<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
]>
<?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc strict="yes" ?>
<?rfc compact="yes" ?>
<?rfc sortrefs="yes" ?>
<?rfc colonspace="yes" ?>
<?rfc rfcedstyle="no" ?>
<!-- Don't change this. It breaks stuff -->
<?rfc tocdepth="4"?>
<rfc category="std" docName="draft-rescorla-callerid-fallback-00"
     ipr="pre5378Trust200902">
  <front>
    <title abbrev="Caller-ID Fallback">Secure Caller-ID Fallback Mode</title>

    <author fullname="Eric Rescorla" initials="E.K." surname="Rescorla">
      <organization>RTFM, Inc.</organization>

      <address>
        <postal>
          <street>2064 Edgewood Drive</street>

          <city>Palo Alto</city>

          <region>CA</region>

          <code>94303</code>

          <country>USA</country>
        </postal>

        <phone>+1 650 678 2350</phone>

        <email>ekr@rtfm.com</email>
      </address>
    </author>

    <date day="17" month="May" year="2013" />

    <area>RAI</area>

<!--    <workgroup>RTCWEB</workgroup> -->

    <abstract>
      <t>
        A major challenge with RFC 4474-style identity assertions
        has been that there are many intermediaries which modify
        the message. Such intermediaries may either remove the
        signature/authentication block entirely or mangle some
        of the fields that it signs, thus breaking the signature.
        This document describes a mechanism for two compliant
        endpoints to exchange authentication data even in the
        face of intermediaries which remove all additional
        call signaling meta-data.
      </t>
    </abstract>
    <note title="Legal">
      <t>THIS DOCUMENT AND THE INFORMATION CONTAINED THEREIN ARE PROVIDED ON
      AN &ldquo;AS IS&rdquo; BASIS AND THE CONTRIBUTOR, THE ORGANIZATION
      HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE
      IETF TRUST, AND THE INTERNET ENGINEERING TASK FORCE, DISCLAIM ALL
      WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY
      WARRANTY THAT THE USE OF THE INFORMATION THEREIN WILL NOT INFRINGE ANY
      RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A
      PARTICULAR PURPOSE.</t>
    </note>
  </front>

  <middle>
    <section anchor="sec-term" title="Terminology">
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
      document are to be interpreted as described in <!--<xref
      target="RFC2119">RFC 2119</xref>.--></t>
    </section>

    <section title="Introduction" anchor="sec.introduction">
      <t>
        A major challenge with RFC 4474-style identity assertions
        has been that there are many intermediaries which modify
        the message. Such intermediaries may either remove the
        signature/authentication block entirely or mangle some
        of the fields that it signs, thus breaking the signature.
        This document describes a mechanism for two compliant
        endpoints to exchange authentication data even in the
        face of intermediaries which remove all additional
        call signaling meta-data.
      </t>
    </section>
    <section title="Operating Environment" anchor="sec.environment">
      <t>
        This section describes the environment in which the proposed
        mechanism is intended to operate. In the simplest setting,
        Alice is calling Bob through some set of gateways and/or the
        PSTN. Both Alice and Bob have smart devices which we can modify,
        but they do not have a clear connection between them:
        Alice cannot inject any data into the system which Bob
        can read, with the exception of her asserted E.164 number.
        Thus, this number is the only value which can be used for
        coordination.
        [[ OPEN ISSUE: Is it possible to put in a false number and
        use that as a channel? ]]
      </t>
      <figure>
        <artwork align="left" alt="" height="" name="" type="" width=""
                 xml:space="preserve"><![CDATA[
                           +---------+
                          /           \
                      +---             +---+
 +----------+        /                      \        +----------+
 |          |       |        Gateways        |       |          |
 |   Alice  |<----->|         and/or         |<----->|    Bob   |
 | (caller) |       |          PSTN          |       | (callee) |             
 +----------+        \                      /        +----------+
                      +---             +---+
                          \           /
                           +---------+
                           ]]></artwork>
      </figure>
      <t>
        In a more complicated setting, Alice and/or Bob may not have
        a programmable device, but have a programmable gateway that services
        them, as shown below:
      </t>
      <figure>
        <artwork align="left" alt="" height="" name="" type="" width=""
                 xml:space="preserve"><![CDATA[
                            +---------+
                           /           \
                       +---             +---+
 +----------+  +--+   /                      \   +--+  +----------+
 |          |  |  |  |        Gateways        |  |  |  |          |
 |   Alice  |<-|GW|->|         and/or         |<-|GW|->|    Bob   |
 | (caller) |  |  |  |          PSTN          |  |  |  | (callee) |             
 +----------+  +--+   \                      /   +--+  +----------+
                       +---             +---+
                           \           /
                            +---------+
                            ]]></artwork>
      </figure>
      <t>
        In such a case, Alice might have an analog connection to her
        gateway/switch which is responsible for her identity.  Similarly, the
        gateway would verify Alice's identity, generate the right caller-id
        information and provide caller-id information to Bob using ordinary
        POTS mechanisms.
      </t>
    </section>
    <section title="Solution Overview" anchor="sec.solution-overview">
      <t>
        Our proposed solution contains two major elements:
      </t>
      <t>
        <list style="symbols">
          <t>Each phone number in the system--or perhaps a gateway acting
          on its behalf--is associated with a set of credentials which
          can be used to prove ownership of that number.</t>
          <t></t>
          <t>A centralized verification server which a caller and a callee
          can use to jointly establish the provenance of the call.</t>
        </list>
      </t>
      <t>
        Prior to placing a call, the caller contacts the verification
        server and stores a record indicating his intention to call
        the callee. Once the callee receives the indication of an
        incoming call, he contacts the verification server to verify
        the validity of the call. If that check succeeds, he can
        then present the callerid information as valid. Otherwise,
        the call is unverifiable. Note that this does not necessarily mean
        that the call is bogus; because we expect incremental
        deployment many legitimate calls will be unverifiable.
      </t>
    </section>

    <section title="Phone Number Authentication" anchor="sec.authentication">
      <t>
        Each phone number in the system is associated with a set of
        credentials which can be used to prove ownership of that number. For
        purposes of exposition we will assume that ownership is associated
        with the endpoint (e.g., a smartphone) but it might well be associated
        with a gateway acting for the endpoint instead.
      </t>
      <t>
        These credentials might be usable for two purposes:
      </t>
      <t>
      <list style="symbols">
        <t>To authenticate to a centralized verification server.</t>
        <t>To authenticate to other endpoints.</t>
      </list>
      </t>
      <t>
        Most likely the credentials will be an asymmetric key pair
        authenticated by a certificate chain, in which case it
        would be usable for both purposes. However, they might
        also be a simple shared key with the verification server,
        in which case they could only be used to authenticate
        to the server, not to other endpoints.
      </t>
      <t>
        The enrollment process itself is described in another document
        [TODO: REF]. For purposes of this document, we simply
        assume that elements have somehow obtained credentials.
      </t>
    </section>

    <section title="Verification Service" anchor="sec.verification-service">
      <t>
        An overview of the basic calling and verification process is
        shown below. In this diagram, we assume that Alice has the number
        +1.111.111.1111 and Bob has the number +2.222.222.2222.
      </t>
      <figure>
        <artwork align="left" alt="" height="" name="" type="" width=""
                 xml:space="preserve"><![CDATA[
Alice                       Verification Server                     Bob
-----------------------------------------------------------------------
<-  Authenticate as 1.111.111.1111  ->

Store 1.111.111.1111:1.222.222.2222 ->

Call from 1.111.111.1111 ---------------------------------------------->

                                    <- Authenticate as 1.222.222.2222 ->

                                    <-------------- Retrieve call record
                                         1.111.111.1111:1.222.222.2222 ?

                                    Call record for ------------------->
                                    1.111.111.1111:1.222.222.2222

                                               [Ring phone with callerid
                                                       = 1.111.111.1111]
                                      ]]></artwork>
      </figure>
      <t>
        When Alice wishes to make a call to Bob, she must first contact
        the Verification Service (VS). She authenticates to the VS, thus
        proving her ownership of her E.164 number. Once she has authenticated,
        she then stores a Call Data Record (CDR) on the VS. We will discuss the
        contents of the CDR below, but minimally it contains the
        pair [Calling-number, Called-number].
      </t>
      <t>
        Once Alice has stored the CDR, she then places the call to Bob
        as usual. At this point, Bob's phone would usually ring and
        display Alice's number (+1.111.111.1111), which is provided
        by the usual caller-id mechanisms [TODO: name of field].
        Instead, Bob's phone transparently contacts the verification service.
      </t>
      <t>
        In order to verify the call, Bob's phone must first authenticate to
        the VS (this protects caller privacy, as detailed in <xref
        target="sec.priv-cons"/>). Once he has authenticated, he
        asks whether there is a current CDR for a call from
        Alice's number to his number. The VS responds with the
        CDR (assuming it exists). Once Bob's phone
        has verified the existence of the appropriate CDR,
        it can then alert Bob to the incoming call and show
        Alice's caller-id information.
      </t>
      <section title="Substitution Attacks">
        <t>
          The security properties of this mechanism are fairly limited:
          all that receipt of the CDR proves is that Alice tried to
          call Bob. It does not prove that this particular incoming
          call is from Alice. Consider the scenario in which we have
          a service which provides an automatic callback to a user-provided
          number. In that case, the attacker can arrange for a
          false caller-id value, as shown below:
        </t>
        <figure>
        <artwork align="left" alt="" height="" name="" type="" width=""
                 xml:space="preserve"><![CDATA[
Attacker            Callback Service              VS                 Bob
-----------------------------------------------------------------------
Place call to Bob ---------->

                            Store CDR for
                            CS:Bob -------------->

Call from CS (forged caller-id info)  -------------------------------->

                            Call from CS ---------------------------> X


                            <------------------ Retrieve CDR for CS:Bob

                            CDR for CS:Bob --------------------------->

                                        [Ring phone with callerid = CS]
                                      ]]></artwork>
      </figure>
      <t>
        In order to mount this attack, the attacker contacts the Callback
        Service (CS) and provides it with Bob's number. This causes the CS
        to initiate a call to Bob. As before, the CS contacts the VS
        to insert an appropriate CDR and then initiates a call to
        Bob. However, the attacker simultaneously initiates a call to
        Bob using forged caller-id information corresponding to the
        CS. If he wins the race with the CS, then Bob's phone will
        attempt to verify the attacker's call (and succeed since they
        are indistinguishable) and the CS's call will go to
        busy/voice mail/call waiting.
      </t>
      </section>

      <section title="Privacy Mode" anchor="sec.privacy-mode">
        <t>
          The major privacy drawback with the design listed above
          is that the verification server learns about every call.
          However we are willing to make somewhat stronger assumptions about
          user credentials, we can provide significantly stronger
          privacy protections. Instead of merely assuming that the
          user has some credential we assume that their credential
          is in the form of an asymmetric key pair (or pairs) which can be
          used for both signature and encryption. Further, we assume
          that there is some central directory of the credentials
          which are associated with any number.
        </t>
        <t>
          Under these conditions, we can make three minor modifications
          to the protocol which signficantly enhance privacy:
        </t>
        <t>
          <list style="symbols">
            <t>Each CDR is stored only under the caller's number.</t>
            <t>CDRs are encrypted under the callee's private key.</t>
            <t>If someone requests a nonexistent CDR from the VS,
            it returns a randomly generated CDR.</t>
          </list>
        </t>
        <t>
          The new protocol is shown below:
        </t>
      <figure>
        <artwork align="left" alt="" height="" name="" type="" width=""
                 xml:space="preserve"><![CDATA[
Alice                       Verification Server                     Bob
-----------------------------------------------------------------------
<-  Authenticate as 1.111.111.1111  ---->

Store E(1.222.222.2222,1.111.111.1111) ->

Call from 1.111.111.1111 ---------------------------------------------->


                                    <-------------- Retrieve call record
                                                         1.111.111.1111?

                                    E(1.222.222.2222,1.111.111.1111) -->

                                               [Ring phone with callerid
                                                       = 1.111.111.1111]
                                      ]]></artwork>
      </figure>
      <t>
        This version of the protocol works nearly the same as that
        described in <xref target="sec.verification-service"/> but
        because the CDR is encrypted for the callee, the VS does not
        learn who the caller is calling. Instead, the VS simply
        learns that the caller is calling someone and that later
        someone retrieved the CDR. The VS might choose to use traffic
        analysis to determine the identity of the caller and callee,
        but they can use an anonymity network such as Tor to thwart
        this.
      </t>
      <t>
        Once the the callee retrieves the encrypted CDR, he decrypts
        it with his private key. If the call was for him, then he
        can read it (and likely verify a signature). If not it is
        simply random data and can be rejected. The result is that even though we do 
        not require callee authentication, anyone not the callee cannot determine
        who the caller is calling. In order to reduce the risk of
        attackers measuring the caller's call rate, the VS just
        returns random (though consistent) replies when a nonexistent
        CDR is requested. It is not possible for an attacker to distinguish
        these replies from CDRs encrypted to someone other than himself.
      </t>
      </section>
      <section title="Escalation to VoIP" anchor="sec.voip-escalation">
        <t>
          If the call is to be carried over the PSTN, then the security
          properties described above are about the best we can do.
          However, if Alice and Bob are both VoIP capable, then
          there is an opportunity to provide a higher quality of
          service and security. The basic idea is that the CDR
          contains rendezvous information for Alice (e.g.,
          Alice's SIP URI). Once Bob has verified Alice's CDR,
          he can initiate a VoIP connection directly to Alice,
          thus bypassing the PSTN. This connection can be initiated
          either in serial (i.e., instead of ringing the phone)
          or in parallel (i.e., starting with a POTS call and
          then switching over to the VoIP call.)
        </t>
      </section>
    </section>

    <section title="Privacy Considerations" anchor="sec.priv-cons">
      <t>
      </t>
    </section>

    <section title="Security Considerations" anchor="sec.sec-cons">
      <t>
      </t>
    </section>

    </middle>
    <back>
    </back>
  </rfc>

