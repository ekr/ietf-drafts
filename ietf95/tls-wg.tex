\documentclass[helvetica]{seminar} 
\input{xy}
\xyoption{all}
\usepackage{graphicx} 
\usepackage{slidesec} 
\usepackage{url}
\usepackage[framemethod=TikZ]{mdframed}
\usepackage{color}

\long\def\symbolfootnote[#1]#2{\begingroup%
\def\thefootnote{\fnsymbol{footnote}}\footnote[#1]{#2}\endgroup}

% to fix problems making landscape seminar pdfs
% Letter...
\pdfpagewidth=11truein
\pdfpageheight=8.5truein
\pdfhorigin=1truein     % default value(?), but doesn't work without
\pdfvorigin=1truein     % default value(?), but doesn't work without
% A4
%\pdfpagewidth=297truemm % your milage may vary....
%\pdfpageheight=210truemm
%\pdfhorigin=1truein     % default value(?), but doesn't work without
%\pdfvorigin=1truein     % default value(?), but doesn't work without


\renewcommand{\familydefault}{\sfdefault}  
 
\input{seminar.bug} 
\input{seminar.bg2} % See the Seminar bugs list 
 
\slideframe{none} 
 
 
\usepackage{fancyhdr} 
 
% Headers and footers personalization using the `fancyhdr' package 
\fancyhf{} % Clear all fields 
\renewcommand{\headrulewidth}{0mm} 
\renewcommand{\footrulewidth}{0.1mm} 
 
\fancyfoot[L]{\tiny IETF 95} 
\fancyfoot[C]{\tiny TLS}
\fancyfoot[R]{\tiny \theslide} 
 
 
% To center horizontally the headers and footers (see seminar.bug) 
\renewcommand{\headwidth}{\textwidth} 

% To adjust the frame length to the header and footer ones 
\autoslidemarginstrue 
\pagestyle{fancy} 
 

\newcommand{\heading}[1]{% 
  \begin{center} 
    \large\bf 
    #1 
  \end{center} 
  \vspace{.4 in}} 



\begin{document}

\begin{slide}
\begin{center}
\vspace{.5 in}
\LARGE{{\bf}TLS 1.3\\{\small \verb^draft-ietf-tls-tls13-12^}}\\
\vspace{.2in}
\large{
\begin{tabular}{c}
Eric Rescorla\\
Mozilla\\
\url{ekr@rtfm.com}
\end{tabular}
}
\end{center}

\end{slide}

\centerslidesfalse 


\begin{slide}
\heading{Overview}

\begin{itemize}
\item Changes since draft-10
\item Outstanding consensus calls
\item 1-RTT PSK and session tickets
\item Context values
\item Key schedule and key separation
\item 0-RTT details
\item Minor issues
\end{itemize}
\end{slide}

\begin{slide}
\heading{Changes since draft-10}

\begin{itemize}
\item Restructure authentication along uniform lines *
\item Restructure 0-RTT record layer *
\item Reset sequence numbers on key changes 
\item Import CFRG Curves
\item Zero-length additional data for AEAD
\item Revised signature algorithm negotiation *
\item Define exporters *
\item Add anti-downgrade mechanism *
\item Add PSK cipher suites
\item Other editorial
\end{itemize}
\end{slide}

\begin{slide}
\heading{Restructuring Authentication}

\begin{itemize}
\item TLS 1.3 has four authentication contexts
  \begin{itemize}
  \item 1-RTT server
  \item 1-RTT client
  \item 0-RTT client\symbolfootnote[2]{Marked for death.}
  \item Post-handshake
  \end{itemize}

\item All were slightly different
\item draft-12 unifies them into one common idiom
\end{itemize}
\end{slide}


\begin{slide}
\heading{TLS 1.3 Authentication Block}

\begin{itemize}
\item Three messages: Certificate*, CertificateVerify*, Finished
\item Inputs
  \begin{itemize}
  \item Handshake Context (generally the handshake hash)
  \item Certificate/signing key
  \item Base key for MAC key
  \end{itemize}

\item CertificateVerify = {\small \verb^digitally-sign(Hash(Handshake Context + Certificate))^\symbolfootnote[1]{Includes disambiguating context string.}}
\item Finished = \\
  {\small \verb^HMAC(finished_key, Handshake Context + Certificate + CertificateVerify)^}
\item Different finished keys for each direction (based on Base Key)
\end{itemize}
\end{slide}


\begin{slide}
\heading{Eye Chart}

{\scriptsize
\begin{verbatim}
   +----------------+-----------------------------------------+--------+
   | Mode           | Handshake Context                       | Base   |
   |                |                                         | Key    |
   +----------------+-----------------------------------------+--------+
   | 0-RTT          | ClientHello + ServerConfiguration +     | xSS    |
   |                | Server Certificate + CertificateRequest |        |
   |                | (where ServerConfiguration, etc. are    |        |
   |                | from the previous handshake)            |        |
   |                |                                         |        |
   | 1-RTT (Server) | ClientHello ... ServerConfiguration     | master |
   |                |                                         | secret |
   |                |                                         |        |
   | 1-RTT (Client) | ClientHello ... ServerFinished          | master |
   |                |                                         | secret |
   |                |                                         |        |
   | Post-Handshake | ClientHello ... ClientFinished +        | master |
   |                | CertificateRequest                      | secret |
   +----------------+-----------------------------------------+--------+
\end{verbatim}
}
\end{slide}


\begin{slide}
\heading{Restructure 0-RTT Record Structure}

\begin{itemize}
\item draft-10 had a somewhat idiosyncratic design
\item draft-12 0-RTT parallels 1-RTT
  \begin{itemize}
  \item \verb^handshake^ for handshake data
  \item \verb^application_data^ for application data
  \item New \verb^end_of_early_data^ (warning) alert for separation
  \item Separate handshake and traffic keys
  \end{itemize}
\end{itemize}

\end{slide}

\begin{slide}
\heading{Revised Signature Algorithm Negotiation (I) (davidben)}

\begin{itemize}
\item TLS 1.2:
\end{itemize}

{\scriptsize
\begin{verbatim}
      struct {
            HashAlgorithm hash;
            SignatureAlgorithm signature;
      } SignatureAndHashAlgorithm;
\end{verbatim}
}

\begin{itemize}
\item Curves were orthogonal (\verb^supported_curves^)
\item It seemed like a good idea at the time
\item ... but new signatures algorithms are tied to one hash for each curve size
\item Proposal from davidben: define a new structure that ties everything together
\end{itemize}
\end{slide}

\begin{slide}
\heading{Revised Signature Algorithm Negotiation (II)}

{\scriptsize
\begin{verbatim}
      enum {
          // RSASSA-PKCS-v1_5 algorithms.
          rsa_pkcs1_sha1 (0x0201),
          rsa_pkcs1_sha256 (0x0401),
          rsa_pkcs1_sha384 (0x0501),
          rsa_pkcs1_sha512 (0x0601),

          ...
      } SignatureScheme;
\end{verbatim}
}

\begin{itemize}
\item These line up with the existing code points
\item New code points define the triplet: signature algorithm, curve, hash
\end{itemize}
\end{slide}

\begin{slide}
\heading{Define Exporters}

\begin{itemize}
\item RFC 5705 defined exporters in terms of the PRF
  \begin{itemize}
  \item We removed the PRF....
  \end{itemize}

\item New definition:
\end{itemize}


{\scriptsize
\begin{verbatim}
   HKDF-Expand-Label(HKDF-Extract(0, exporter_secret),
                     label, context_value, length)
\end{verbatim}
}

\begin{itemize}
\item Note: this doesn't cover 0-RTT. More on this later.
\end{itemize}
\end{slide}


\begin{slide}
\heading{Anti-Downgrade Mechanism I (Green/Bhargavan)}

\begin{itemize}
\item TLS 1.2 and below downgrade defense was tied to the Finished message
\item TLS 1.3 downgrade is tied to both Finished and server CertificateVerify
  \begin{itemize}
  \item So TLS 1.3 resists downgrade even when the key exchange is weak
  \item ... but what about downgrade to TLS 1.2 or 1.1
  \end{itemize}
\end{itemize}
\end{slide}

\begin{slide}
\heading{Anti-Downgrade Mechanism II (Green/Bhargavan)}

\begin{itemize}
\item Countermeasure: taint the \verb^ServerRandom^
  \begin{itemize}
  \item If server supports TLS 1.2 or TLS 1.3 but client offers a lower version use a special \verb^ServerRandom^
    \begin{itemize}
    \item Top eight bytes are \verb^44 4F 57 4E 47 52 44 01^ (TLS 1.3) or \verb^44 4F 57 4E 47 52 44 00^
    \item This is covered by the server signature
    \end{itemize}
  \item Clients MUST check
  \end{itemize}

\item This doesn't protect you if you negotiate to static RSA
  \begin{itemize}
  \item Didn't you want PFS anyway
  \end{itemize}
\end{itemize}
\end{slide}



\begin{slide}
\heading{Mailing List Recap: 0-RTT Client Authentication}

\begin{itemize}
\item Current design: client signs the \verb^ClientHello+...<Server context>^
  \begin{itemize}
  \item The authentication is tied to the client's (EC)DH share
  \end{itemize}

\item This is very brittle
  \begin{itemize}
  \item Effectively it's a long-term DH certificate
    \begin{itemize}
    \item Modulo anti-replay issues
    \end{itemize}
  \item Compromise of either DH share allows impersonation
  \end{itemize}

\item 0-RTT PSK also scary

\item Proposal on list: Remove 0-RTT Client Authentication entirely
\end{itemize}
\end{slide}


\begin{slide}
\heading{(EC)DHE-based 0-RTT}

\vspace{-2ex}

\begin{itemize}
\item Currently we have 0-RTT modes
  \begin{itemize}
  \item (EC)DHE: Server provides (EC)DHE static key in ServerConfiguration and pairs it with its ephemeral
  \item PSK: Based on session ticket
  \end{itemize}

\item Proposal: only do the PSK-based mode (Fournet et al., Sullivan et al.)
  \begin{itemize}
  \item People are going to want to do PSK-resumption anyway for perf reasons
  \item Implicit binding between connection parameters
  \item No need for a ServerConfiguration object
  \item The crypto analysis of (EC)DHE 0-RTT is tricky
  \item Can always re-phrase DH as a ``PSK type'' later
  \end{itemize}
\end{itemize}
\end{slide}


\begin{slide}
\heading{Objection: What about out-of-band priming?}

\begin{itemize}
\item You can publish an (EC)DH key (e.g., in the DNS)
  \begin{itemize}
  \item 0RTT-PSK isn't compatible with out-of-band priming (duh!)
  \end{itemize}

\item But...
  \begin{itemize}
  \item This brings in all the concerns about delegation
  \item No really plausible priming mechanism (DNS not viable)
  \item See previous comments about DH-as-PSK
  \end{itemize}
\end{itemize}
\end{slide}


\begin{slide}
\heading{Objection: Security impact of client-side storage}

\begin{itemize}
\item Storing a DH public key requires only storage integrity
\item Storing a PSK requires secrecy
\item But...
  \begin{itemize}
  \item Client-side secure storage already needed for session caching
  \item Generally session caches don't survive program shutdown
  \item Google's measurements in QUIC show this has no performance impact versus long-term storage
  \end{itemize}
\end{itemize}
\end{slide}


\begin{slide}
\heading{Objection: PFS}

\begin{itemize}
\item With (EC)DHE you get
  \begin{itemize}
  \item No PFS for 0-RTT data
  \item PFS for 1-RTT data
  \end{itemize}

\item Can do PSK 0-RTT two ways
  \begin{itemize}
  \item PSK only (no PFS)
  \item PSK-(EC)DHE (same PFS as with DH 0-RTT)
  \end{itemize}

\item Note: can do better with server-side state as opposed to tickets
\end{itemize}

\end{slide}


\begin{slide}
\heading{Objection: WebRTC}

\begin{itemize}
\item WebRTC might have a use for this
\item But...
  \begin{itemize}
  \item We have a different hack for that (\verb^draft-rescorla-dtls-in-udp^)
  \end{itemize}
\end{itemize}

\end{slide}

\begin{slide}
\heading{Objection: Server Proof of Private Key}

\begin{itemize}
\item The DHE 0-RTT mode forces the server to re-sign every time
  \begin{itemize}
  \item The point of PSK is to avoid the server doing that
  \end{itemize}

\item This creates a tradeoff between 0-RTT and continuing proof of server key
\item Solution: Allow 0-RTT PSK to be used with signed (EC)DHE exchange
\end{itemize}
\end{slide}


\begin{slide}
\heading{Proposal: Remove 0-RTT DHE-based mode}

\begin{itemize}
\item The only 0-RTT mode will be PSK
\item We can re-add 0-RTT DH mode later if needed
  \begin{itemize}
  \item Probably more oriented towards external priming
  \end{itemize}
\end{itemize}
\end{slide}


\begin{slide}
\heading{NewSessionTicket Format (Bhargavan)}

\vspace{-2ex}
\begin{itemize}
\item NewSessionTicket just has expiry.... more information needed
  \begin{itemize}
  \item Cipher suites the server would accept (ECHDE-PSK or PSK, especially)
  \item Which 0-RTT modes you would accept: None, Replayable, All (????)
  \end{itemize}
\end{itemize}

{\scriptsize
\begin{verbatim}
            enum {
                    no_early_data_allowed(0),
                    replayable_early_data_allowed (1),
                    all_early_data_allowed(2),
                    (65535)
             } EarlyDataType;
          
             uint32 ticket_lifetime;
                   opaque ticket<0..2^16-1>;
                   CipherSuite cipher_suites<2..2^16-2>;
                   EarlyDataType early_data_type
             } NewSessionTicket;
\end{verbatim}
}
\end{slide}


\begin{slide}
\heading{0-RTT PSK Extensions I}

\begin{itemize}
\item We do need extensions to contextualize 0-RTT data
  \begin{itemize}
  \item ALPN
  \item Elapsed time (PR\#437)
  \end{itemize}

\item Where do they go?
  \begin{itemize}
  \item EarlyDataIndication.extensions
  \item EncryptedExtensions (let's add this back)
  \end{itemize}

\item Relationship to original connection
\end{itemize}

\end{slide}


\begin{slide}
\heading{0-RTT PSK Extensions II: Where do they go?}

\begin{itemize}
\item EarlyDataIndication has an extensions field
  \begin{itemize}
  \item But this is in the clear
  \item As much stuff as possible should be secret
  \end{itemize}

\item We have gone back and forth on client EncryptedExtensions
  \begin{itemize}
  \item We should add it back
  \item Minimally want it for privacy-leaking data like elapsed time
  \item Semantics: \emph{only} apply to the 0-RTT data
  \end{itemize}

\item Proposed dividing line: same as for ServerHello.extensions/EncryptedExtensions
\end{itemize}
\end{slide}


\begin{slide}
\heading{0-RTT PSK Extensions III: Semantics}

\vspace{-2ex}
\begin{itemize}
\item Two basic options
  \begin{itemize}
  \item Omit all the extensions and require both sides to use what was picked last time
  \item Client sends the relevant extensions (defining what it expects the server to want)
    and the server can reject if it choked
  \end{itemize}

\item ``Matching'' options
  \begin{itemize}
  \item Extensions must match the 1-RTT negotiation (Requires both sides to keep the same configuration)
  \item Extensions must match the last negotiation (Requires both sides to remember)
  \end{itemize}

\item Proposal: extensions MUST be the same as last time and server must reject 0-RTT if its config changes
\end{itemize}

\end{slide}


\begin{slide}
\heading{Rejection of 0-RTT: HelloRetryRequest (Bhargavan)}

\begin{itemize}
\item Setting: client offers PSK with 0-RTT
\item ... server sends \verb^HelloRetryRequest^
\item What happens to the 0-RTT data
  \begin{itemize}
  \item Can it be resent on the next flight
  \end{itemize}

\item Proposal: No. HelloRetryRequest sends you back to the beginning.
\end{itemize}
\end{slide}


\begin{slide}
\heading{Rejection of 0-RTT: Finding the next handshake block}

\begin{itemize}
\item What happens if server rejects 0-RTT?
\item Need to skip ahead to next non 0-RTT client message
  \begin{itemize}
  \item \verb^HelloRetryRequest^ $\rightarrow$ wait for \verb^ClientHello^
  \item \verb^ServerHello^ $\rightarrow$ wait for \verb^Certificate^ or \verb^Finished^
  \end{itemize}
  
\item Right now this means trial-decryption
\item Karthik suggests that the client sends \verb^end_of_early_data^ alert in the clear upon rejection
  \begin{itemize}
  \item Probably easier to implement, very slightly worse privacy
  \end{itemize}

\item Proposal: Adopt this
\end{itemize}
\end{slide}


\end{document}  
                