<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc iprnotified="no" ?>
<?rfc strict="no" ?>
<?rfc compact="yes" ?>
<?rfc sortrefs="no" ?>
<?rfc colonspace="yes" ?>
<?rfc rfcedstyle="no" ?>
<rfc category="std" docName="draft-bryan-p2psip-reload-04" ipr="full3978">
  <front>
    <title abbrev="RELOAD">REsource LOcation And Discovery (RELOAD)</title>

    <author fullname="Cullen Jennings" initials="C." surname="Jennings">
      <organization>Cisco</organization>

      <address>
        <postal>
          <street>170 West Tasman Drive</street>

          <street>MS: SJC-21/2</street>

          <city>San Jose</city>

          <region>CA</region>

          <code>95134</code>

          <country>USA</country>
        </postal>

        <phone>+1 408 421-9990</phone>

        <email>fluffy@cisco.com</email>
      </address>
    </author>

    <author fullname="Bruce B. Lowekamp" initials="B. B." surname="Lowekamp">
      <organization>SIPeerior Technologies</organization>

      <address>
        <postal>
          <street>3000 Easter Circle</street>

          <city>Williamsburg</city>

          <region>VA</region>

          <code>23188</code>

          <country>USA</country>
        </postal>

        <phone>+1 757 565 0101</phone>

        <email>lowekamp@sipeerior.com</email>
      </address>
    </author>

    <author fullname="Eric Rescorla" initials="E.K." surname="Rescorla">
      <organization>Network Resonance</organization>

      <address>
        <postal>
          <street>2064 Edgewood Drive</street>

          <city>Palo Alto</city>

          <region>CA</region>

          <code>94303</code>

          <country>USA</country>
        </postal>

        <phone>+1 650 320-8549</phone>

        <email>ekr@networkresonance.com</email>
      </address>
    </author>

 
    <author fullname="Salman A. Baset" initials="S.A." surname="Baset">
      <organization>Columbia University</organization>

      <address>
        <postal>
          <street>1214 Amsterdam Avenue</street>

          <city>New York</city>

          <region>NY</region>

          <country>USA</country>
        </postal>

        <email>salman@cs.columbia.edu</email>
      </address>
    </author>

    <author fullname="Henning Schulzrinne" initials="H.G."
            surname="Schulzrinne">
      <organization>Columbia University</organization>

      <address>
        <postal>
          <street>1214 Amsterdam Avenue</street>

          <city>New York</city>

          <region>NY</region>

          <country>USA</country>
        </postal>

        <email>hgs@cs.columbia.edu</email>
      </address>
    </author>

    <date month="May" year="2008" />

    <area>RAI</area>

    <workgroup>P2PSIP</workgroup>

    <abstract>
      <t>This document defines REsource LOcation And Discovery (RELOAD), a
      peer-to-peer (P2P) binary signaling protocol for use on the Internet. A
      P2P signaling protocol provides its clients with an abstract hash table
      service between a set of cooperating peers that form the overlay
      network. RELOAD is designed to support a P2P Session Initiation Protocol
      (P2PSIP) network, but can be utilized by other applications with similar
      requirements by defining new usages that specify the data kinds that
      must be stored for a particular application. RELOAD defines a security
      model based on a certificate enrollment service that provides unique
      identities. NAT traversal is a fundamental service of the protocol.
      RELOAD also allows access from "client" nodes which do not need to route
      traffic or store data for others.</t>
    </abstract>
  </front>

    <!-- This prologue contains the basic definitions for the struct language -->

          <!-- begin-prologue 
                EKR commented out

        <figure>

          <artwork><![CDATA[
primitive uint8 8;
primitive uint16 16;
primitive uint24 24;
primitive uint32 32;
primitive int32 32;
primitive uint64 64;
primitive uint128 128;
primitive char 8;
primitive opaque 8;
primitive blob 0;
typedef char string<65000>;

primitive peer_id 128;
typedef  opaque resource_id<255>;
typedef uint32 overlay;
typedef uint64 transaction_id;
typedef uint32 kind_id;
typedef uint64 generation_counter;

           struct  {
                   uint32 addr;
                   uint16 port;
           } ip4_addr_port;

           struct  {
                   uint128 addr;
                   uint16 port;
           } ip6_addr_port;

           enum {ip4_address_type (1), ip6_address_type (2)} address_type;
           
           select {
             case ip4_address_type:
               ip4_addr_port v4;
             case ip6_address_type:
              ip6_addr_port v6;           
           } ip_address_and_port;

              ]]></artwork>

        </figure>
      
           end-prologue -->

  <middle>
    <section title="Introduction">
    
<!--      <t>[TODO: HGS]</t> -->

      <t>This document defines REsource LOcation And Discovery (RELOAD), a
      peer-to-peer (P2P) signaling protocol for use on the Internet. It
      provides a generic, self-organizing overlay network service, allowing nodes 
      to efficiently route messages to other nodes based on node-id
      and to efficiently store and retrieve data in the overlay.
      RELOAD is a lightweight,
      binary protocol. It provides several functions that are critical for a
      successful P2P protocol for the Internet:
      </t>
      <t><list style="hanging">
          <t></t>
	  <t hangText="Security Framework:">
	    A P2P network will often be established among a set of
	    peers that do not trust each other.  RELOAD leverages a central
	    enrollment to provide credentials for each peer which can then be used
	    to authenticate each operation. This greatly reduces the possible
	    attack surface.
	  </t>

          <t></t>
	  <t hangText="Usage Model:">
	    RELOAD is designed to support a variety of applications, including P2P
	    multimedia communications with the Session Initiation Protocol <xref
	    target="I-D.ietf-p2psip-concepts"></xref>. RELOAD allows the
	    definition of new application usages, each of which can define its
	    own data types, along with the rules for their use. This
	    allows RELOAD to be used with new applications through a simple
	    documentation process that supplies the details for each
	    application.
	  </t>

          <t></t>
	  <t hangText="NAT Traversal:">
	    RELOAD is designed to function in environments where many
	    if not most of the nodes are behind NATs or firewalls. 
	    Operations for NAT traversal are part
	    of the base design, including establishing new RELOAD connections
	    and tunneling SIP or other application protocols required by P2PSIP.
	  </t>

          <t></t>
	  <t hangText="High Performance Routing:">
	    The very nature of DHT algorithms introduces a requirement
	    that peers participating in the P2P network route requests on behalf
	    of other peers in the network.  This introduces a load on those other
	    peers, in the form of bandwidth and processing power. RELOAD has been
	    defined with a simple, lightweight forwarding header, thus minimizing
	    the amount of effort required by intermediate peers.
	  </t>

<!-- EKR removed (this doesn't seem first class
          <t></t>
	  <t hangText="Transport Flexibility:">
	    RELOAD has native support for both DTLS and TLS for the underlying transport protocol, with
          support for DTLS over UDP as mandatory to implement. TLS over TCP is
          preferred because it has better bulk data performance and connection
          stability, but UDP is more likely to provide direct connections
          between peers in the presence of NATs. Explicit support for
          fragmentation is provided and required when using UDP. Because there
          is no single universally available and suitable transport protocol,
          the peer protocol must be flexible in this regard. New transports
          can be supported trivially.</t>
-->
          <t></t>
	  <t hangText="Pluggable DHT Algorithms:">
	    RELOAD has been designed with an abstract interface to the
	    overlay layer to simplify implementing a variety of structured (DHT)
	    and unstructured overlay algorithms. This specification also defines
	    how RELOAD is used with Chord, which is mandatory to
	    implement. Specifying a default "must implement" DHT will allow
	    interoperability, while the extensibility allows selection of DHTs
	    optimized for a particular application.
	  </t>
        </list></t>

      <t>These properties were designed specifically to meet the requirements
      for a P2P protocol to support SIP, and this document defines a
      SIP Usage of RELOAD. However, RELOAD is not limited to
      usage by SIP and could serve as a tool for supporting other P2P
      applications with similar needs. RELOAD is also based on the concepts
      introduced in <xref target="I-D.ietf-p2psip-concepts"></xref>.</t>

      <section title="Architecture">
        
        <t>Architecturally this specification is divided into several layers,
        as shown in the following figure.</t>

        <figure>
          <artwork><![CDATA[
                 Application

            +-------+  +-------+               
            | SIP   |  | XMPP  |  ...                
            | Usage |  | Usage |              
            +-------+  +-------+
          -------------------------------------- Message Routing API
            +------------------+   +---------+
            |                  |<->| Storage |
            |                  |   +---------+
            |      Routing     |        ^
            |       Layer      |        v
            |                  |   +---------+
            |                  |<->|Topology |
            |                  |   | Plugin  |
            +------------------+   +---------+
                      ^                 ^
                      v                 |
            +------------------+ <------+
            |    Forwarding    |
            |       Layer      | 
            +------------------+
          -------------------------------------- Transport API
             +-------+  +------+                              
             |TLS    |  |DTLS  |                           
             +-------+  +------+  
              ]]></artwork>
        </figure>

        <t>The major components of RELOAD are:</t>
	
        <t><list style="hanging">
            <t></t>
	    <t hangText="Usage Layer:">
	      Each application defines reload usage: a set of data
	      kinds and behaviors which describe how to use the services provided by
	      RELOAD. These usages all talk to RELOAD through a common message
	      routing API.
	    </t>
            <t></t>
	    <t hangText="Routing Layer:">
	      The Routing Layer is responsible for routing messages 
	      through the overlay. It talks directly to the topology
	      plugin, which is responsible for implementing the
	      specific topology defined by the DHT being used.
	    </t>
	    
	    <t></t>
	    <t hangText="Storage:">
	      The Storage component is responsible for processing 
	      messages relating to the storage and retrieval of
	      data. It talks directly to the topology plugin and
	      the routing layer in order to send and receive messages
	      and manage data replication.
	    </t>

	    <t></t>
	    <t hangText="Topology Plugin:">
	      The Topology Plugin is responsible for implementing the
	      specific topology defined by the DHT being used.
	      It talks directly to the Routing Layer to send and
	      receive overlay management messages and to the Storage
	      component to manage data replication.
	    </t>

            <t></t>
	    <t hangText="Forwarding Layer:">
	      The Forwarding Layer provides packet forwarding
	      services between nodes. It also handles setting up
	      connections across NATs using ICE.
	    </t>
          </list></t>

        <section title="Usage Layer">
          <t>
	    The top layer, called the Usage Layer, has application
            usages, such as the SIP Location Usage, that use the abstract Message
            Routing API provided by RELOAD. The goal of this layer is to implement
            application-specific usages of the overlay services provided by
            RELOAD. The Usage defines how a specific application maps its data
            into something that can be stored in the DHT, where to store the data,
            how to secure the data, and finally how applications can retrieve and
            use the data.
	  </t>
	  
          <t>
	    The architecture diagram shows both a SIP usage and an XMPP
	    usage. A single application may require multiple usages. A usage may
	    define multiple kinds of data that are stored in the overlay and may
	    also rely on kinds originally defined by other usages. A usage is
	    not itself encoded on the wire, only the kind-ids and data models
	    are, but is rather a specification of the functionality that is
	    required for a given application. That specification typically
	    specifies semantics, access control rules, and the format and size
	    of the data which may be stored.
	  </t>

          <t>
	    One usage may depend on another. For example, the SIP usage
	    depends on a Certificate Store usage (not shown in the diagram) to
	    obtain the certificates required to authenticate messages. Because
	    certificates are stored in standard X.509 form, there is no reason
	    for each usage to specify this service independently.
	  </t>
        </section>

	<section title="Routing Layer">
	  <t>
	    The Routing Layer provides a generic message routing service
	    for the overlay. Each peer is identified by and its location
            in the overlay determined by its Peer-ID that is assigned by the
            enrollment server when the user or peer first enrolls in the
            overlay. A component which is a client of the Routing Layer can perform 
	    two basic functions:
	  </t>
	  <t>
	    <list style="symbols">
	      <t>
		Send a message to a given peer, described by Peer-Id or
		Resource-Id.
	      </t>
	      <t>
		Receive messages that other peers sent to this peer's
		PeerId.
	      </t>
	    </list>
	  </t>
	  <t>
	    All Usages are clients of the Routing Layer and use Reload's
	    services by sending and receiving messages from peers.
	    For instance, when a usage wants to store data, it does
	    so by sending STORE requests.
	    Note that the Storage component and the Topology Plugin
	    are themselves clients of the Routing Layer, because they
	    need to send and receive messages from other peers. 
	  </t>

          <t>
	    The Routing Layer provides a fairly
	    generic interface that allows the topology plugin control the
	    overlay and resource operations and messages. Since each DHT is
	    defined and functions differently, we generically refer to the table
	    of other peers that the DHT maintains and uses to route requests
	    (neighbors) as a Routing Table. The Routing Layer component makes queries to
	    the DHT's Routing Table to determine the next hop, then encodes and
	    sends the message itself. Similarly, the DHT issues periodic update
	    requests through the logic component to maintain and update its
	    Routing Table.
	  </t>
	</section>
	<section title="Storage">
	  <t>
	    One of the major functions of RELOAD is to allow peers
	    to store data in the overlay and to retrieve data
	    stored by other peers or by themselves. The Storage
	    component is responsible for processing data
	    storage and retrieval messages from other peers.
	    For instance, the Storage component might receive
	    a STORE request for a given resource from the
	    Routing Layer. It would then store the data value(s)
	    in its local data store and sends a response to the
	    Routing Layer for delivery to the requesting peer.
	  </t>
	  <t>
	    The node's Peer-ID determines the set of resources which it
	    will be responsible for storing. However, the exact mapping
	    between these is determined by the DHT algorithm used by the
	    overlay, therefore the Storage component always the 
	    queries the topology plugin to determine where a particular
	    resource should be stored.
	  </t>
	</section>
	<section title="Topology Plugin">
	  <t>
	    RELOAD is explicitly designed to work with a variety of
	    DHTs. In order to facilitate this, the DHT implementation
	    is provided by a pluggable Topology Plugin
	    so that each overlay can select
	    an appropriate DHT that relies on the common RELOAD core code.
	  </t>
	  <t>
	    The Topology Plugin is responsible for maintaining the
	    DHT Routing Table, which is consulted by the Routing
	    Layer before routing a message. When connections are made or broken,
	    the Forwarding Layer notifies the Topology Plugin, which
	    adjusts the routing table as appropriate. The Topology
	    Plugin will also instruct the Forwarding Layer to form
	    new connections as dictated by the requirements of the
	    DHT Topology.
	  </t>
	  <t>
	    As peers enter and leave, resources may be stored on different
	    peers, so Topology Plugin also keeps track of which peers
	    are responsible for which resources.
	    As peers join and leave,
	    the Topology Plugin issues resource migration requests as
	    appropriate, in order to ensure that other peers have whatever
	    resources they are now responsible for.
	    Redundancy is used to protect against loss of
	    information in the event of a peer failure and to protect against
	    compromised or subversive peers. 
	  </t>
	</section>
	<section title="Forwarding Layer">
          <t>
	    The Forwarding Layer is responsible for getting a packet to the next peer,
	    as determined by the Routing and Storage Layer. The Forwarding Layer
	    establishes and maintains the network connections as required by the
	    Topology Plugin. This layer is also responsible for setting up
	    connections to other peers through NATs and firewalls using ICE, and
	    it can elect to forward traffic using relays for NAT and firewall
	    traversal.
	  </t>
        </section>
	<section title="SIP Usage">
	  <t>
	    The SIP Usage of RELOAD allows SIP user agents to provide
	    a peer-to-peer telephony service without the requirement
	    for permanent proxy or registration servers. In such
	    a network, the RELOAD overlay itself performs the registration
	    and rendezvous functions ordinarily associated with such
	    servers.
	  </t>
	  <t>
	    The SIP Usage involves two basic functions:
	    <list style="hanging">
	      <t hangText="Registration: ">
		SIP UAs can use the RELOAD data storage functionality
		to store a mapping from their AOR to their Peer-Id
		in the overlay, and to retrieve the Peer-Id of 
		other UAs.
	      </t>
	      <t hangText="Rendezvous: ">
		Once a SIP UA has identified the Peer-Id for an 
		AOR it wishes to call, it can use the RELOAD message
		routing system to set up a direct connection
		which can be used to exchange SIP messages.
	      </t>
	    </list>
	  </t>
	  <t>
	    For instance, Bob could register his Peer-Id, "1234",
	    under his AOR, "sip:bob@dht.example.com". When Alice
	    wants to call Bob, she queries the overlay for
	    "sip:bob@dht.example.com" and gets back Peer-Id
	    1234. She then uses the overlay to establish
	    a direct connection with Bob and can use that 
	    direct connection to perform a standard SIP INVITE.
	  </t>
	</section>
      </section>

<!-- EKR removed. I don't know if these make sense
      
      <section title="Overlays">
         <t>[TODO: HGS]</t>
      </section>

      <section title="Data Model">
         <t>[TODO: HGS]</t>
      </section>
-->

<!-- EKR: removed. I don't think this is illuminating.

      <section title="Security">
        <t>RELOAD provides two security mechanisms, one based on public key
        certificates and one based on a globally shared key.</t>

        <t>RELOAD's preferred security framework is built upon an enrollment
        server. The enrollment server issues each new peer a certificate that
        assigns it a Peer-ID. By generating the Peer-IDs randomly and
        controlling what peers are issued certificates, the enrollment server
        protects against many of the attacks on the overlay network.
        Similarly, all users are issued certificates for their identities by
        the enrollment server. All resources stored on the overlay must be
        signed by their creator, thus ensuring that an attacker cannot forge
        data belonging to another user. The enrollment process is only
        required to join the overlay (and perhaps to refresh an expired
        certificate). The peers and users do not need to have real-time access
        to the enrollment server.</t>

        <t>TLS or DTLS are used for communication between peers. In
        combination with the certificates, this provides both confidentiality
        and authentication for communication across the overlay. Applications
        such as P2PSIP can also make use of the users' certificates to achieve
        secure end-to-end connections at the application layer.</t>

        <t>RELOAD also provides for an authorization framework based on
        certificates. Each usage defines the access control rules for which
        users/peers are allowed to read/write each Resource-ID. This protects
        data belonging to one user from being written by another, as well as
        allowing for a distributed quota mechanism based on the maximum size
        of each kind of data.</t>

        <t>In addition to the enrollment server model, RELOAD offers a
        security model using a pre-shared-key. Although this provides
        significantly less security than is provided through an enrollment
        server, it allows ad hoc or ephemeral overlays to be set up with
        minimal effort on the part of the users.</t>
      </section>
-->

      <section title="Security">
	<t>
	  RELOAD provides two security models, one based on
	  certificates assigned by a central server and one
	  based on a shared key known to all members of the 
	  overlay. These credentials can be leveraged to
	  provide communications security for RELOAD messages.
	  RELOAD provides communications security at three levels:
	</t>
	<t>
	  <list style="hanging">
	    <t hangText="Connection Level: ">
	      Connections between peers are secured with TLS or 
	      DTLS. 
	    </t>
	    <t hangText="Message Level: ">
	      Each RELOAD message can be signed (this is only
	      possible with the certificate model.)
	    </t>
	    <t hangText="Object Level: ">
	      Stored objects can be signed by the storing peer
	      (this is only possible with the certificate model.)
	    </t>
	  </list>
	</t>
	<t>
          These three levels of security work together to allow peers
          to verify the origin and correctness of data they receive from other
          peers, even in the face of malicious activity by other peers in the
          overlay.
	</t>
	<t>
	  RELOAD also provides access control built on top of these
	  communications security features. Because the node responsible for
	  storing a piece of data can verify the identity of the storing node,
	  it can determine whether a given operation is permitted or not.
	</t>
      </section>
    </section>

    <section title="Terminology">
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
      document are to be interpreted as described in <xref
      target="RFC2119">RFC 2119</xref>.</t>

      <t>We use the terminology and definitions from the <xref
      target="I-D.ietf-p2psip-concepts">Concepts and Terminology for Peer to
      Peer SIP</xref> draft extensively in this document. Other terms used in
      this document are defined inline when used and are also defined below
      for reference.</t>

      <t>[TODO: BBL, revise these terms]</t>

      <t>The following important terms from the Concepts document are defined
      below for reference.</t>

      <t><list style="hanging">
          <t></t><t hangText="DHT:">A distributed hash table. A DHT is an abstract
          hash table service realized by storing the contents of the hash
          table across a set of peers.</t>

          <t></t><t hangText="DHT Algorithm:">A DHT algorithm defines the rules for
          determining which peers in a DHT store a particular piece of data
          and for determining a topology of interconnections amongst peers in
          order to find a piece of data.</t>

          <t></t><t hangText="DHT Instance:">A specific hash table and the collection
          of peers that are collaborating to provide read and write access to
          it. There can be any number of DHT instances running in an IP
          network at a time, and each operates in isolation of the others.</t>

          <t></t><t hangText="P2P Network:">Another name for a DHT instance.</t>

          <t></t><t hangText="P2P Network Name:">A string that identifies a unique
          P2P network. P2P network names are DNS names - for example,
          "example.org". Lookup of such a name in DNS returns services
          associated with the DHT, such as enrollment servers, bootstrap
          peers, or gateways (for example, a SIP gateway between a traditional
          SIP and a P2P SIP network called "example.com").</t>

          <t></t><t hangText="Resource-ID:">A value that
	  identifies some resources and which is used as a key for
          storing and retrieving the resource. Often this is not 
	  human friendly/readable. One way to generate a
          Resource-ID is by applying a mapping function to some other unique
          name (e.g., user name or service name) for the resource. The
          Resource-ID is used by the distributed database algorithm to
          determine the peer or peers that are responsible for storing the
          data for the overlay. In structured P2P networks, resource-IDs are
          generally fixed length and are formed by hashing the resource
          identifier. In unstructured networks, resource identifiers may be
          used directly as resource-IDs and may have variable length.</t>

          <t></t><t hangText="Peer:">A host that is participating in the DHT. By
          virtue of its participation it can store data and is responsible for
          some portion of the overlay.</t>

          <t></t><t hangText="Peer-ID:">A 128-bit value that uniquely identifies a peer.
          Peer-IDs 0 and 2^128 - 1 are reserved and are invalid Peer-IDs. A
          value of zero is not used in the wire protocol but can be used to
          indicate an invalid peer in implementations and APIs. The Peer-ID of
          2^N-1 is used on the wire protocol as a wildcard.</t>

          <t></t><t hangText="Resource:">An object associated with a string
          identifier. In unstructured P2P networks, the identifier is used
          directly as a Resource-Id. In structured P2P networks the identifier
	  can be mapped into a Resource-ID by using the string as the input to
          hash function. A SIP resource, for example, is often identified by its
          AOR.</t>

          <t></t><t hangText="User:">A human being.</t>
        </list>&gt;</t>

      <t>We also introduce the following important new terms.</t>

      <t><list style="hanging">
          <t></t><t hangText="Connection Table:">The set of peers to which a peer is
          directly connected. This includes peers with which CONNECT
          handshakes have been done but which have not sent any UPDATEs.</t>

          <t></t><t hangText="Routing Table:">The set of peers which a peer can use
          to route DHT messages. In general, these peers will all be on the
          connection table but not vice versa, because some peers will have
          CONNECTed but not sent updates. Peers may send messages directly to
          peers which are on the connection table but may only route messages
          to other peers through peers which are on the routing table.</t>

          <t></t><t hangText="Hashed-ID:">The generic term for an identifier in the
          hash space of the DHT. Examples of Hashed-IDs include Resource-IDs
          and Peer-IDs. This only applies to structured overlays.</t>

          <t></t><t hangText="Unhashed-ID:">An Unhashed-ID is a string used as an
          input to a hash function, the result of which is a Hashed-ID. This
          only applies to structured overlays.</t>

          <t></t><t hangText="Usage:">A usage is an application that wishes to use
          the DHT for some purpose. Each application wishing to use the DHT
          defines a set of data kinds that it wishes to use. The SIP usage
          defines the location, certificate, STUN server and TURN server data
          kinds.</t>

          <t></t><t hangText="Destination List:">A list of IDs through which a
          message is to be routed. A single Peer-ID is a trivial form of destination list.</t>
        </list></t>
    </section>

    <section title="Overlay Management Overview">

      <t>
         The most basic function of RELOAD is as a generic overlay
         network. Nodes need to be able to join the overlay, form
         connections to other nodes, and route messages through the
         overlay to nodes to which they are not directly connected.
         This section provides an overview of the mechanisms that
         perform these functions.
      </t>
      
      <section title="Security and Identification">
         <t>
           Every node in the RELOAD overlay is identified by one or more Peer-IDs.
           The Peer-ID is used for three major purposes:
           </t><t>
           <list style="symbols">
             <t>To address the node itself.</t>
             <t>To determine its position in the overlay topology.</t>
             <t>To determine the set of resources for which the node is responsible.</t>
           </list>
           </t>
           <t>
             RELOAD supports two Peer-ID assignment models: certificate-based and
             shared-key.
           </t>
           <t>
             In the certificate based
             model, Peer-IDs are centrally assigned by an enrollment server which
             also issues the nodes with a PKI certificate attesting to its ownership
             of its assigned Peer-ID. This certificate can be used to authenticate
             DTLS/TLS connections to and from the node as well as to sign messages
             from the node.
           </t>
           <t>
             In the shared-key model, all the nodes in the overlay share a single
             static key which is used for admission control. Nodes choose their
             own Peer-IDs and there is no cryptographic mechanism from distinguishing
             one node from another. This model is only suitable for use in
             closed environments where nodes are mutually trusted.
           </t>
           <section anchor="sec-cert-security" title="Certificate-Based Security">
             <t>The certificate-based security model revolves around the
             enrollment process allocating a unique name to the user and issuing
             a certificate <xref target="RFC3280"></xref> for a public/private
             key pair for the user. All peers in a particular DHT instance
	     can verify
             these certificates. A given peer acts on behalf of a user, and that
             user is responsible for its operation.</t>

             <t>The certificate serves two purposes:</t>

             <t><list style="symbols">
               <t>
                  It entitles the user to store data at specific locations in
                  the DHT Instance. Each kind defines the specific rules for determining
                  which certificates can access each resource-ID/kind-id pair. For
                  instance, some kinds might allow anyone to write at a given
                  location, whereas others might restrict writes to the
		  owner of a single certificate.
               </t>

               <t>
                  It entitles the user to operate a peer that has a Peer-ID
                  found in the certificate. When the peer is acting as a DTLS or
                  TLS server, it can use this certificate so that a client
                  connecting to it knows it is connected to the correct
                  server. In addition, the peer can sign messages, thus providing
                  integrity and authentication for messages which are sent
                  from the peer.
               </t>
             </list></t>

             <t>
               When a user enrolls, or enrolls a device with no keying material,
               the user is given a certificate. This certificate contains
               information that identifies the user and the device they are using.
               If a user has more than one device, typically they would get one
               certificate for each device. This allows each device to act as a
               separate peer.
             </t>

             <t>The contents of the certificate include:</t>

             <t><list style="symbols">
               <t>A public key provided by the user.</t>

               <t>Zero or more user names that the DHT Instance is allowing this user to
               use. For example, "alice@example.org". Typically a certificate
               will have one name. In the SIP usage, this name corresponds to
               the AOR.</t>

               <t>Zero or more Peer-IDs. Typically there will be one Peer-ID.
               Each device will use a different Peer-ID, even if two devices
               belong to the same user. Peer-IDs should be chosen randomly by
               the enrollment server.</t>

               <t>A serial number that is unique to this certificate across all
               the certificates issued for this DHT instance.</t>

               <t>
                  An expiration time for the certificate. At some point before the
                  certificate expires, the user will
                  need to get a new certificate from the enrollment server.
               </t>
             </list></t>
             
             <t>
               Note that because Peer-IDs are chosen randomly, they will be
               randomly distributed with respect to the user name. This has the
               result that any given peer is highly unlikely to be responsible for
               storing data corresponding to its own user, which promotes high
               availability.
             </t>
           </section>

           <section anchor="sec-shared-key" title="Shared-Key Security">
             <t>RELOAD also defines a shared-key security model which can be used
             in closed networks where all peers are trusted. In
             this model, the peers all share a single key which is used to
             authenticate the peer-to-peer DTLS connections via TLS-PSK/TLS-SRP.
             If shared-key security mode is in use, a shared-key capable cipher
             suite such as TLS-PSK or TLS-SRP MUST be used. This is useful for
             admission control, but is completely unsafe in any setting where
             peers are not mutually trusted, since it allows any peer to
             impersonate any other peer.</t>
           </section>
         </section>
      <section title="Nodes, Clients and Peers">
 	<t>RELOAD defines a single protocol that is used both as the
 	  peer protocol and client protocol for the overlay.  This
 	  simplifies implementation, particularly for devices that may
 	  act in either role, and allows clients to inject messages
 	  directly into the overlay.</t>
 
         <t>TODO: this will have been covered in intro or prev section?  We use the
           term peer to identify a node in the overlay routes messages
           other than those to which it is directly connected.  Peers
           typically also have storage responsibilities although some
           overlays may also assign storage responsibilities to
           non-routing nodes.  We use clients to refer to nodes that have
           no routing responsibilities and typically connect only to a
           single peer for access to the resources in the overlay.  When
           text refers to either peers or clients, we will simply refer
           to such a device as a node.</t>
 
         <section title="Peer-capable Clients">
           <t>Each peer in the overlay is provisioned with a
             certificate that provides its Node-ID, joins the overlay,
             and assumes routing responsibility for its portion of the
             overlay.  However, there are many reasons why a capable node 
             may not wish to serve as a full
             peer <xref target="I-D.pascual-p2psip-clients"></xref>.
             Perhaps two of the most important are:</t>
 
           <t><list style="symbols">
               <t>The node does not have appropriate network
                 connectivity---typically because it is behind an overly
                 restrictive NAT.</t>
 
               <t>The node may not have sufficient resources, such as
                 computing power, storage space, or battery power.</t>
 
               <t>The overlay algorithm may dictate specific
                 requirements for peer selection.  These may include
                 participation in the overlay to determine
                 trustworthiness or simply to control the number of peers
                 in the overlay to reduce overly-long routing paths.</t>
           </list></t>
 
           <t>While there are many more reasons, the ultimate criteria
             for an eligible peer is determined by the overlay algorithm
             and specific deployment.</t>
 
           <t>RELOAD's support for peer-capable clients allows nodes
             that are not participating in the overlay as peers to
             utilize the same implementation and to benefit from the same
             security mechanisms as the peers.  Under this scenario a
             client uses its Node-ID to identify itself and its requests
             in the same manner as a peer.  There are two routing options
             for such a client:</t>
 
           <t><list style="symbols">
               <t>Establish a connection to the peer responsibile for
                 the client's Node-ID in the overlay. Then requests may
                 be sent from/to the client using its Node-ID in the same
                 manner as if it were a peer, because the responsible
                 peer in the overlay will handle the final step of
                 routing to the client.</t>
 
               <t>Establish a connection with an arbitrary peer in the
                 overlay (perhaps based on network proximity or an
                 inability to establish a direct connection with the
                 responsible peer).  In this case, the client will rely
                 on RELOAD's Via List feature to ensure reachability.
                 The client can initiate requests, and any node in the
                 overlay that knows the Via List to its current location
                 can reach it, but it is not arbitrarily reachable
                 directly using only the client's Node-ID.  (Note that it
                 may be possible to extend the protoocl by including a
                 usage that would allow the client to store a resource at
                 its Node-ID in the overlay redirecting to its current
                 Via List.)</t>
           </list></t>
 
           <t>In all of these scenarios, the client speaks the same
             protocol as the peers, knows how to calculate Resource-IDs,
             and signs its requests in the same manner as peers.  While a
             client does not necessarily require a full implementation of
             the overlay algorithm, calculating the Resource-ID requires
             an implementation of the appropriate algorithm for the
             overlay.</t>
 
         </section>
 
         <section title="Clients with Limited Functionality">
           <t>In order to exchange RELOAD messages with a peer, a
             client must meet a minimum level of functionality.  Such a
             client must:</t>
           
           <t><list style="symbols">
               <t>Implement RELOAD's connection-management connections
                 that are used to establish the connection with the
                 peer.</t>
               <t>Implement RELOAD's data storage and retrieval
                 methods (with client functionality).</t>
               <t>Be able to calculate Resource-IDs used by the
                 overlay.</t>
               <t>Possess security credentials required by the overlay
                 it is implementing.</t>
           </list></t>
 
           <t>Such a client will be participating in the overlay as
             described in the previous section, but be unable to be
             promoted to a peer.</t>
 
           <t>RELOAD does not support a separate protocol for clients
             that do not meet these functionality requirements.  Any
             such extension would either entail compromises on the
             features of RELOAD or require an entirely new protocol to
             reimplement the core features of RELOAD.  Furthermore, for
             P2PSIP and many other applications, a native
             application-level protocol already exists that is
             sufficient for such a client, as described in the next
             section.</t>
 
         </section>
 
         <section title="Clients as Application-level Agents">
           <t>SIP defines an extensive protocol for registration and
             security between a client and its registrar/proxy
             server(s).  Any SIP device can act as a client of a
             RELOAD-based P2PSIP overlay if it contacts a peer that
             implements the server-side functionality required by the
             SIP protocol.  TODO Such an overlay would also require a
             security scheme that allows such a peer to authenticate a
             registration of resources for such a client (or just
             require the proxy to have its clients' keys).  </t>
 
         </section>
 
       </section>
      <section title="Connectivity Management">
<t> [TODO: This section requires an understanding of ICE to make any sense] </t>

	<t>
	  In order to provide efficient routing, a peer needs to maintain
	  a set of direct connections to other peers in the DHT Instance. Because
	  of the presence of NATs, these connections often cannot be
	  formed directly. Instead, we use the CONNECT request to
          establish a connection.
	</t>
	<t>
	  Say that peer A wishes to form a direct connection to peer B. It
          gathers ICE candidates and packages them up in a CONNECT request
          which it sends to B through usual DHT routing procedures. B does its
          own candidate gathering and sends back a response with its
          candidates. A and B then do ICE connectivity checks on the candidate
          pairs. The result is a connection between A and B. At this point, A
          and B can add each other to their routing tables and send messages
          directly between themselves without going through other DHT
          peers.
	</t>
	<t>
	  There is one special case in which CONNECT cannot be used: when
	  a peer is joining the overlay and is not connected to any
	  peers. In order to support this case, some small number 
	  of "bootstrap nodes" need to be publicly accessible so that
	  new peers can directly connect to them. Section [XREF]
	  contains more detail on this.
	</t>
	<t>
	  In general, a peer needs to maintain connections to all of the
          peers near it in the DHT Instance and to enough other peers to have efficient
          routing (the details depend on the specific DHT). If a peer cannot
          form a connection to some other peer, this isn't necessarily a
          disaster; DHTs can route correctly even without fully connected
          links. However, a peer should try to maintain the specified link set
          and if it detects that it has fewer direct connections, should form
          more as required. This also implies that peers need to periodically
	  verify that the connected peers are still alive and if not
	  try to reform the connection or form an alternate one.
	</t>
      </section>
      <section title="Routing">

        <t>This section will discuss the requirements RELOAD's routing
          capabilities must meet, then describe the routing features in
          the protocol, and provide a brief overview of how they are
          used.  The section will conclude by discussing some
          alternative designs and the tradeoffs that would be
          necessary to support them.</t>

        <t>RELOAD's routing capabilities must meet the following
          requirements:</t>
        
        <t><list style="hanging">
            <t hangText="NAT Traversal">RELOAD must support
              establishing and using connections between nodes
              separated by one or more NATs, including locating
              peers behind NATs for those overlays
              allowing/requiring it.</t>
            <t hangText="Clients">RELOAD must support requests from
              and to clients that do not participate in overlay
              routing.</t>
            <t hangText="Client promotion">RELOAD must support
              clients that become peers at a later point as
              determined by the overlay algorithm and
              deployment.</t>
            <t hangText="Low state">RELOAD's routing algorithms must
              not require significant state to be stored on
              intermediate peers.</t>
        </list></t>
        
        <t>To meet these requirements, RELOAD's routing relies on two
          basic mechanisms:</t>

        <t><list style="hanging">
            <t hangText="Via Lists">The forwarding header used by all
              RELOAD messages contains both a Via List (built
              hop-by-hop as the message is routed through the overlay)
              and a Destination List (providing source-routing
              capabilities for requests and return-path routing for
              responses).</t>
            <t hangText="ROUTE_QUERY">The ROUTE_QUERY method allows a
              node to query a peer for the next hop it will use to
              route a message.  This method is useful for diagnostics
              and for iterative routing.</t>
        </list></t>

        <t>The basic routing mechanism used by RELOAD is symmetric
          recursive.  We will first describe symmetric routing and
          then discuss its advantages in terms of the requirements
          discussed above.</t>

        <t>Symmetric recursive routing requires a message follow the
          path through the overlay to the destination without
          returning to the originating node: each peer forwards the
          message closer to its destination.  The return path of the
          response is then the same path followed in
          reverse. For example, a message following a route from A to
          Z through B and X: </t>

        <figure>
          <artwork><![CDATA[
INSERT LADDER DIAGRAM WITH VIA AND DST LISTS HERE
              ]]></artwork>
        </figure>

        <t>Note that the preceding Figure does not indicate whether A
          is a client or peer---A forwards its request to B and the
          response is returned to A in the same manner regardless of
          A's role in the overlay.</t>

        <t>This Figure shows use of full via-lists by intermediate
          peers B and X.  However, if B and X are willing to store
          state, then they may elect to truncate the lists, save that
          information internally, and return the response message
          along the path from which it was received when the response
          is received.  This option requires greater state on
          intermediate peers but saves a small amount of bandwidth and
          reduces the need for modifying the message enroute.
          Selection of this mode of operation is a choice for the
          individual peer---the techniques are mutually interoperable
          even on a single message.</t>

        <figure>
          <artwork><![CDATA[
INSERT LADDER DIAGRAM WITH truncated VIA AND DST LISTS HERE
              ]]></artwork>
        </figure>

        <t>For debugging purposes, a Route Log attribute is available
          that stores information about each peer as the message is
          forwarded.  </t>

        <t>RELOAD also supports a basic iterative routing mode (where
          the intermediate peers merely return a response indicating
          the next hop, but do not actually forward the message to
          that next hop themselves).  Iterative routing is implemented
          using the ROUTE_QUERY method, which requests this behavior.
          Note that iterative routing is selected only by the
          initiating peer.  RELOAD does not support an intermediate
          peer returning a response that it will not recursively route
          the request---the willingness to perform that operation is
          implicit in its role as a peer in the overlay.</t>

        <section title="Routing Alternatives">

          <t>Significant discussion has been focused on the selection
            of a routing algorithm for P2PSIP.  This section discusses
            the motivations for selection of symmetric recursive
            routing for RELOAD and describes the extensions that would
            be required to support additional routing algorithms.</t>

          <section title="Iterative vs Recursive">
            <t>Iterative routing has a number of advantages.  It is
            easier to debug, consumes fewer resources on intermediate
            peers, and allows the querying peer to identify and route
            around misbehaving peers.  However, in the presence of
            NATs iterative routing is intolerably expensive because a
            new connection (using ICE) must be established for each
            hop.</t>

            <t>Iterative routing is supported through the ROUTE_QUERY
            mechanism and is primarily intended for debugging.  It is
            also the most reliable technique in the presence of
            compromised peers or network transitivity because the
            querying peer can evaluate the routing decisions made by
            the peers at each hop and consider
            alternatives [REF].</t>

          </section>

          <section title="Symmetric vs Forward response">
            <t>An alternative to the symmetric recursive routing
              method used by RELOAD is forward-only routing, where the 
              response is routed to the requester as if it is a new
              message initiating by the responder (in the previous
              example, Z sends the response to A as if it was sending
              a request).  Forward-only routing requires no state in
              either the message or intermediate peers.</t>

            <t>The drawback of forward-only routing is that it does
              not work when the overlay is unstable.  For example, if
              A is in the process of joining the overlay and is
              sending a JOIN request to Z, it is not yet reachable via
              forward routing.  Even if it is established in the
              overlay, if network failures produce temporary
              instablity, A may not be reachable (and may be trying to
              stabilize its network connectivity via CONNECT
              messages). </t>

            <t>An extension to RELOAD that supports forward-only
            routing but relies on symmetric responses as a fallback
            would be possible, but due to the complexities of
            determining when to use forward-only and when to fallback
            to symmetric, we have chosen not to include it as an
            option at this point.</t>
          </section>

          <section title="Direct Response">
            <t>A highly desireable routing option is to return the
              response directly to the querying node.  In the previous
              example, if A encodes its IP address in the request,
              then Z can simply deliver the response directly to A.
              In the absence of NATs or other connectivity issues,
              this is the optimal routing technique.</t>

            <t>The challenge of implementing direct response is
              implementing it in the presence of NATs.  There are a
              number of complexities that must be addressed.  In this
              discussion, we will continue our assumption that A
              issued the request and Z is generating the response.</t>

            <t><list style="symbols">
                <t>The IP address listed by A may be unreachable,
                  either due to NAT or firewall rules.  Therefore, a
                  direct response technique must fallback to symmetric
                  response.  The hop-by-hop ACKs used by RELOAD allow
                  Z to determine when A has received the message (and
                  the SSL negotiation will provide earlier
                  confirmation that A is reachable), but this fallback
                  requires a timeout that will increase the response
                  latency whenever A is not reachable from Z.</t>

                <t>Whenever A is behind a NAT it will have multiple
                  candidate IP addresses, each of which must be
                  advertised to ensure connectivity, therefore Z will
                  need to attempt multiple connections to deliver the
                  response.</t>
                
                <t>One (or all) of A's candidate addresses may route
                  from Z to a different device on the Internet.  In
                  the worst case these nodes may actually be running
                  RELOAD on the same port.   Therefore, establishing a
                  secure connection to authenticate A before
                  delivering the response is absolutely necessary.
                  This step diminishes the efficiency of direct
                  response because TODO roundtrips are required before
                  the message can be delivered.</t>

                <t>If A is behind a NAT and does not have a connection
                  already established with Z, there are only two ways
                  the direct response will work.  The first is that A
                  and Z are both behind the same NAT, in which case
                  the NAT is not involved.  In the more common case,
                  when Z is outside A's NAT, the response will only be
                  received if A's NAT implements endpoint-independent
                  filtering.  Because this is not the recommended
                  filtering mode for
                  NATs<xref target="RFC4787"></xref>, this ability
                  is likely to become less common over time.</t>
            </list></t>

            <t>An extension to RELOAD that supports direct response
            routing but relies on symmetric responses as a fallback
            would be possible, but due to the complexities of
            determining when to use forward-only and when to fallback
            to symmetric, and the reduced performance for responses to
            peers behind restrictive NATs, we have chosen not to
            include it as an option at this point.</t>

          </section>
          <section title="Relaying Peers">
            <t><xref target="I-D.jiang-p2psip-sep">SEP</xref> has proposed
              implementing a form of direct response by having A
              identify a peer, Q, that will be directly reachable by
              any other peer.  A uses CONNECT to establish a
              connection with Q and advertises Q's IP address in the
              request sent to Z.  Z sends the response to Q, which
              relays it to A.  This then reduces the latency to two
              hops, plus Z negotiating a secure connection to Q.</t>
            
            <t>This technique relies on the relative population of
              nodes such as A that require relay peers and peers such
              as Q that are capable of serving as a relay peer.  It
              also requires nodes to be able to identify which
              category they are in. </t>
            
            <t>An extension to RELOAD that supports relay peers is
              possible, but due to the complexities of implementing
              such an alternative, we have not added such a feature to
              RELOAD at this point.  </t>
          </section>

          <section title="Symmetric Route Stability">
            <t>A common concern about symmetric recursive routing has
              been that one or more peers along the request path may
              fail before the response is received.  The significance
              of this problem essentially depends on the response
              latency of the overlay---an overlay that produces slow
              responses will be vulnerable to churn, whereas responses
              that are delivered very quickly are vulnerable only to
              failures that occur over that small interval.</t>
            
            <t>The other aspect of this issue is whether the request
              itself can be successfully delivered.  Assuming typical
              connection maintenance intervals, the time period
              between the last maintenance and the request being sent
              will be orders of magnitude greater than the delay
              between the request being forwarded and the response
              being received.  Therefore, if the path was stable
              enough to be available to route the request, it is
              almost certainly going to remain available to route the
              response [REF: havethisneedtogetit].</t>
            
            <t>An overlay that is unstable enough to suffer this type
              of failure frequently is unlikely to be able to support
              reliable functionality regardless of the routing mechanism.</t>

            <t>Finally, because RELOAD retries the end-to-end request,
              that retry will address the issues of churn that
              remain.</t>
          </section>
        </section>

<!--
            
        <t>The forwarding layer is responsible for looking at message and
        doing one of three things:</t>

        <t><list style="symbols">
            <t>Deciding the message was destined for this peer and passing the
            message up to the layer above this.</t>

            <t>Looking at the Peer-ID that represents the next peer to send
            the message too and if there is an existing connection, sending
            the message over the connection.</t>

            <t>Requesting the DHT Routing logic to tell the forwarding layer
            which peer the message needs to be forwarded to (based on the
            target Peer-ID or resource-id), and then sending the message.</t>
          </list></t>
-->

<!--
        <section anchor="sec-via-list" title="Via Lists">
	  <t>
	    [TODO: BBL; I would merge this into the symmetric section
	    and try to trim a bit.]
	  </t>
          <t>In a general messaging system, messages need a source and a
          destination and peers need to be able to send a response to the peer
          that sent the request. This can be particularly tricky in overlay
          networks when a new peer is joining, or the overlay network is
          stabilizing and different peers have different ideas on what the
          overlay topology is. A simple and reliable way to make sure that a
          response can reach the node that sent the request in these
          situations is to have the response traverse the reverse path of the
          request.</t>

          <t>The approach used here is to have each node the request traverses
          add its Peer-ID to the "via list" in the request. Then the response
          is routed by looking at the list and using it as list of peers that
          the response will be routed thorough. To support this, each message
          has a destination list of nodes it needs to be routed through as
          well as a via list of what nodes it has traversed.</t>

          <t>When a peer receives a message from the Transport Layer, it adds
          the Peer-ID of the node it received the message from to the end of
          the via list. When a peer goes to transmit a message to the
          Transport Layer, it looks at the first entry on the destination
          list. If the entry is this peer, it removes this entry from the list
          and looks at the next entry and if the entry is not this peer, it
          sends the message to the first peer on the destination list.</t>

          <t>When a peer goes to send a response to a request, it can simply
          copy the via list in reverse to form the destination list for the
          response if it wishes to route the response along the reverse path
          as the request.</t>

          <t>Peers that are willing to maintain state may do list compression
          for privacy reason and to reduce the message size. They do this by
          taking some number of entries off the via list and replacing them
          with a unique entry that this peer can later identify. Later, if the
          peer sees the unique entry in a destination list, it removes the
          unique entry and replaces it with the all the entries removed from
          the original via list (and reverses the order of these entries).
          Note that this technique will generally require storing some
          per-message state on the intermediate peer, so this is a
          bandwidth/per-peer state tradeoff. The exception is if the list is
          not compressed but rather the Peer-IDs are simply encrypted.</t>

          <t>The via list approach provides several features. First it allows
          a response to follow the same path as the request. This is
          particularly important for peers that are sending requests while
          they are joining and before other peers can route to them as well as
          situations where message are being exchanged to stabilize the
          overlay network. It also makes it easier to diagnose and manage the
          system when all peers see the response to any request they
          forward.</t>
        </section>
-->
      </section>
      <section title="Overlay Algorithm Support">
         <t>[TODO: UNKNOWN]</t>
         <!-- EKR: not sure if this goes here -->
        <section anchor="sec-join-leave-maint"
                 title="Joining, Leaving, and Maintenance">
          <t>When a new peer wishes to join the DHT Instance, it must have a Peer-ID
          that it is allowed to use. It uses one of the Peer-IDs in the
          certificate it received from the enrollment server. The main steps
          in joining the DHT Instance are:</t>

          <t><list style="symbols">
              <t>Forming connections to some other peers.</t>

              <t>Acquiring the data values this peer is responsible for
              storing.</t>

              <t>Informing the other peers which were previously responsible
              for that data that this peer has taken over responsibility.</t>
            </list></t>

	<t>
	  The first thing the peer needs to do is form a connection
	  to some "bootstrap node". Because this is the first connection
	  the peer makes, these nodes "bootstrap nodes"
	  MUST have public IP addresses and therefore can be
	  connected to directly. Once a peer has connected to one
	  or more bootstrap nodes, it can form connections in the usual
	  way by routing CONNECT messages through the overlay to other
	  nodes.
	  Once a peer has connected to the overlay for the first time,
	  it can cache the set of nodes it has connected to with 
	  public IP addresses for use as future bootstrap nodes.
	</t>
	
	<t>
	  Once the peer has connected to a bootstrap node, it
	  then can use overlay routing to 
	  contacts the peer which would have formerly been responsible for the
	  peer's Peer-ID (since that is where in the DHT Instance the peer will be
	  joining), the Admitting Peer (AP). It copies the other peer's state,
	  including the data values it is now responsible for and the
	  identities of the peers with which the other peer has direct
	  connections.
	</t>

	<t>The details of this operation depend mostly on the DHT involved,
	but a typical case would be:</t>

	<t><list style="numbers">
	  <t>JP sends a JOIN request to AP announcing its intention to
	  join.</t>

	  <t>AP sends a JOIN response.</t>

	  <t>AP does a sequence of STOREs to JP to give it the data it
	  will need.</t>

	  <t>AP does UPDATEs to JP and to other peers to tell it about its
	  own routing table. At this point, both JP and AP consider JP
	  responsible for some section of the DHT Instance.</t>

	  <t>JP makes its own connections to the appropriate peers in the
	  DHT Instance.</t>
	</list></t>

	<t>After this process is completed, JP is a full member of the DHT Instance
	and can process STORE/FETCH requests.</t>
	</section>
      </section>
      <section title="Diagnostics">
         <t>[TODO: SAB]</t>
      </section>

<!-- EKR: REMOVED. This is just noise. Maybe put this back in depending on how the 
     introduction ends up looking.

      <section title="Transport">
         <t>[TODO</t>
         <t>The transport layer sends and receives messages over TLS and DTLS.
        For TLS it simply pushes the messages into the stream. For DTLS it
        takes care of fragmentation issues. The reason for including TLS is
        the improved performance it can offer for bulk transport of data. The
        reason for including DTLS is that the percentage of the time that two
        devices behind NATs can form a direct connection without a relay is
        much higher for DTLS than for TLS. If all NATs were <xref
        target="I-D.ietf-behave-tcp"></xref> compliant, then TLS over TCP
        would be preferred.</t>
      </section>

-->

      <section title="Enrollment">
         <t>
	   Previous sections addesssed how RELOAD works
	   once a node has connected. This section provides an overview of how
	   users get connected to the overlay for the first time.
	   RELOAD is designed so that 
	   users can start with the name of the overlay they wish to join
	   and perhaps a username and password, and leverage that into
	   having a working peer with minimal user intervention.
	   This helps avoid the problems that have been experienced
	   with conventional SIP clients where users are required
	   to manually configure a large number of settings.
	 </t>

	 <section title="Initial Configuration">
	   <t>
	     In the first phase of the process, the user starts out
	     with the name of the overlay and uses this to download
	     an initial set of overlay configuration parameters.
	     The user does a DNS SRV lookup on the overlay name
	     to get the address of a configuration server. They
	     can then connect to this server with HTTPS to download
	     a configuration document which contains the basic
	     overlay configuration parameters as well as a set
	     of bootstrap nodes which can be used to join the overlay
	     (see [XREF]).
	   </t>
	 </section>
	 <section title="Enrollment">
	   <t>
	     If the overlay is using certificate-based access control,
	     then a user needs to acquire a certificate before joining
	     the overlay. In that case, the configuration document will
	     contain the address of an enrollment server which can
	     be used to obtain such a certificate. The enrollment
	     server may (and probably will) require some sort of
	     username and password before issuing the certificate.
	   </t>
	 </section>

      </section>
    </section>
<!-- EKR: REMOVED: TMI
     
         <section title="Enrollment">
           <t>Before a new user can join the DHT Instance for the first time, they must
           enroll in the P2P Network for the DHT Instance they want to join. Enrollment
           will typically be done by contacting a centralized enrollment server.
           Other approaches (for instance static out of band configuration) are
           possible but are outside the scope of this specification. During
           enrollment a new node learns about a particular overlay, sets up a
           names and credentials, and discovers the bootstrap nodes. This would
           typically be done when a new peer joined an overlay for the very first
           time. Bootstrap is the process that happens each time a node boots and
           is how the peer finds an node that can be used to join the
           overlay.</t>

           <t>Before a node can join an overlay, it needs to be provided with a
           name for the overlay. Some examples are "example.com", "example", and
           "example.local". This name is resolved via a DNS SRV lookup for
           service name p2p_enroll and a protocol of tcp. If the TLD for the name
           is .local, then this DNS SRV lookup is done using <xref
           target="I-D.cheshire-dnsext-multicastdns"></xref> and the service name
           p2p_menroll. The intention here is to support ad hoc/local overlays.
           The resulting DNS lookup will provide the address of a enrollment
           server. Once this server is found, HTTPS is used to retrieve a XML
           file that contains the parameters for the overlay. These include
           things such as: what algorithms the overlay uses, overlay parameters,
           what usages are a peer on this overlay is required to support, the
           type of credentials required, addresses of credentials servers, the
           root certificate for the DHT Instance, information about the DHT algorithm that
           is being used, a P2P-Network-Id that uniquely identifies this ring,
           and any other parameters it may need to connect to the DHT Instance. The DHT
           also informs the peers what Usages it is required to support to be a
           peer on this P2P Network. It also provides an initial list of
           bootstrap nodes that consists of multiple bootstrap entries that each
           have the IP address and port for contacting a bootstrap peer. Some of
           the address may be multicast addresses. In the case of multicast DNS,
           every peer may also act as an enrollment server.</t>

           <t>If shared-key security (<xref target="sec-shared-key"></xref>) is
           being used, then the peer can proceed directly to bootstrap. If
           certificate-based security (<xref target="sec-cert-security"></xref>
           is being used, the peer MUST contact the credential server to obtain a
           certificate.</t>

           <section title="Certificate Issuance">
             <t>Once the peer has the XML file that identifies if credentials are
             needed, it can contact the credential server. The user establishes
             his identity to the server's satisfaction and provides the server
             with its public key. The centralized server then returns a
             certificate binding the user's user name to his public key. The
             properties of the certificate are discussed in [XREF].
             The amount of authentication
             performed here can vary radically depending on the DHT network being
             joined. Some networks may do no verification at all and some may
             require extensive identity verification (e.g., checking a driver's
             license) before issuing credentials for a given user name. The only
             invariant that the enrollment server needs to ensure is that no two
             users may have the same identity.</t>
           </section>
           <section title="Bootstrap">
             <t>The above steps are only done the first time a peer joins a new
             overlay or when the overlay parameters are close to their expiration
             time (as listed in the configuration document) and need to be
             refreshed. The next step is the bootstrap step which is done every
             time the peer boots.</t>

             <t>Bootstrapping consists of looking at the list of cached nodes and
             bootstraps nodes and sending a RELOAD PING to them to see if they
             respond. Once a node responds, it can be used to join the overlay.
             After a node has joined, it keeps track of a small number of peers
             to which it could directly connect. Theses are saved as the cached
             nodes and used next time the peer boots. The point of the cached
             nodes is to reduce the load on the bootstrap nodes.</t>
           </section>
         </section>

-->


    <section title="Application Support Overview">
        <t>[TODO: HGS; this needs bridge text to explain what application
         support is.]</t>
      <section title="Data Model">
         <t>[TODO: HGS; hopefully the intro to the enclosing section will
          explain what a Data Storage Layer is.]</t>
         <t>The Data Storage Layer provides operations to STORE, FETCH, and
         REMOVE data. Each location in the DHT Instance is referenced by a single
         integer Resource-ID. However, each location may contain data
         elements corresponding to multiple kinds (e.g., certificate, SIP
         registration). Similarly, there may be multiple elements of a given
         kind.</t>

          <figure>
            <artwork><![CDATA[
                    +--------------------------------+
                    |            Resource-ID         |
                    |                                |
                    | +------------+  +------------+ | 
                    | |   Kind 1   |  |   Kind 2   | |
                    | |            |  |            | |
                    | | +--------+ |  | +--------+ | |
                    | | | Value  | |  | | Value  | | |
                    | | +--------+ |  | +--------+ | |
                    | |            |  |            | |
                    | | +--------+ |  | +--------+ | |
                    | | | Value  | |  | | Value  | | |
                    | | +--------+ |  | +--------+ | |
                    | |            |  +------------+ |
                    | | +--------+ |                 |
                    | | | Value  | |                 |
                    | | +--------+ |                 |
                    | +------------+                 |
                    +--------------------------------+
              ]]></artwork>
          </figure>

           <t>Each kind is identified by a kind-id, which is a code point
           assigned by IANA. Note that a kind may be employed by multiple
           usages and new usages are encouraged to use previously defined kinds
           where possible. As part of the kind definition, protocol designers
           may define constraints, such as limits on size, on the values which
           may be stored. For many kinds, the set may be restricted to a single
           value; some sets may be allowed to contain multiple identical items
           while others may only have unique items. We define the following
           data models in this document, though other usages can define their
           own structures:</t>

           <t><list style="hanging">
             <t></t><t hangText="single value:">There can be at most one item in the
             set and any value overwrites the previous item.</t>

             <t></t><t hangText="array:">Many values can be stored and addressed by
             index.</t>

             <t></t><t hangText="dictionary:">The values stored are indexed by a
             key. Often this key is one of the values from the certificate of
             the peer sending the STORE request.</t>
           </list></t>

           [TODO: HGS; I glued two sxns together here. This needs bridge text.]

        <t>By itself, the distributed storage layer just provides
        infrastructure on which applications are built. In order to do
        anything useful, a usage must be defined. Each Usage needs to specify
        several things:</t>

        <t><list style="symbols">
            <t>Register kind-id code points for any kinds that the Usage
            defines.</t>

            <t>Define the data structure for each of the kinds.</t>

            <t>Define access control rules for each kinds.</t>

            <t>Provide a size limit for each kinds.</t>

            <t>Define how the Unhashed-ID is formed that is hashed to form the
            Resource-ID where each kind is stored.</t>

            <t>Describe how values will be merged after a network partition.
            Unless otherwise specified, the default merging rule is to act as
            if all the values that need to be merged were stored and that the
            order they were stored in corresponds to the stored time values
            associated with (and carried in) their values. Because the stored
            time values are those associated with the peer which did the
            writing, clock skew is generally not an issue. If if two nodes are
            on different partitions, clocks, this can create merge conflicts.
            However because RELOAD deliberately segregates storage so that
            data from different users and peers is stored in different
            locations, and a single peer will typically only be in a single
            network partition, this case will generally not arise.</t>
          </list></t>

        <t>The kinds defined by a usage may also be applied to other usages.
        However, a need for different parameters, such as different size
        limits, would imply the need to create a new kind.</t>
           
           [TODO: HGS; I glued two sxns together here. This needs bridge text.]
         
          <section title="Storage Permissions">
            <t>When a peer uses a STORE request to place data at a particular
            location X, it must sign with the private key that corresponds to
            a certificate that is suitable for storing at location X. Each
            data kind in a usage defines the exact rules for determining what
            certificate is appropriate.</t>

            <t>The most natural rule is that a certificate with user name X
            "owns" data located at Hash(X) (X is the Unhashed-ID and Hash(X)
            is the Hashed-ID) and only he can write there. This rules is used
            for all the kinds defined in this specification. Thus, only a user
            with a certificate for "alice@example.org" could write to that
            location in the DHT. However, other usages can define any rules
            they choose, including publicly writable values.</t>

            <t>The digital signature over the data serves two purposes. First,
            it allows the peer responsible for storing the data to verify that
            this STORE is authorized. Second, it provides integrity for the
            data. The signature is saved along with the data value (or values)
            so that any reader can verify the integrity of the data. Of
            course, the responsible peer can "lose" the value but it cannot
            undetectably modify it.</t>
          </section>


      </section>
      <section title="Service Discovery">
         <t>[TODO: UNKNOWN]</t>
      </section>
      <section title="Replication">
	<t>Replication in P2P overlays can be used to provide:</t>

        <t><list style="hanging">
            <t hangText="persistence"> if the responsible peer crashes
	      and/or if the storing peer leaves the overlay</t>
            <t hangText="security"> to guard against DoS attacks by
	      the responsible peer or routing attacks to that
	      responsible peer</t>
            <t hangText="load balancing"> to balance the load of
	      queries for popular resources.</t>
        </list></t>

        <t>A variety of schemes are used in P2P overlays to achieve
          some of these goals.  Common techniques include replicating
          on neighbors of the responsible peer, randomly locating
          replicas around the overlay, or replicating along the path
          to the responsible peer.</t>

        <t>The core RELOAD specification does not specify a particular
          replication strategy.  Instead, the first level of
          replication strategies are determined by the overlay
          algorithm, which can base the replication strategy on the
          its particular topology.  For example, Chord places replicas
          on successor peers, which will take over responsibility
          should the responsible peer fail.</t>
        
        <t>If additional replication is needed, for example if data
          persistence is particularly important for a particular
          usage, then that usage may specify additional replication,
          such as implementing random replications by inserting a salt
          into the keyword used to store a resource.  Such replication
          strategies can be added independent of the underlying
          algorithm, and their usage can be determined based on the
          needs of the particular usage.</t>

      </section>
      <section title="Application Connectivity">
        <t>There is no requirement that a RELOAD usage must use
          RELOAD's primitives for establishing its own communication
          if it already posesses its own means of establishing
          connections.  For example, if a P2PSIP node registers a
          simple SIP URI in an overlay, such as alice@example.com,
          then conventional SIP resolution is applied to establish a
          dialog.</t>
        

        <t>For more common situations, where the overlay itself is
          used to establish a connection rather than an external
          authority such as DNS, RELOAD provides connectivity to
          applications using the same CONNECT method as is used for
          the overlay maintenance.  For example, if a P2PSIP node
          wishes to establish a SIP dialog with another P2PSIP node,
          it will use CONNECT to establish a direct connection with
          the other node. This new connection is separate from the
          peer protocol connection, it is a dedicated UDP or TCP flow
          used only for the SIP dialog. Each usage specifies which
          types of connections can be initiated using CONNECT.</t>

        <t>Previous versions of RELOAD specified a TUNNEL method by
          which a usage could specify how to route
          application-specific messages across the overlay without
          establishing a new connection.  This version withdraws that
          method because it is essentially an optimization that adds
          additional complexity, particularly in specifying how an
          application such as SIP will make use of the feature,
          without adding additional functionality.  It may be
          reintroduced in the future.</t>

      </section>
    </section>

    <section title="P2PSIP Integration Overview">

          <t>
	    The SIP Usage of RELOAD allows SIP user agents to provide
	    a peer-to-peer telephony service without the requirement
	    for permanent proxy or registration servers. In such
	    a network, the RELOAD overlay itself performs the registration
	    and rendezvous functions ordinarily associated with such
	    servers.
	  </t>
	  <t>
	    The basic function of the SIP usage is to allow Alice to
	    start with a SIP URI (e.g., "bob@dht.example.com") and end up with a
	    connection which Alice's SIP UA can use to pass SIP messages back and
	    forth to Bob's SIP UA. The way this works is as follows:
	  </t>
	  <t>
	    <list style="numbers">
	      <t>
		Bob, operating Peer-ID 1234, stores a mapping from
		his URI to his Peer-ID in the overlay. I.e.,
		"sip:bob@dht.example.com -> 1234".
	      </t>
	      <t>
		Alice, operating Peer-ID 5678, decides to call
		Bob. She looks up "sip:bob@dht.example.com"
		in the overlay and retrieves "1234".
	      </t>
	      <t>
		Alice uses the overlay to route a CONNECT
		message to Bob's peer. Bob responds with
		his own CONNECT and they set up a direct
		connection, as shown below.
	      </t>
	    </list>
	  </t>
	  
        <figure>
<artwork>
<![CDATA[
Alice       Peer1      Overlay     PeerN      Bob
(5678)                                     (1234)
-------------------------------------------------
CONNECT ->
          CONNECT ->
                      CONNECT -> 
                                   CONNECT ->
                                          <- CONNECT
                                <- CONNECT
                   <- CONNECT
         <- CONNECT

<------------------- ICE Checks ----------------->
INVITE ------------------------------------------>
<---------------------------------------------- OK
ACK --------------------------------------------->
]]>
	  </artwork>
	</figure>
	<t>
	  It's important to note that RELOAD's only role here
	  is to set up the direct connection between Alice and
	  Bob. As soon as the ICE checks complete and that
	  connection is established, then ordinary SIP is used.
	  In particular, the establishment of the media channel
	  for the phone call happens via the usual SIP mechanisms,
	  and RELOAD is not involved. Media never goes over
	  the overlay.
	</t>
	<t>
	  As well as allowing mappings from AORs to Peer-IDs,
	  the SIP Usage also allows mappings from AORs to other
	  AORs. For instance, if Bob wanted his phone calls
	  temporarily forwarded to Charlie, he could store
	  the mapping "sip:bob@dht.example.com -> sip:charlie@dht.example.com".
	  When Alice wants to call Bob, she retrieves this mapping and can
	  then fetch Charlie's AOR to retrieve his Peer-ID.
	</t>
<!-- EKR REMOVED: Too much information here
            
     
           <section title="SIP Connect">
             <t>This usage allows two clients to form a new TLS or DTLS
             connection between them and then use this connection for sending
             SIP messages to one another. This does not store any information
             in the DHT, but it allows the CONNECT request to be used to set up
             a TLS or DTLS connection between two peers and then use that
             connection to send SIP messages back and forth.</t>

             <t>The CONNECT request will ensure that the connection is formed
             to a peer that has a certificate which includes the user that the
             connection is being formed to.</t>
           </section>

           <section title="SIP GRUUs">
             <t>GRUUs that refer to peers in the P2P network are constructed by
             simply forming a GRUU, where the value of gr URI parameter
             contains a base64 encoded version of the destination list that
             will reach the peer. Typically the destination list is just a
             single entry with the Peer-ID of peer.</t>
           </section>
-->

           <!-- EKR Removed
           <section title="SIP Tunnel">
           

             <t>This TUNNEL request allows two peers to exchange SIP messages
             across the overlay using the TUNNEL method without first setting
             up a direct connection using CONNECT. This allows a SIP message to
             be sent immediately, without the delay associated with CONNECT and
             for a simple SIP exchange, it may result in fewer messages being
             sent.</t>
           </section>
           -->
         </section>

    <!-- EKR: REMOVED

    <section title="Overview">
      <section title="Distributed Storage Layer">
        <t>RELOAD is designed to be extensible to both structured and
        unstructured overlays. However, this version is only completely worked
        out for structured overlays such as DHTs. The following text assumes
        structured overlays; in particular Resource-IDs are assumed to be
        fixed length for any given overlay, although the protocol allows them
        to be variable length to allow extension to unstructured overlays.</t>

        <t>Each logical address in the DHT where data can be stored is
        referred to as a Resource-ID. A given peer will be responsible for
        storing data from many Resource-ID locations. Typically literature on
        DHTs uses the term "key" to refer to a location in the DHT; however,
        in this specification the term key is used to refer to public or
        private keys used for cryptographic operations and the term
        Resource-ID is used to refer to a location for storage in the DHT.</t>

        <section title="DHT Concepts">
          <t>While very early P2P systems used flood based techniques, some
          newer P2P systems locate resources using a Distributed Hash Table,
          or DHT to improve efficiency. Peers are organized using a
          Distributed Hash Table (DHT) structure. In such a system, every
          resource has a Resource-ID, which is obtained by hashing some
          keyword or value (an Unhashed-ID) that uniquely identifies the
          resource. Resources can be thought of as being stored in a hash
          table at the entry corresponding to their Resource-ID. The peers
          that make up the overlay network are also assigned an ID, called a
          Peer-ID, in the same hash space as the Resource-IDs. A peer is
          responsible for storing all resources that have Resource-IDs near
          the peer's Peer-ID. The hash space is divided up so that all of the
          hash space is always the responsibility of some particular peer,
          although as peers enter and leave the system a particular peer's
          area may change. Messages are exchanged between the peers in the DHT
          as the peers enter and leave to preserve the structure of the DHT
          and exchange stored entries. Various DHT implementations may
          visualize the hash space as a grid, circle, line, or hypercube.</t>

          <t>Peers keep information about the location of other peers in the
          hash space and typically know about many peers nearby in the hash
          space, and progressively fewer more distant peers. We refer to this
          table of other peers as a Routing Table. When a peer wishes to
          operate on a resource it consults the list of peers it is aware of
          and contacts the peer with the Peer-ID nearest the desired
          Resource-ID. If that peer does not know how to find the resource, it
          either returns information about a closer peer it knows about, or
          forwards the request to a closer peer. In this fashion, the request
          eventually reaches the peer responsible for the resource, which then
          replies to the requester.</t>
        </section>

        <section title="DHT Topology">
          <t>Each DHT will have a somewhat different structure, but many of
          the concepts are common. The DHT defines a large space of
          Resource-IDs, which can be thought of as addresses. In many DHTs,
          the Resource-IDs are simply 128- or 160-bit integers. Each DHT also
          has a distance metric such that we can say that Resource-ID A is
          closer to Resource-ID B than to Resource-ID C.</t>

          <t>Each peer in the DHT is assigned a Peer-ID and is "responsible"
          for the nearby space of Resource-IDs. So, for instance, if we have a
          peer P, then it could also be responsible for storing data
          associated with Resource-ID P+epsilon as long as no other peer P was
          closer. The DHT Resource-ID space is divided so that some peer is
          responsible for each Resource-ID.</t>
        </section>


      <section title="Migration">
        <t>At some point in time, a given P2P Network may want to migrate from
        one underlying DHT algorithm to another or update to a later extension
        of the protocol. This can also be used for crypto agility issues. The
        migration approach is done by having peers initializing algorithm A.
        When the clients go to periodically renew their credentials, they find
        out that the P2P Network now requires them to use algorithm A but also
        to store all the data with algorithm B. At this point there are
        effectively two DHT rings in use, rings A and B. All data is written
        to both but queries only go to A. At some point when the clients
        periodically renew their credentials, they learn that the P2P Network
        has moved to storing to both A and B but that FETCH requests are done
        with P2P Network B and that any SEND should first be attempted on P2P
        Network B and if that fails, retried on P2P Network A. In the final
        stage when clients renew credentials, they find out that P2P Network A
        is no longer required and only P2P Network B is in use. Some types of
        usages and environments may be able to migrate very quickly and do all
        of these steps in under a week, depending on how quickly software that
        supports both A and B is deployed and how often credentials are
        renewed. On the other hand, some very ad-hoc environments involving
        software from many different providers may take years to migrate.</t>

        <t>[[TODO: This needs more filling out]]</t>
      </section>

      <section title="Usages Layer">

        <section title="Certificate Store Usage">
          <t>This usage allows each user to store their certificate in the DHT
          so that it can be retrieved to be checked by various peers and
          applications. Peers acting on behalf of a particular user store that
          user's certificate in the DHT, and any peer that needs the
          certificate can do a FETCH to retrieve the certificate. Typically it
          is retrieved to check a signature on a request or the signature on a
          chunk of data that the DHT has received.</t>
        </section>

        <section title="TURN Usage">
          <t>This usage defines a new kind for finding STUN-Relay servers. Any
          peer that supports this usage saves a pointer to the IP address and
          port of the TURN server in the DHT. When a peer wishes to discover a
          TURN server, it picks a random Resource-ID and performs a FIND at
          that Resource-ID for the appropriate type for the service. If
          nothing is found, this can be repeated until an appropriate set of
          servers are found.</t>
        </section>
        <section title="Diagnostic Usage">
          <t>This usage defines several new kinds that be queried to find
          information about the peer that may be useful for monitoring and
          diagnostics. This includes information such as software version,
          neighbor information, and performance statistics.</t>
        </section>

        <section title="HIP Tunnel Usage">
          <t>This usage allows two peers running HIP to tunnel HIP messages
          across the overlay. This allows the HIP peers to use the overlay as
          a rendezvous system to set up a direct path using HIP NAT traversal
          mechanisms.</t>
        </section>

         -->
    

    <section title="Overlay Management Protocol">
      <t>
         This section describes the basic protocols used create, maintain,
         and use the RELOAD overlay network. We start by describing how
         messages are transmitted, received, and routed in an existing
         overlay, then describe the message structure, and then finally
         describe the messages used to join and maintain the overlay.
      </t>

      <!-- TODO: EKR Diagram? --> 

      <section title="Message Routing">
         <t>
           Regardless of which DHT algorithm is used, a RELOAD overlay
           is a partly connected (incomplete) graph of nodes, each identified by
           Peer-ID. Each node maintains a set of connections to some 
           other set of nodes in the overlay. If a node is directly
           connected to the destination of a message, it can send it
           directly. However, in general, any two nodes will probably not be
           directly connected; when node A wants to send a message to
           node B, the message must traverse other nodes in the graph,
           with the precise set of intermediate nodes traversed
           depending on the DHT algorithm.
         </t>
         <t>
           RELOAD intentionally separates the generic mechanisms for
           routing messages from the precise DHT topology.
           The topology
           plugin (see [XREF]) should be thought of as providing a
           routing table. When a node wishes to transmit a message to
           a given Peer-ID to which it is not connected, it consults
           the routing table which tells
           it which of its existing connections to forward the message
           down. However, the procedures for sending, receiving, and
           forwarding the messages are the same regardless of the 
           topology and contents of the routing table.
         </t>
         <t>
           RELOAD also incorporates a loose source routing feature using
           DESTINATION LISTS. When a node transmits a message it
           can provide a set of Peer-IDs which it wishes the message
           to be routed through. Each intermediate node examines
           the first entry on the destination list and routes 
           the message to that node. When that node is reached,
           it removes itself from the destination list and routes
           based on the next entry. This repeats until the
           message arrives at its final destination.
           This makes it possible to address a peer which
           is potentially behind a NAT or a firewall in such a way that it
           cannot be connected to directly under any circumstances
         </t>
         
         <section anchor="sec-request-origination"
                   title="Request Origination">
                                             
           <t>
             In order to originate a message to a given Peer-ID or resource-id, a
             peer must first construct an appropriate destination list. The most
             common such destination list is a single entry containing the
             peer/resource-id. This simply uses the normal DHT routing
             mechanisms to forward the message to that destination. The
             peer can also construct a more complicated destination
             list to allow source routing. 
           </t>
           <t>
             Once the message is constructed, the node sends it down
             the appropriate connection to some adjacent peer. If the
             first entry on the destination list is directly connected,
             then the message will be routed down that connection.
             Otherwise, the topology plugin will be consulted to
             determine the appropriate next hop.
           </t>

           <t>[[TODO: Salman has suggested the originator doing parallel
           requests/responses. This is an open issue.]</t>
           
           <t>
             Because messages may be lost in transit through the overlay,
             RELOAD incorporates an end-to-end reliability mechanism.
             When an originating node transmits a request it sets a 3 second timer.
             If a response has not been received when the timer fires,
             the request is retransmitted with the same transaction
             identifier. The request may be retransmitted up to 4 times
             (for a total of 5 messages). After the timer for the fifth
             transmission fires, the message SHALL be considered to have
             failed. Note that this retransmission procedure is not
             followed by intermediate nodes. They follow the hop-by-hop
             reliability procedure described in [XREF].
           </t>
      </section>

      <section anchor="sec-message-forwarding"
                title="Message Receipt and Forwarding">
         <t>When a peer receives a message, it first examines the overlay,
         version, and other header fields to determine whether the message
         is one it can process. If any of these are incorrect (e.g., the
         message is for an overlay in which the peer does not participate)
         it is an error. The peer SHOULD generate an appropriate error but 
         if local policy can override this in which case the messages is 
         silently dropped. </t>

         <t>Once the peer has determined that the message is correctly
         formatted, it examines the first entry on the destination list.
         There are three possible cases here:</t>

         <t><list style="symbols">
           <t>The first entry on the destination list is an id for which
           the peer is responsible.</t>

           <t>The first entry on the destination list is a
	   an id for which
           another peer is responsible.</t>

           <t>The first entry on the destination list is a private id
           which is being used for destination list compression.</t>
         </list></t>

         <t>These cases are handled as discussed below.</t>
         <section anchor="sec-responsible-id" title="Responsible ID">
           <t>If the first entry on the destination list is a Hashed-ID for
           which the peer is responsible, the peer strips the entry off the
           destination list. If there are remaining entries on the destination
           list, the peer then re-examines the destination list to
           determine which case now applies. If the destination list is now
           empty, then the message was destined for this peer and it MUST
           pass it to the next layer up.</t>
         </section>

         <section anchor="sec-other-id" title="Other Hashed-ID">
           <t>If neither of the other two cases applies, then the peer MUST
           forward the message towards the first entry on the destination
           list. This means that it MUST select one of the peers to which
	   it is connected and which which is closer to the first entry than to itself
           and send the message to that peer. If the first entry on the
           destination list is in the peer's connection table, then it
           SHOULD forward the message to that peer directly. Otherwise,
	   it MUST consult the route table.</t>

           <t>RELOAD messages contain a via list which lists each peer
           that the message has traversed. When a peer forwards a message
           it MUST update the via list.
           The natural way to update the via list is simply to add the
           Peer-ID of the peer from which the message was received to the
           end of the list. However, peers may use any algorithm of their
           choice provided that if the peer received a destination list
           constructed by reversing the via list it would be able to route
           the outgoing message correctly, enabling symmetric routing.</t>

           <t>For instance, if node D receives a message from node C with
           via list (A, B), the simple approach is simply to forward to the
           next node (E) with via list (A, B, C). Now, if E wants to
           respond to the message, it reverses the via list to produce the
           destination list, resulting in (D, C, B, A). When D forwards the
           response to C, the destination list will contain (C, B, A).
           However, node D could also list compression and send E the via
           list (X). E would then use the destination list (D, X). When D
           processes this destination list, it MUST detect that X is a
           compressed entry, recover the via list (A, B, C), and reverse
           that to produce the correct destination list (C, B, A) before
           sending it to C.</t>

           <t>Note that if a peer is using list compression and then exits
           the overlay, the message cannot be forwarded and will be
           dropped. The ordinary timeout and retransmission mechanisms
           provide stability over this type of failure.</t>
          </section>

         <section anchor="sec-private-Peer-ID" title="Private ID">
           <t>If the first entry on the destination list is a private id,
           the peer replaces that entry with the stored local value that it
           indexes and then re-examines the destination list to determine
           which case now applies.</t>
         </section>

         </section>

         <section anchor="sec-response-origination"
                   title="Response Origination">
           <t>
             When a peer sends a response to a request, it SHOULD construct
             the destination list by reversing the order of the entries on the
             via list. This has the result that the response traverses (at
             least) the same peers as the request traversed, except in reverse
             order (symmetric routing).
           </t>
         </section>
         </section>

         <section title="Message Structure">
           <t>
             RELOAD is a message-oriented request/response protocol. The messages
             are encoded using binary fields. All integers are represented in network
             byte order. The general philosophy behind the design was to use Type,
             Length, Value fields to allow for extensibility. However, for the parts
             of a structure that were required in all messages, we just define these in
             a fixed position as adding a type and length for them is unnecessary and
             would simply increase bandwidth and introduces new potential for
             interoperability issues.
           </t>

           <t>Each message has three parts, concatenated as shown below:</t>
        <figure>
          <artwork><![CDATA[
   +-------------------------+
   |    Forwarding Header    |
   +-------------------------+
   |    Message Contents     |
   +-------------------------+
   |       Signature         |
   +-------------------------+
   ]]>
</artwork>
         </figure>
         
          <t>
            The contents of these parts are as follows:
	    <list style="hanging">
             <t></t><t hangText="Forwarding Header:">Each message has a generic header
             which is used to forward the message between peers and to its final
             destination. This header is the only information that an
             intermediate peer (i.e., one that is not the target of a message)
             needs to examine.</t>

             <t></t><t hangText="Message Contents:">The message being delivered between
             the peers. From the perspective of the forwarding layer, the
             contents is opaque, however, it is interpreted by the higher
             layers.</t>

             <t></t><t hangText="Signature:">A digital signature over the message
             contents and parts of the header of the message. Note that this
             signature can be computed without parsing the message contents.</t>
           </list></t>


           <t>The following sections describe the format of each part of the
           message.</t>
           
           <section anchor="sec-presentation-language" title="Presentation Langauge">
             <t>
               Most of the structures defined in this document (with
	       the exception of the forwarding header defined in the next section)
	       are defined using a C-like syntax based on the presentation language
	       used to define TLS.  Advantages of this style include:
             </t>
             <t>
               <list style="symbols">
                  <t>It is easy to write and familiar enough looking that most readers can grasp it quickly.</t>
                  <t>The ability to define nested structures allows a separation between high-level
                  and low level message structures.</t>
                  <t>It has a straightforward wire encoding that allows quick implementation,
                  but the structures can be comprehended without knowing the encoding.</t>
               </list>
               <t>
		  This presentation is to some extent a placeholder.
	          We consider it an open question what the final protocol definition
                  method and encodings use. 
		  We expect this to be a question for the WG to decide.
               </t>   
             </t>
             <t>
               Several idiosyncracies of this language are worth noting.
             </t>
             <t>
               <list style="symbols">
                  <t>All lengths are denoted in bytes, not objects.</t>
                  <t>Variable length values are denoted like arrays with angle brackets.</t>
                  <t>"select" is used to indicate variant objects.</t>
               </list>
             </t>
             <t>
               For instance, "uint16 array&lt;0..2^8-2&gt;;" represents up to 254 bytes
               but only up to 127 values of two bytes (16 bits) each..
             </t>
             <section anchor="sec-definitions" title="Common Definitions">
               <t>
                 The following definitions are used throughout RELOAD and so are
                 defined here. They also provide a convenient introduction to how
                 to read the presentation language.
               </t>
	       <t>
		 An enum represents an enumerated type. The values
		 associated with each possibility are represented in
		 parentheses and the maximum value is represented
		 as a nameless value, for purposes of describing
		 the width of the containing integral type. For 
		 instance, Boolean represents a true or false:
	       </t>
	       <figure>
		 <!--begin-pdu-->
		 <artwork><![CDATA[
       enum { false (0), true(1), (255)} Boolean;
       ]]>
		 </artwork>
	       </figure>
	       <t>
		 A boolean value is either a 1 or a 0 and is represented
		 as a single byte on the wire.
	       </t>
		<t>
		 The PeerId, shown below, represents a single Peer-ID.
	       </t>
         <figure>
           <!--begin-pdu-->
           <artwork><![CDATA[

           typedef opaque       PeerId[16];

       ]]></artwork>
         </figure>
         
         <t>
           A PeerId is a fixed-length
           128-bit structure represented as a series of bytes, most significant
           byte first. Note: the use of "typedef" here is an extension to the
           TLS language, but its meaning should be relatively obvious.
         </t>
	 <t>
	   A ResourceId, shown below, represents a single resource-id. 
	 </t>
         <figure>
           <!--begin-pdu-->
           <artwork><![CDATA[

           typedef opaque       ResourceId<0..255>;

       ]]></artwork>
         </figure>
         <t>
	   Like a PeerId, a resource-id is an opaque string of bytes,
	   but unlike Peer-IDs, resource ids are variable length, up to 255
           bytes (2048 bits) in length. On the wire, each ResourceId
	   is preceded by a single length byte (allowing lengths up to 
	   255). Thus, the 3-byte value "Foo" would be encoded as:
	   03 46 4f 4f.
         </t>
         <t>
           A more complicated example is IpAddressPort,
	   which represents a network address and
           can be used to carry either an IPv6 or IPv4 address:
         </t>
           
         <figure>
           <!--begin-pdu-->
           <artwork><![CDATA[

      enum {reserved(0), ip4_address (1), ip6_address (2), (255)} 
           AddressType;
      
      struct  {
        uint32                  addr;
        uint16                  port;
      } IPv4AddrPort;
      
      struct  {
        uint128                 addr;
        uint16                  port;
      } IPv6AddrPort;
      
      
      struct {
        AddressType             type;
        uint8                   length;
        
        select (type) {
          case ipv4_address:
             IPv4AddrPort;
          
          case ipv6_address:
             IPv6AddrPort;

          /* This structure can be extended */

       } IpAddressPort;

       ]]></artwork>
         </figure>

         <t>
           The first two fields in the structure are the same no 
           matter what kind of address is being represented:
         </t>
         <t>
           <list style="hanging">
             <t></t><t hangText="type "></t><t> the type of address (v4 or v6).</t>
             <t></t><t hangText="length "></t><t>the length of the rest of the structure.</t>
           </list>
         </t>
         <t>
           By having the type and the length appear at the beginning
           of the structure regardless of the kind of address being
           represented, an implementation which does not understand
           new address type X can still parse the IpAddressPort field 
           and then discard it if it is not needed.
         </t>
         <t>
           The rest of the IpAddressPort structure is either an IPv4AddrPort
           or an IPv6AddrPort. Both of these simply consist of an
           address represented as an integer and a 16-bit port.
           As an example, here is the wire representation of 
           the IPv4 address "192.0.2.1" with port "6100".
         </t>
         <figure>
           <artwork><![CDATA[
           01           ; type    = IPv4
           06           ; length  = 6
           c0 00 02 01  ; address = 192.0.2.21
           17 d4        ; port    = 6100
           ]]></artwork>
         </figure>
             </section>
           </section>
           <section anchor="sec-forwarding-header" title="Forwarding Header">
             <t>
               The layout of the forwarding header is shown below. We 
               present this as a bit diagram because it is mostly fixed
               and to show the similarities with other packet headers.
             </t>

        <figure>
          <artwork><![CDATA[
    0                   1                   2                   3 
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |1|     R       |       E       |       L       |       O       |
4  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           Overlay                             |
8  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |               |               |F|L|                           |
   |     TTL       |   Reserved    |R|F|      Fragment Offset      |
   |               |               |A|R|                           |
   |               |               |G|G|                           |
12 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |               |                                               |
   |    Version    |                    Length                     |
   |               |                                               | 
16 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        Transaction ID                         |
   +                                                               +
   |                                                               |
24 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     Via       |     Route     |                               |
   |     List      |     List      |            Flags              |
   |     Length    |     Length    |                               |
28 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   //                           Via List                          //
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   //                          Destination List                   //
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   //                          Route Log                          //
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   
]]></artwork>
        </figure>
         

         <t>The first four bytes identify this message as a RELOAD message. The
         message is easy to demultiplex from STUN messages by looking at the
         first bit.</t>

         <t>The Overlay field is the 32 bit checksum/hash of the overlay being
         used. The variable length string representing the overlay name is
         hashed with SHA-1 and the low order 32 bits are used. The purpose of
         this field is to allow nodes to participate in multiple overlays and
         to detect accidental misconfiguration.</t>

         <t>TTL (time-to-live) is an 8 bit field indicating the number of
         iterations, or hops, a message can experience before it is discarded.
         The TTL value MUST be decremented by one at every hop along the route
         the message traverses. If the TTL is 0, the message MUST NOT be
         propagated further and MUST be discarded. The initial value of the TTL
         should be TBD.</t>

         <t>FRAG is a 1 bit field used to specify if this message is a
         fragment.</t>

         <figure>
           <artwork><![CDATA[
           NOT-FRAGMENT    : 0x0          
           FRAGMENT        : 0x1
           ]]></artwork>
         </figure>

         <t>LFRG is a 1 bit field used to specify whether this is the last
         fragment in a complete message.</t>

         <figure>
           <artwork><![CDATA[
           NOT-LAST-FRAGMENT    : 0x0          
           LAST-FRAGMENT        : 0x1
           ]]></artwork>
         </figure>

         <t>[[Open Issue: How should the fragment offset and total length be
         encoded in the header? Right now we have 14 bits reserved with the
         intention that they be used for fragmenting, though additional bytes
         in the header might be needed for fragmentation.]]</t>

         <t>Version is a 7 bit field that indicates the version of the RELOAD
         protocol being used.</t>

         <figure>
           <artwork><![CDATA[
           Version1.0       : 0x1
           ]]></artwork>
         </figure>

         <t>The message Length is the count in bytes of the size of the
         message, including the header.</t>

         <t>The Transaction ID is a unique 64 bit number that identifies this
         transaction and also serves as a salt to randomize the request and the
         response. Responses use the same Transaction ID as the request they
         correspond to. Transaction IDs are also used for fragment
         reassembly.</t>

         <t>The Destination List Length and the Via List Length contain the
         lengths of the route and via lists respectively, in the number of
         objects.</t>

         <t>[[Open Issue: How should we handle Peer-ID lengths? This basically
         assumes they're fixed length per DHT algorithm (but not fixed-length
         for RELOAD) so that you can unambiguously parse things. Should we have
         a length byte?]]</t>

         <t>The flags word contains control flags. There is one currently
         defined flag.</t>

         <figure>
           <artwork><![CDATA[
           ROUTE-LOG       : 0x1
           ]]></artwork>
         </figure>

         <t>The ROUTE-LOG flag indicates that the route log should be included
         (see [XREF])</t>

         <t>The Destination List contains a sequence of destinations which the
         message should pass through. The destination list is constructed by
         the message originator. The first element in the destination list is
         where the message goes next. The list shrinks as the message traverses
         each listed peer. Destinations are defined at the end of this
         section.</t>

         <t>The Via List contains the sequence of destinations through which
         the message has passed. The via list starts out empty and grows as the
         message traverses each peer.</t>

         <t>If a message was being sent thought the sequences of peers A,B,C,D,
         the message from A to B would have a empty via list and a route of
         list of B,C,D. The message from B to C would have a via list of A then
         route of C,D and so on. This means that when the route list is
         followed exactly, all that is needed to update these lists is to
         change their lengths. This avoids the need to change or move any of
         the other list entries. In other cases, some entries may need to be
         copied or moved.</t>

         <t>The destination list and via lists are sequences of Destination values:</t>

         <figure>
           <!--begin-pdu-->
           
           <artwork><![CDATA[

      enum {reserved(0), peer(2), resource(2), compressed(3), (255) }
           DestinationType;
      
     
      select (destination_type) {
        case peer:
           PeerId               peer_id;
        
        case resource:
           ResourceId           resource_id;
      
        case compressed:
           opaque               compressed_id;
         
        /* This structure may be extended with new types */
      
      } DestinationData;

      struct {
        DestinationType         type;
        uint8                   length;
        DestinationData         destination_data;
      } Destination;
      ]]></artwork>
         </figure>
         
         <t>This is a TLV structure with the following contents:</t>
         <t>
         <list style="hanging">
           <t></t><t hangText="type "></t><t>
             The type of the DestinationData PDU. This may be one of
             "peer", "resource", or "compressed".
           </t>
           <t></t><t hangText="length "></t><t>
             The length of the destination_data.
           </t>
           <t></t><t hangText="destination_value "></t><t>
             The destination value itself, which is an encoded
             DestinationData structure, depending on the value
	     of "type".
           </t>
         </list>
         </t>
	 <t>
	   Note: This structure encodes a type, length, value. 
	   The length field specifies the length of the
	   DestinationData values, which allows the addition of new
	   DestinationTypes. This allows an implementation which does not understand
	   a given DestinationType to skip over it.
	 </t>
         
         <t>A DestinationData can be one of three types:</t>

         <t><list style="hanging">
           <t></t><t hangText="peer"></t><t>A Peer-ID.</t>

           <t></t><t hangText="compressed"></t><t>A compressed list of Peer-IDs and/or
           resources. Because this value was
           compressed by one of the peers, it is only meaningful to that peer
           and cannot be decoded by other peers. Thus, it is represented
	   as an opaque string.
	 </t>

           <t></t><t hangText="resource"></t><t>The resource id of the resource which is
           desired. This type MUST only appear in the final location of a
           destination list and MUST NOT appear in a via list. It is
           meaningless to try to route through a resource.</t>
         </list></t>

         <!-- EKR: Removed. This seems redundant at this point. 

         <section anchor="sec-reload-diffs"
                   title="Changes to Forwarding Header">
           <t>The RELOAD-01 forwarding header was completely fixed, whereas
           this header includes lists that change en-route. However, this type
           of operation is easily accomplished in both software and hardware,
           therefore we still view it as a low-overhead header. The changes
           include the following.</t>

           <t><list style="symbols">
             <t>Rearranged fields to have a cleaner separation between
             payload and header.</t>

             <t>Removed DHT, Hash, and Security parameters. These are now in
             the overlay bootstrap system rather than per-message.</t>

             <t>Source and destination IDs are now destination lists to
             accommodate source routing and recursion without state on
             intermediate peers.</t>

             <t>Added route log to header to allow payload/header
             separation.</t>
           </list></t>
         </section>

         -->


        <section anchor="sec-route-log" title="Route Logging">
          <t>The route logging feature provides diagnostic information about
          the path taken by the request so far and in this manner it is
          similar in function to <xref target="RFC3261">SIP's</xref> Via
          header field. If the ROUTE-LOG flag is set in the Flags word, at
          each hop peers MUST append a route log entry to the route log
          element in the header. The order of the route log entry elements in
          the message is determined by the order of the peers were traversed
          along the path. The first route log entry corresponds to the peer at
          the first hop along the path, and each subsequent entry corresponds
          to the peer at the next hop along the path. If the ROUTE-LOG flag is
          set in a request, the route log MUST be copied into the response and
          the ROUTE-LOG flag set so that the originator receives the ROUTE-LOG
          data.</t>

          <t>If the responder wishes to have a route log in the reverse
          direction, it MAY set the ROUTE-LOG flag in its response as well.
          Note, however, that this means that the response will grow on the
          return path, which may potentially mean that it gets dropped due to
          becoming too large for some intermediate hop. Thus, this option must
          be used with care.</t>

          <t>
            The route log is defined as follows:
          </t>

          <figure>
            <!-- begin-pdu-->
            <artwork>
<![CDATA[
    enum { reserved(0), tcp_tls(1),  udp_dtls(2),  (255)}  Transport;

    struct {
      opaque                 version<0..255>;    /* A string */
      Transport              transport;          /* TCP or UDP */
      PeerId                 id; 
      uint32                 uptime;
      IpAddressPortPort      address;
      opaque                 certificate<0..2^16-1>;
    } RouteLogEntry;

    struct {
       RouteLogEntry         entries<0..2^16-1>;
    } RouteLog;

]]></artwork>
          </figure>
          
          <t>The route log consists of an
          arbitrary number of RouteLogEntry values, each representing
	  one node through which the message has passed.</t>

          <t>Each RouteLogEntry consists of the following values:</t>

          <t><list style="hanging">
              <t></t><t hangText="version "></t><t>A textual representation of the software
              version</t>

              <t></t><t hangText="transport "></t><t>The transport type, currently
              either "tcp_tls" or "udp_dtls".</t>

              <t></t><t hangText="id "></t><t>The Peer-ID of the peer.</t>

              <t></t><t hangText="uptime "></t><t>The uptime of the peer in seconds.</t>

              <t></t><t hangText="address "></t><t>The address and port of the peer. </t>

              <t></t><t hangText="certificate "></t><t>The peer's certificate. Note that
              this may be omitted by setting the length to zero.</t>
            </list></t>
        </section>
      </section>

      <section anchor="sec-contents" title="Message Contents Format">
        <t>
	  The second major part of a RELOAD message is the contents
	  part, which is defined by MessageContents:</t>
        

         <figure>
           <!--begin-pdu-->
           
           <artwork><![CDATA[
       struct {
         MessageCode            message_code;
         opaque                 payload<0..2^24-1>;
       } MessageContents;
       
       ]]>
</artwork>
         </figure>
         
         <t>
           The contents of this structure are as follows:
         </t>
         <t>
         <list style="hanging">
           <t></t><t hangText="message_code "></t><t>
             This indicates the message that is being sent. The
             code space is broken up as follows.
             
             <list style="hanging">
              <t></t><t hangText="0">Reserved</t>

              <t></t><t hangText="1 .. 0x7fff">Requests and responses. These code
              points are always paired, with requests being odd and the
              corresponding response being the request code plus 1. Thus,
              PING_Q (the PING request) has value 1 and PING_A (the PING
              response) has value 2</t>

              <t></t><t hangText="0xffff">Error</t>
            </list></t>
            <t></t><t hangText="reserved "></t><t>
              A reserved 16-bit value. [TODO: Do we need this?]
            </t>
            <t></t><t hangText="message_body "></t><t>
              The message body itself, represented as a variable-length
              string of bytes. The bytes themselves are dependent on the code
              value. See the sections describing the various RELOAD methods
              (JOIN, UPDATE, CONNECT, STORE, FETCH, etc.) for the definitions
              of the payload contents.</t>
         </list>
         </t>
         <t>
           [TODO: We could represent this as a big select() with enums
           as well. That sort of removes layering but is clearer from
           a presentation language perspective. Comments?]
         </t>

         <section anchor="sec-response-code"
                   title="Response Codes and Response Errors">

           <t>A peer processing a request returns its status in the message_code
           field of the header. If the request was a success, then the
           message code is the response code that matches the request (i.e., the
           next code up). The response payload is then as defined in the
           request/response descriptions.</t>

           <t>If the request failed, then the message code is set to 0xffff
           (error) and the payload MUST be an error_response PDU, as shown
           below.</t>

           <t>
	     When the message code is 0xffff, the payload MUST be an
	     ErrorResponse.
	   </t>


           <figure>
             <!--begin-pdu-->
             <artwork><![CDATA[

       public struct {
         uint16             error_code;
         opaque             reason_phrase<0..255>;  /* String*/
         opaque             error_info<0..65000>;
       } ErrorResponse;

             ]]></artwork>
           </figure>

           <t>The contents of this structure are as follows:</t>

           <t><list style="hanging">
             <t></t><t hangText="error_code "></t><t>A numeric error code indicating the
             error that occurred.</t>

             <t></t><t hangText="reason_phrase "></t><t>A free form text string indicating
             the reason for the response. The reason phrase SHOULD BE as
             indicated in the error code list below (e.g., "Moved Temporarily).</t>

             <t></t><t hangText="error_info "></t><t>Payload specific error information.
             This MUST be empty (zero length) except as specified below.</t>
           </list></t>

           <t>The following error code values are defined. [[TODO: These are
           currently semi-aligned with SIP codes. that's probably bad and we need
           to fix.]</t>

           <t><list style="hanging">
             <t></t><t hangText="302 (Moved Temporarily):">The requesting peer SHOULD
             retry the request at the new address specified in the 302 response
             message.</t>

             <t></t><t hangText="401 (Unauthorized):">The requesting peer needs to
             sign and provide a certificate. [[TODO: The semantics here don't
             seem quite right.]]</t>

             <t></t><t hangText="403 (Forbidden):">The requesting peer does not have
             permission to make this request.</t>

             <t></t><t hangText="404 (Not Found):">The resource or peer cannot be
             found or does not exist.</t>

             <t></t><t hangText="408 (Request Timeout):">A response to the request has
             not been received in a suitable amount of time. The requesting
             peer MAY resend the request at a later time.</t>

             <t></t><t hangText="412 (Precondition Failed):">A request can't be
             completed because some precondition was incorrect. For instance,
             the wrong generation counter was provided</t>

             <t></t><t hangText="498 (Incompatible with Overlay)">A peer receiving the
             request is using a different overlay, DHT algorithm, or hash
             algorithm. [[Open Issue: What is the best error number and reason
             phrase to use?]]</t>

             <t></t><t hangText="499 (UnWilling To Proxy)">A peer receiving the
             request is unwilling to support the Routing mechanism specified in
             the Routing field of the message header. [[Open Issue: What is the
             best error number and reason phrase to use?]]</t>
           </list></t>
         </section>

      </section>
        <section anchor="sec-signature" title="Signature">

          <t>
	    The third part of a RELOAD message is the signature,
	    represented by a Signature structure.
	    The Signature PDU is used to attach signatures to messages
	    and or stored data elements. All signatures are formatted using this
	    element. However, the input structure to the signature computation
	    varies depending on the data element being signed.
	  </t>

          <figure>
            <!--begin-pdu-->
            
            <artwork><![CDATA[


       enum {reserved(0), signer_identity_peer (1), 
             signer_identity_name (2), signer_identity_certificate (3), 
             (255)} SignerIdentityType;

       select (identity_type) {
         case signer_identity_peer:
           PeerId               id;
 
         case signer_identity_name:
           opaque               name<0..2^16-1>;
         
         case signer_identity_certificate:
           opaque               certificate<0..2^16-1>;

         /* This structure may be extended with new types */
       } SignerIdentityValue;


       struct {
         SignerIdentityType     identity_type;
         uint16                 length;
         SignerIdentityValue    identity[SignerIdentity.length];
       } SignerIdentity;


       struct  {
          SignatureAndHashAlgorithm     algorithm;
          SignerIdentityType            identity;
          opaque                        signature_value<0..2^16-1>;
       } Signature;


]]></artwork>
          </figure>

          <t>The signature construct contains the following values:</t>

          <t><list style="hanging">
              <t></t><t hangText="algorithm "></t><t>The signature algorithm in use.
              The algorithm definitions are found in the IANA 
	      TLS SignatureAlgorithm Registry.</t>

              <t></t><t hangText="identity "></t><t>The identity or certificate used to
              form the signature</t>
              
              <t></t><t hangText="signature_value "></t><t>The value of the signature</t>
              
            </list></t>

          <t>A number of possible identity formats are permitted. The current
	  possibilities are: a Peer-ID, a user name, and a certificate.</t>

          <t>For signatures over messages the input to the signature is computed
	  over: 
          </t>
          <t>
          <list>
            <t>overlay + transaction_id + MessageContents + SignerIdentity</t>
          </list>
          </t>
          <t>
            Where overlay and transaction_id come from the forwarding header
	    and + indicates concatenation.
          </t>
          <t>[[TODO: Check the inputs to this carefully.]]</t>

          <t>The input to signatures over data values is different, and is
          described in [XREF].</t>
      </section>
    </section>
    <section title="Overlay Topology">
      <t>[TODO: UNKNOWN]</t>
      <section title="Topology Plugin Overview">
         <t>[TODO: UNKNOWN]</t>
      </section>
      <section title="Topology Plugin Requirements">
        <t>When specifying a new DHT, at least the following need to be
        described:</t>

        <t><list style="symbols">
            <t>Joining procedures, including the contents of the JOIN
            message.</t>

            <t>Stabilization procedures, including the contents of the UPDATE
            message, the frequency of topology probes and keepalives, and the
            mechanism used to detect when peers have disconnected.</t>

            <t>Exit procedures, including the contents of the LEAVE
            message.</t>

            <t>The hash algorithm used to go from a Unhashed-ID, such as a
            user name, to a Resource-ID. This also includes the length of the
            Resource-IDs and Peer-IDs</t>

            <t>The procedures that peers use to route messages.</t>

            <t>The replication strategy used to ensure data redundancy.</t>
          </list></t>
      </section>
      <section title="Methods and types for use by topology plugins">
	<t>[TODO: UNKNOWN]</t>
        <section title="JOIN">
          <t>A new peer (but which already has credentials) uses the JOIN_Q
          message to join the DHT. The JOIN_Q is sent to the peer which
          previously was responsible for the resource-id corresponding to the
          Peer-ID which the new peer has. This notifies the responsible peer
          that the new peer is taking over some of the overlay and it needs to
          synchronize its state.</t>
          <figure>
            <!--begin-pdu-->
            <artwork><![CDATA[
       struct {
          PeerId                desired_peer_id;
          opaque                dht_specific_data<0..2^16-1>;
       } JoinQ;

              ]]></artwork>
          </figure>

          <!--    join-request = Peer-ID -->

          <t>The minimal JOIN_Q contains only the Peer-ID which the sending
          peer wishes to assume. DHTs MAY specify other data to appear in
          this request.</t>

          <t>If the request succeeds,
	  the responding peer responds with a JOIN_A message, 
	  as defined below:</t>
          <figure>
            <!--begin-pdu-->
            <artwork><![CDATA[
       struct {
          opaque                dht_specific_data<0..2^16-1>;
       } JoinQ;
              ]]></artwork>
          </figure>

	<t>
	  If the request succeeds, the responding peer MUST follow up by
	  executing the right sequence of
          STOREs and UPDATEs to transfer the appropriate section of the
          overlay space to the joining peer. In addition, DHTs MAY define data
          to appear in the response payload that provides additional info.</t>
        </section>


        <section title="LEAVE">

          <t>The LEAVE_Q message is used to indicate that a peer is exiting
          the overlay. The peer SHOULD send this message to each peer with
          which it is directly connected prior to exiting the overlay.</t>

          <figure>
            <!--begin-pdu-->
            <artwork><![CDATA[

       public struct {
          PeerId                leaving_peer_id;
          opaque                dht_specific_data<0..2^16-1>;
       } LeaveQ;

              ]]></artwork>
          </figure>

          <!--    leave-request = Peer-ID -->

          <t>The default LEAVE_Q contains only the Peer-ID of the leaving
          peer. DHTs MAY other specify data to appear in this request.</t>

          <t>Upon receiving a LEAVE request, a peer MUST update its own
          routing and routing table, and send the appropriate STORE/UPDATE
          sequences to re-stabilize the overlay.</t>
        </section>

        <section title="UPDATE">
          <t>Update is the primary DHT-specific maintenance message. It is
          used by the sender to notify the recipient of the sender's view of
          the current state of the overlay and it is up to the recipient to
          take whatever actions are appropriate to deal with the state
          change.</t>

          <t>The contents of the UPDATE_Q message are completely DHT-specific.
          The UPDATE_A response is expected to be either success or an
          error.</t>
	  
        </section>

        <section anchor="sec-route-query" title="ROUTE_QUERY">
          <t>The ROUTE_QUERY request allows the sender to ask a peer where
          they would route a message directed to a given destination. In other
          words, a ROUTE-QUERY for destination X requests the Peer-ID where
          the receiving peer would next route to get to X. A ROUTE-QUERY can
          also request that the receiving peer initiate an UPDATE request to
          transfer his routing table.</t>

          <t>One important use of the ROUTE-QUERY request is to support
          iterative routing. The way that this works is that the sender selects
          one of the peers in its neighbor table and sends it a ROUTE-QUERY
          message with the destination_object set to the Peer-ID/resource-id
          it wishes to route to. The neighbor responds with the next Peer-ID
          to send to. The sending peer then CONNECTs to that peer and repeats
          the ROUTE-QUERY. Eventually, the sender gets a response from a peer
          containing a Peer-ID that is the same as the responding peer, which
	  means that the responding peer is the closest. At that point,
          the sender can send whatever request is needed directly to that
          peer.</t>

          <t>Note that this procedure only works well if all the peers are
          mutually directly reachable--either by all having public IP
          addresses or at least by all being behind the same NAT. Accordingly,
          peers MUST only use this method if permitted by the overlay
          configuration (see [XREF]).</t>

          <section title="Request Definition">
            <t>A ROUTE_QUERY_Q message indicates the peer or resource that the
            requesting peer is interested in. It also contains a "send_update"
            option allowing the requesting peer to request a full copy of the
            other peer's routing table.</t>

            <figure>
              <!--begin-pdu-->

              <artwork><![CDATA[
       struct {
         Boolean                send_update;
         Destination            destination;
       } RouteQueryQ;

              ]]></artwork>
            </figure>

            <t>The contents of the ROUTE_QUERY_Q message are as follows:</t>

            <t><list style="hanging">
                <t></t><t hangText="send_update "></t><t>A single byte. This may be set to "true"
                to indicate that the requester wishes the responder to
                initiate an UPDATE request immediately. Otherwise, this value
                MUST be set to "false".</t>

                <t></t><t hangText="destination "></t><t>The destination which the
                requester is interested in. This may be any valid destination
                object, including a Peer-ID, compressed ids, or
                resource-id</t>
              </list></t>
          </section>

          <section title="Response Definition">
            <t>A response to a successful ROUTE_QUERY request is a
            ROUTE_QUERY_A message containing the address of the peer to which
            the responding peer would have routed the request message in
            recursive routing.</t>

            <figure>
              <!--begin-pdu-->
              <artwork>
<![CDATA[
    struct {
       PeerId                  next_id;

       select (IterativeAllowed) {
          case True:
             IpAddressPort           next_addr;
          
           case False:               /* Empty*/
        };
      } RouteQueryA;
]]></artwork>
            </figure>

            <t>The contents of the ROUTE_QUERY_A are as follows:

	      <list style="hanging">
                <t></t><t hangText="next_peer "></t><t>The peer to which the responding peer
                would route the message to in order to deliver it to the
                destination listed in the request.</t>

                <t></t><t hangText="next_addr"></t><t>The address of the next peer.</t>
              </list></t>

            <t>If the requester set the send_update flag, the responder SHOULD
            initiate an UPDATE immediately after sending the ROUTE_QUERY_A.</t>
          </section>
         </section>
      </section>
    </section>
    <section title="Forwarding Layer">
      <t>
         Each node maintains connections to a set of other nodes defined
         by the topology plugin. For instance, in the Chord topology
         described in [XREF], node would maintain
         connections to 16 nodes in its finger table and to 6 neighbors.
         RELOAD currently supports two transport protocols: TLS 
         [REF]
         over TCP and DTLS <xref target="RFC4347"/> over UDP.
         RELOAD messages are transported directly over the transport
         protoccol with no framing other than that described in [XREF].
      </t>
      <t>
         Note that
         although UDP does not properly have "connections", DTLS provides
         a similar stateful construct and we simply refer to "connections"
         in this document.
      </t>
      
      <section title="Reliability for Unreliable Transports">
          <t>When RELOAD is carried over DTLS or another unreliable transport,
          it needs to be used with a reliability and flow control mechanism,
          which is provided on a hop-by-hop basis, matching the semantics if
          TCP were used. The basic principle is that each message, regardless
          of if it carries a request or responses, will get an ACK and be
          reliably retransmitted. The receiver's job is very simple, limited
          to just sending ACKs. All the complexity is at the sender side. This
          allows the sending implementation to trade off performance versus
          implementation complexity without affecting the wire protocol.</t>
          
          <t>
            In order to support unreliable transport, each message is wrapped
            in a very simple framing layer (FramedMessage)
            which is only used for each hop.
            This layer contains a sequence number which can then be used
            for ACKs.
          </t>
          <section title="Framed Message Format">
	    <t>
	      The definition of FramedMessage is:
            </t>
            <figure>
              <!--begin-pdu-->
                        
              <artwork><![CDATA[

      enum {data (1), ack (2)} FramedMessageType;

      struct {            
        FramedMessageType       type;

        select (type) {
          case data:
            uint24              sequence;
            opaque              message<0..2^24-1>;

          case ack:
            uint24              ack_sequence;
            uint32              received;            
        };
      } FramedMessage;

      ]]>
              </artwork>
            </figure>

            <t>The type field of the PDU is set to indicate whether the message
            is data or an acknowledgement.</t>

            <t>If the message is of type "data", then the remainder of the PDU is
            as follows:
              <list style="hanging">
                <t></t><t hangText="sequence "></t><t> the sequence number</t>
                <t></t><t hangText="message "></t><t> the original message that is being transmitted.</t>
              </list>
            </t>
            <t>
              Each connection has it own sequence number. Initially the
              value is zero and it increments by exactly one for each message
              sent over that connection.
            </t>
            <t>
              When the receiver receive a message, it SHOULD immediately send
              an ACK message. The receiver MUST keep track of the 32 most recent
              sequence numbers received on this association in order to generate
              the appropriate ack.
	      The contents of the ACK PDU are as follows:
              <list style="hanging">
                <t></t><t hangText="ack_sequence "></t><t>
                  The sequence number of the message being acknowledged.
                </t>
                <t></t><t hangText="received "></t><t>
                  A bitmask indicating whether or not
                  each of the previous 32 packets has been received before
		  the sequence number in ack_sequence. The high
                  order bit represents the first packet in the sequence
                  space.
                </t>
              </list>
            </t>
            <t>
              The received field bits in the ACK provide a very high degree
             of redundancy for the sender to figure out which packets the
             receiver received and can then estimate packet loss rates. If the
             sender also keeps track of the time at which recent sequence
             numbers were sent, the RTT can be estimated.
            </t>
          </section>
          
          <section title="Retransmission and Flow Control">
             <t>Because the receiver's role is limited to providing packet
             acknowledgements, a wide variety of congestion control algorithms
             can be implemented on the sender side while using the same basic
             wire protocol. It is RECOMMENDED that senders implement
             TFRC-SP<xref target="RFC4828"></xref> and use the received bitmask
             to allow the sender to compute packer loss event rates. Senders
             MUST implement a retransmission and congestion control scheme no
             more aggressive then TFRC-SP.</t>
           </section>
         </section>

         <!-- EKR REMOVED
              <section title="HIP">
              <t>RELOAD MAY also be used with a HIP transport using the architecture
              for HIP BONE described in <xref
              target="I-D.camarillo-hip-bone"></xref>. From the perspective of the
              P2P layer, HIP looks very much like normal IP. Either TLS (over TCP)
              or DTLS (over UDP) is run over top of the HIP. Thus the reliability
              and congestion control schemes are the same for DTLS section. If an
              overlay is configured such that HIP is the only transport that it will
              use, then it may make sense to configure the p2p layer to only offer
              the ORCHID when gather candidate addresses for ICE. This will
              effectively disable ICE at the p2p layer.</t>

              <t>For overlays that use HIP, the enrollment server MUST provide each
              peer with a unique ORCHID and use that ORCHID to generate the Peer-ID
              for the peer (see <xref target="sec-credentials"></xref>. Later when
              the HIP layer wishes to tunnel a message (such as an I1 message)
              through the overlay, the HIP layer can use the ORCHID to generate the
              Peer-ID, and then use the TUNNEL message with the HIP to route the
              message to that the peer that owns that ORCHID.</t>
              </section>
              
              <section title="TLS">
              <t>TLS runs on top of TCP which offers the best performance from a
              data transfer point of view and does not require as frequent keep
              alive messages.</t>
              </section>
         -->


        <section anchor="sec-frag-reass" title="Fragmentation and Reassembly">
          <t>In order to allow transport over datagram protocols, RELOAD
          messages may be fragmented. If a message is too large for a peer to
          transmit to the next peer it MUST fragment the message. Note that
          this implies that intermediate peers may re-fragment messages if the
          incoming and outgoing paths have different maximum datagram sizes.
          Intermediate peers SHOULD NOT reassemble fragments.</t>

          <t>Upon receipt of a fragmented message by the intended peer, the
          peer holds the fragments in a holding buffer until the entire
          message has been received. The message is then reassembled into a
          single unfragmented message and processed. In order to mitigate
          denial of service attacks, receivers SHOULD time out incomplete
          fragments. [[TODO: Describe algorithm]]</t>
        </section>
      <section title="Connection Management">
	<t>
	  RELOAD provides a number of methods to establish and
	  maintain connections between the nodes in the overlay.
	</t>
        <section anchor="sec-connect-details" title="CONNECT">
          <t>A node sends a CONNECT request when it wishes to establish a
          direct TCP or UDP connection to another node for the purposes of
          sending RELOAD messages or application layer protocol messages, such
          as SIP. Detailed procedures for the CONNECT and its response are
          described in [XREF].</t>

          <t><list style="hanging">
              <t></t><t hangText="Note:">A CONNECT does not result in updating the
              routing table of either node. That function is performed by
              UPDATEs. If node A has CONNECTed to node B, it MAY route
              messages which are directly addressed to B through that channel
              but MUST NOT route messages through B to other peers via that
              channel.</t>
            </list></t>

          <section anchor="sec-connect-request" title="Request Definition">
            <t>A CONNECT_Q message contains the requesting peer's ICE
            connection parameters formatted into a binary structure.</t>

            <figure>
              <!--begin-pdu-->

              <artwork><![CDATA[

      typedef opaque            IceCandidate<0..2^16-1>;

      struct  {
        opaque                  ufrag<0..255>;
        opaque                  password<0..255>;                
        uint16                  application;
        opaque                  fingerprint<0..255>;
        opaque                  role<0..255>;
        IceCandidate            candidates<0..2^16-1>;
      } ConnectQA;


]]></artwork>
            </figure>

            <t>The values contained in ConnectQA are:
	    <list style="hanging">
                <t></t><t hangText="ufrag "></t><t>The username fragment (from ICE)</t>

                <t></t><t hangText="password "></t><t>The ICE password.</t>

                <t></t><t hangText="application "></t><t>A 16-bit port number. This port
                number represents the IANA registered port of the protocol
                that is going to be sent on this connection. For SIP, this is
                5060 or 5061, and for RELOAD is TBD. By using the IANA
                registered port, we avoid the need for an additional registry
                and allow RELOAD to be used to set up connections for any
                existing or future application protocol.</t>

                <t></t><t hangText="fingerprint "></t><t>One fingerprint attribute (from
                RFC 4572 <xref target="RFC4572"></xref>).</t>

                <t></t><t hangText="role "></t><t>An active/passive/actpass attribute from
                RFC 4145 <xref target="RFC4145"></xref>.</t>

                <t></t><t hangText="candidates "></t><t>One or more ICE candidate values.
                Each candidate has an IP address, IP address family, port,
                transport protocol, priority, foundation, component ID, STUN
                type and related address. The candidate_list is a list of
                string candidate values.</t>
              </list></t>

            <t>These values should be generated using the procedures of [XREF].</t>
          </section>

          <section anchor="sec-connect-response" title="Response Definition">
            <t>If a peer receives a CONNECT request, it SHOULD follow the
            procedures of [XREF] to process
            the request and generate its own response (a CONNECT_A) containing
            a ConnectQA. It should then begin ICE checks. When a
            peer receives a CONNECT response, it SHOULD parse the response and
            begin its own ICE checks.</t>
          </section>
        </section>

        <section title="PING">
          <t>PING is used to test connectivity along a path. A ping can be
          addressed to a specific Peer-ID or to the broadcast Peer-ID (all
          1s). In either case, the target Peer-IDs respond with a simple
          response containing some status information.</t>

          <section title="Request Definition">
            <t>The PING_Q message contains a list (potentially empty) of the
            pieces of status information that the requester would like the
            responder to provide.</t>

            <figure>
              <!--begin-pdu-->
              <artwork><![CDATA[
      enum { responsible_set(1), num_resources(2), (255)} 
           PingInformationType;

      struct {
        PingInformationType     requested_info<0..255>;
      } PingQ

]]></artwork>
            </figure>

            <t>The two currently defined values for PingInformation are:</t>
            
            <list style="hanging">
              <t></t><t hangText="responsible_set"></t><t>
                indicates that the peer should Respond with the
                fraction of the overlay for which the responding peer is
                responsible.
              </t>
              
              <t></t><t hangText="num_resources"></t><t>
                indicates that the peer should Respond with the
                number of resources currently being stored by the peer.
              </t>
            </list>
          </section>


          <section title="Response Definition">
            <t>A successful PING_A response contains the information elements
            requested by the peer.</t>

            <figure>
              <!--begin-pdu-->
              <artwork><![CDATA[

       struct {
         PingInformationType    type;
         
         select (type) {
           case responsible_set:
             uint32             responsible_ppb;

           case num_resources:
             uint32             num_resources;                           

           /* This type may be extended */

         };
       } PingInformation;

       struct {
         uint64                 response_id;
         PingInformation        ping_info<0..2^16-1>;
       } PingA;


]]></artwork>
            </figure>

            <t>
	      A PING_A message contains the following elements:
	      <list style="hanging">
                <t></t><t hangText="response_id "></t><t>A randomly generated 64-bit
                response ID. This is used to distinguish PING responses in
                cases where the PING request is multicast.</t>

                <t></t><t hangText="ping_info "></t><t>A sequence of PingInformation structures,
                as shown below.</t>
              </list>
            </t>
             
            <t>
              Each of the current possible PING information types is a 32-bit
              unsigned integer. For type "responsible_ppb", it is the
              fraction of the overlay for which the peer is responsible
              in parts per billion. For type "num_resources", it is the
              number of resources the peer is storing.
            </t>

            <t>The responding peer SHOULD include any values that the
            requesting peer requested and that it recognizes. They SHOULD be
            returned in the requested order. Any other values MUST NOT
	    be returned.</t>
          </section>
        </section>

<!-- EKR: REMOVED 
        <section anchor="sec-tunnel-details" title="TUNNEL">
          <t>A node sends a TUNNEL request when it wishes to exchange
          application-layer protocol messages without the expense of
          establishing a direct connection via CONNECT or when ICE is unable
          to establish a direct connection via CONNECT and a TURN relay is not
          available. The application-level protocols that are routed via the
          TUNNEL request are defined by that application's usage.</t>

          <t><list style="hanging">
              <t></t><t hangText="Note:">The decision of whether to route
              application-level traffic across the overlay or to open a direct
              connection requires careful consideration of the overhead
              involved in each transaction. Establishing a direct connection
              requires greater initial setup costs, but after setup,
              communication is faster and imposes no overhead on the overlay.
              For example, for the SIP usage, an INVITE request to establish a
              voice call might be routed over the overlay, a SUBSCRIBE with
              regular updates would be better used with a CONNECT, and media
              would both impose too great a load on the overlay and likely
              receive unacceptable performance. However, there may be a
              tradeoff between locating TURN servers and relying on TUNNEL for
              packet routing.</t>
            </list></t>

          <t>When a usage requires the TUNNEL method, it must specify the
          specific application protocol(s) that will be TUNNELed and for each
          protocol, specify:</t>

          <t><list style="symbols">
              <t>An application attribute that indicates the protocol being
              tunneled. This the IANA-registered port of the application
              protocol.</t>

              <t>The conditions under which the application will be TUNNELed
              over the overlay rather than using a direct CONNECT.</t>

              <t>A mechanism for moving future application-level communication
              from TUNNELing on the overlay to a direct CONNECTion, or an
              explanation why this is unnecessary.</t>

              <t>A means of associating messages together as required for
              dialog-oriented or request/response-oriented protocols.</t>

              <t>How the TUNNELed message (and associated responses) will be
              delivered to the correct application. This is particularly
              important if there might be multiple instances of the
              application on or behind a single peer.</t>
            </list></t>

          <section anchor="sec-tunnel-request" title="Request Definition">
            <t>The TUNNEL_Q message contains the application PDU that the
            requesting peer wishes to transmit, along with some control
            information identifying the handling of the PDU.</t>
             -->

<!--            <figure>
              <artwork><![CDATA[

   public struct  {
       uint16 application;
       string dialog_id;
       string application_pdu;
   } tunnel_q;

]]></artwork>
            </figure>
-->
<!--
            <t>The values contained in the TUNNEL_Q are:</t>

            <t><list style="hanging">
                <t></t><t hangText="Application "></t><t>A 16-bit port number. This port
                number represents the IANA registered port of the protocol
                that is going to be sent on this connection. For SIP, this is
                5060 or 5061, and for RELOAD is TBD. By using the IANA
                registered port, we avoid the need for an additional registry
                and allow RELOAD to be used to set up connections for any
                existing or future application protocol.</t>

                <t></t><t hangText="Dialog ID "></t><t>An arbitrary string providing an
                application-defined way of associating related TUNNELed
                messages. This attribute may also encode sequence information
                as required by the application protocol.</t>

                <t></t><t hangText="Application PDU "></t><t>An application PDU in the
                format specified by the application.</t>
              </list></t>
          </section>

          <section anchor="sec-tunnel-response" title="Response Definition">
            <t>A TUNNEL_A message serves as confirmation that the message was
            received by the destination peer. It implies nothing about the
            processing of the application. If the application protocol
            specifies an acknowledgement or confirmation, that must be sent
            with a separate TUNNEL request</t>
          </section>
        </section>
-->

      </section>
      </section>
      <section title="Diagnostics">
         <t>[TODO: SAB]</t>
      </section>
    </section>
    <section title="Data Storage Protocol">
      <t>
         RELOAD provides a set of generic mechanisms for storing and retrieving
         data in the DHT Instance. These mechanisms can be used for new applications
         simply by defining new code points and a small set of rules.
         No new protocol mechanisms are required.
      </t>
      <t>
        The basic unit of stored data is a single StoredData structure:
      </t>
           <figure>
              <!--begin-pdu-->
              <artwork><![CDATA[

      struct {
        uint32                  length;
        uint64                  storage_time;
        uint32                  lifetime;
        StoredDataValue         value;
        Signature               signature;
      } StoredData;

      ]]>
      </artwork>
    </figure>
    <t>
      The contents of this structure are as follows:
      <list style="hanging">
      <t></t><t hangText="length "></t><t>The length of the rest of the
      structure in octets.</t>

      <t></t><t hangText="storage_time "></t><t>The time when the data was stored
      in absolute time, represented in seconds since the Unix epoch.
      Any attempt to store a data value with a storage time before
      that of a value already stored at this location MUST generate a
      412 error. This prevents rollback attacks. Note that this does
      not require synchronized clocks: the receiving peer uses the
      storage time in the previous store, not its own clock.</t>

      <t></t><t hangText="lifetime "></t><t>The validity period for the data, in
      seconds, starting from the time of store.</t>

      <t></t><t hangText="value "></t><t>The data value itself, as described
      in <xref target="sec-kind-model"/>.</t>


      <t></t><t hangText="signature "></t><t>A signature over the data value.
      <xref target="sec-data-sig"></xref> describes the signature
      computation. The element is formatted as described in <xref
      target="sec-signature"></xref></t>
    </list></t>

    <t>
      [TODO: this doesn't include the resource ID and kind to
      avoid duplicating it in each value. It would make things
      more self-contained, though.]
    </t>
    <t>
      Each resource-id specifies a single location in the DHT Instance.
      However, each location may contain multiple StoredData values
      distinguished by kind-id. 
      The definition of a kind describes
      both the data values which may be stored and the data
      model of the data. Some data models allow multiple values
      to be stored under the same kind-id. Section <xref target="sec-kind-model"/>
      describes the available data models.
      Thus, for instance, a given resource-id might contain 
      a single-value element stored under kind-id X and
      an array containing multiple values stored under kind-id Y. 
    </t>

    <section anchor="sec-data-sig" title="Data Signature Computation">

      <t>Each StoredData element is individually signed. However, the
      signature also must be self-contained and cover the kind-id and
      resource-id even though they are not present in the StoredData
      structure. The input to the signature algorithm is:</t>

      <t><list>
	<t>
	  resource_id + kind + StoredData
	</t>
      </list>
      </t>

      <t>Where these values are:
      <list style="hanging">
        <t></t><t hangText="resource "></t><t>The resource ID where this data is
        stored.</t>

        <t></t><t hangText="kind "></t><t>The kind-id for this data.</t>

        <t></t><t hangText="StoredData "></t><t>The contents of the stored data
        value, as described in the previous sections.</t>
      </list></t>

      <t>[[TODO: Should we include the identity?.]]</t>

      <t>Once the signature has been computed, the signature is
      represented using a signature element, as described in <xref
      target="sec-signature"></xref>.</t>
    </section>

    <section title="Data Models" anchor="sec-kind-model">
      <t>
        The protocol currently defines the following data
        models:
      </t>
      <t>
        <list style="symbols">
        <t>single value</t>

        <t>array</t>

        <t>dictionary</t>
      </list></t>

      <t>
	These are represented with the StoredDataValue structure:
      </t>
        <figure>
          <!--begin-pdu-->
          <artwork><![CDATA[
                    
      enum { reserved(0), single_value(1), array(2), 
             dictionary(3), (255)} DataModel;

      struct {
        Boolean                exists;
        opaque                 value<0..2^32-1>;
      } DataValue;
      
      select (DataModel) {
        case single_value:
          DataValue             single_value_entry;
 
        case array:
          ArrayEntry            array_entry;

        case DictionaryEntry:
          DictionaryEntry       dictionary_entry;


        /* This structure may be extended */
      } StoredDataValue;

      
      ]]>
          </artwork>           
        </figure>

         <t>We now discuss the properties of each data model in turn:</t>

         <section title="Single Value">
           <t>
	     A single-value element is a simple, opaque sequence of bytes.
	     There may be only one single-value element for each
	     resource-id, kind-id pair.
           </t>
           <t>
             A single value element is represented as a DataValue,
	     which contains the following two values:
	     <list style="hanging">
	       <t hangText="exists"></t><t>This value indicates
	       whether the value exists at all. If it is set to
	       False, it means that no value is present. If it
	       is True, that means that a value is present. This
	       gives the protocol a mechanism for indicating 
	       nonexistence as opposed to emptiness.
	       </t>
	       <t hangText="value"></t><t>The stored data.</t>
	     </list>
	   </t>
         </section>

         <section title="Array">
           <t>An array is a set of opaque values addressed by an
	   integer index. Arrays are zero based. Note that arrays can be sparse. 
	   For instance, a store of "X" at index 2 in an empty array produces an array with the values [
           NA, NA, "X"]. Future attempts to fetch elements at index 0 or 1
           will return values with "exists" set to False.
	   </t>

           <t>
             A array element is represented as an ArrayEntry:
           </t>

            <figure>
              <!--begin-pdu-->
              <artwork><![CDATA[
            
       struct {
         int32                  index;
	 DataValue              value;
       } ArrayEntry;

       ]]>
              </artwork>
            </figure>
	    <t>
	      The contents of this structure are:
	      <list style="hanging">
		<t hangText="index"></t><t>The index of the data element in
		the array. Must be nonnegative or -1.</t>
		<t hangText="value"></t><t>The stored data.</t>
	      </list>
	    </t>
	    <t>
	      <!-- 
	      TODO: EKR, clean up the story about the indices and
	      appending (-1)
	      -->
	    </t>
	 </section>
         <section title="Dictionary">
           <t>A dictionary is a set of opaque values indexed by an 
	   opaque key with one value for each key.
           single dictionary entry is represented as follows
           </t>

           <t>
             A dictionary element is represented as a DictionaryEntry:
           </t>

            <figure>
              <!--begin-pdu-->
              <artwork><![CDATA[
              
       typedef opaque           DictionaryKey<0..2^16-1>;
              
       struct {
         DictionaryKey          key;
	 DataValue		value;
       } DictionaryEntry;


       ]]>
              </artwork>
            </figure>
	    <t>
	      The contents of this structure are:
	      <list style="hanging">
		<t hangText="key"></t><t>The dictionary key for this value.</t>
		<t hangText="value"></t><t>The stored data.</t>
	      </list>
	    </t>
         </section>
         </section>
         <section title="Data Storage Methods">
	   <t>
	     RELOAD provides several methods for storing and retrieving data:
	     <list style="symbols">
	       <t>STORE values in the overlay</t>
	       <t>FETCH values from the overlay</t>
	       <t>REMOVE values from the overlay</t>
	       <t>FIND the values stored at an individual peer</t>
	     </list>
	   </t>
	   <t>
	     These methods are each described in the following sections.
	   </t>

          <section anchor="sec-store" title="STORE">
	       
          <t>The STORE method is used to store data in the overlay.
          The format of the STORE request depends on the data model which is determined by the kind.</t>

          <section anchor="sec-store-req" title="Request Definition">
            <t>A STORE_Q message is a sequence of StoreKindData values, each of
            which represents a sequence of stored values for a given kind. The
            same kind-id MUST NOT be used twice in a given store request. Each
            value is then processed in turn. These operations MUST be atomic.
            If any operation fails, the state MUST be rolled back to before
            the request was received.</t>
	    
	    <t>
	      The store request is defined by the StoreQ structure:
	    </t>

            <figure>
              <!--begin-pdu-->
              <artwork><![CDATA[
     struct {
         KindId                 kind;
         DataModel              data_model;
         uint64                 generation_counter;
         StoredData             values<0..2^32-1>;
     } StoreKindData;

     struct {
         ResourceId             resource;
         StoreKindData          kind_data<0..2^32-1>;
     } StoreQ;


              ]]></artwork>
            </figure>

            <t>A single STORE request stores data of a number of kinds to a
            single resource location. The contents of the structure are:
              <list style="hanging">
                <t></t><t hangText="resource "></t><t>The resource to store at.</t>

                <t></t><t hangText="kind_data "></t><t>A series of elements, one for
                each kind of data to be stored.</t>
              </list>
            </t>
              
            <t>Each StoreKindData element represents the data to be stored
            for a single kind-id. The contents of the element are:
	    <list style="hanging">
                <t></t><t hangText="kind "></t><t>The kind-id. Implementations SHOULD
                reject requests corresponding to unknown kinds unless
                specifically configured otherwise.</t>

                <t></t><t hangText="data_model "></t><t>The data model of the
                data. The kind defines what this has to be so this is redundant
                in the case where the software interpreting the messages
                understands the kind. </t>

                <t></t><t hangText="generation "></t><t>The expected current state of the
                generation counter (approximately the number of times this
                object has been written, see below for details).</t>

                <t></t><t hangText="values "></t><t>The value or values to be stored. This
                may contain one or more stored_data values depending on the
                data model associated with each kind.</t>
              </list>
            </t>

              
            <t>The responsible peer MUST perform the following checks:</t>

            <t><list style="symbols">
                <t>The kind-id is known.</t>

                <t>The signature over the message is valid or (depending on
                overlay policy) no signature is required.</t>

                <t>The signatures over each individual data element (if any)
                are valid.</t>

                <t>Each element is signed by a credential which is authorized
                to write this kind at this resource-id</t>

                <t>If the generation-counter is non-zero, it must equal the
                current value of the generation-counter for this kind. This
                feature allows the generation counter to be used in a way
                similar to the HTTP Etag feature.</t>

                <t>The storage time values are greater than that of any value
                which would be replaced by this STORE. [[OPEN ISSUE: do peers
                need to save the storage time of REMOVEs to prevent
                reinsertion?]]</t>
              </list></t>

            <t>If all these checks succeed, the peer MUST attempt to store the
            data values. If the store succeeds and the data is changed, then
            the peer must increase the generation counter by at least one. If
            there are multiple stored values in a single store_kind_data, it
            is permissible for the peer to increase the generation counter by
            only 1 for the entire kind-id, or by 1 or more than one for each
            value.</t>

	    <t>
	      The properties of stores for each data model are as follows:
	      <list style="hanging">
		<t></t><t hangText="Single-value:"></t><t>
		A store of a new single-value element creates the element
		if it does not exist and overwrites any existing value.
		with the new value.</t>
		<t></t><t hangText="Array:"></t><t>A store of an array entry replaces
		(or inserts) the given value at the location specified
		by the index. Because arrays are sparse, a store 
		past the end of the array extends it with nonexistent
		values (exists=False) as required.
		A store at index -1, places the new value is placed at
		the end of the array regardless of the length of the
		the array.
		</t>
		<t></t><t hangText="Dictionary:"></t><t>
		A store of a dictionary entry replaces (or inserts) the given
		value at the location specified by the dictionry key.
		</t>
	      </list>
	    </t>
	    <t>
	      The following figure shows the relationship between these
	      structures for an example store which stores the following
              values at resource "1234"
	    </t>
	    <t>
	      <list style="symbols">
		<t>The value "abc" in the single value slot for kind X</t>
		<t>The value "foo" at index 0 in the array for kind Y</t>
		<t>The value "bar" at index 1 in the array for kind Y</t>
	      </list>
	    </t>
		
            <figure>
              <artwork><![CDATA[
                                  StoreQ
                              resource=1234
                                 /      \
                                /        \
                    StoreKindData        StoreKindData
                       kind=X               kind=Y
                 model=Single-Value       model=Array
                         |                    /\
                         |                   /  \
                     StoredData             /    \
                         |                 /      \
                         |           StoredData  StoredData
                  StoredDataValue        |           |
                   value="abc"           |           |
                                         |           |
                                StoredDataValue  StoredDataValue
                                      index=0      index=1
                                   value="foo"    value="bar"
	      ]]>
	    </artwork>
	    </figure>

          </section>
	  
          <section title="Response Definition">
            <t>In response to a successful STORE request the peer MUST return
            a STORE_A message containing a series of StoreKindResponse
            elements containing the current value of the generation counter
            for each kind-id, as well as a list of the peers where the data
            was replicated.</t>

            <figure>
              <!--begin-pdu-->
              <artwork><![CDATA[
      struct {
        KindId                  kind;
        uint64                  generation_counter;
        PeerId                  replicas<0..2^16-1>;
      } StoreKindResponse;


      struct {
        StoreKindResponse       kind_responses<0..2^16-1>;
      } StoreA;

              ]]></artwork>
            </figure>

            <t>The contents of each StoreKindResponse are:</t>

            <t><list style="hanging">
                <t></t><t hangText="kind "></t><t>The kind-id being represented.</t>

                <t></t><t hangText="generation "></t><t>The current value of the generation
                counter for that kind-id.</t>

                <t></t><t hangText="replicas "></t><t>The list of other peers at which the
                data was/will-be replicated. In DHTs and applications where
                the responsible peer is intended to store redundant copies,
                this allows the storing peer to independently verify that the
                replicas were in fact stored by doing its own FETCH.</t>
              </list></t>

            <t>The response itself is just StoreKindResponse values
            packed end-to-end.</t>

            <t>
	      If any of the generation counters in the request precede
	      the corresponding stored generation counter, then the 
	      peer MUST fail the entire request and respond with a 412
	      error. The error_info in the ErrorResponse MUST be a
	      StoreA response containing the correct generation counter
	      for each kind and empty replicas lists.
	      [[TODO: The
            generation counter may need more thinking for uniqueness.]]</t>
          </section>

        </section>
        <section title="FETCH">
          <t>
            The FETCH request retrieves one or more data elements stored at a
            given resource-id. A single FETCH request can retrieve multiple differnt kinds. 
          </t>

          <section title="Request Definition">
            <figure>
              <!--begin-pdu-->
              <artwork><![CDATA[
      struct {
        KindId                  kind;
        DataModel               model;
        uint64                  generation;
        uint16                  length;
        
        select (model) {
          case single_value: ;    /* Empty */

          case array:
               int32            first;
               int32            last;
          
          case dictionary:
               DictionaryKey    keys<0..2^16-1>;

          /* This structure may be extended */

        } model_specifier;
      } StoredDataSpecifier;

      struct {
        ResourceId              resource;
        StoredDataSpecifier     specifiers<0..2^16-1>;
      } FetchQ;

              ]]></artwork>
            </figure>
            
            <t>The contents of the FETCH requests are as follows:</t>

            <t><list style="hanging">
                <t></t><t hangText="resource "></t><t>
                  The resource ID to fetch from.
                </t>

                <t></t><t hangText="specifiers "></t><t>
                  A sequence of StoredDataSpecifier values, each
                  specifying some of the data values to retrieve.
                </t>
              </list></t>

            <t>
              Each StoredDataSpecifier specifies a single kind of
              data to retrieve and (if appropriate) the subset of
	      values that are to be retrieved. The contents of the
	      StoredDataSpecifier structure are as follows:
            </t>
            
            <t><list style="hanging">
                <t></t><t hangText="kind "></t><t>The kind-id of the data being fetched.
                Implementations SHOULD reject requests corresponding to
                unknown kinds unless specifically configured otherwise.</t>

                <t></t><t hangText="model "></t><t>The data model of the data.</t>

                <t></t><t hangText="generation "></t><t>The last generation counter that
                the requesting peer saw. This may be used to avoid unnecessary
                fetches or it may be set to zero. </t>

                <t></t><t hangText="length "></t><t>The length of the rest of the structure,
                thus allowing extensibility.</t>

                <t></t><t hangText="model_specifier "></t><t>A reference to the data value being
                requested within the data model specified for the kind. For instance,
                if the data model is "array", it might specify some subset of the values.
                </t>
              </list>
            </t>
              
            <t>The model_specifier is as follows:</t>

            <t>
              <list style="symbols">
                <t>If the data is of data model single value, the specifier is
                empty.</t>

                <t>If the data is of data model array, the specifier contains
                two integers. The first integer is the beginning of the range
                and the second is the end of the range. 0 is used to indicate
                the first element and -1 is used to indicate the final
                element. The beginning of the range MUST be earlier in the
                array then the end.</t>

                <t>If the data is of data model dictionary then the specifier
                contains a list of the dictionary keys being requested. If no
                keys are specified, than this is a wildcard fetch and all
                key-value pairs are returned. [[TODO: We really need a way to
                return only the keys. We'll need to modify this.]]</t>
              </list>

            </t>
            <t>The generation-counter is used to indicate the requester's
            expected state of the storing peer. If the generation-counter in
            the request matches the stored counter, then the storing peer
            returns a resone with no StoredData values rather than the stored data.
            </t>

            <t>Note that because the certificate for a user is typically
            stored at the same location as any data stored for that user, a
            requesting peer which does not already have the user's certificate
            should request the certificate in the FETCH as an
            optimization.</t>
          </section>
          
          <section title="Response Definition">
            <t>The response to a successful FETCH request is a FETCH_A message
            containing the data requested by the requester.</t>

            <figure>
              <!--begin-pdu-->
              <artwork><![CDATA[
       struct {
         KindId                 kind;
         uint64                 generation;
         StoredData             values<0..2^32-1>;
       } FetchKindResponse;

       struct {
         FetchKindResponse      kind_responses<0..2^32-1>;
       } FetchA;

              ]]></artwork>
            </figure>
	    
	    <t>
	      The FetchA structure contains a series of FetchKindResponse
	      structures. There MUST be one FetchKindResponse element for each kind-id in
            the request. </t>
	    
	    
	    <t>
	      The contents of the FetchKindResponse structure are as
	      follows:
	    </t>
	    
	    <t>
	      <list style="hanging">
		<t></t><t hangText="kind "> </t><t>the kind that this structure
		is for.</t>
		<t></t><t hangText="generation "></t><t>the generation counter
		for this kind.</t>
		<t></t><t hangText="values "></t><t>the relevant values. 
		If the generation counter in the request matches the
		generation-counter in the stored data, then no StoredData
		values are returned. Otherwise, all relevant data values
		MUST be returned. A nonexistent value is represented 
		with "exists" set to False.
	      </t>
	      </list>
	    </t>
          </section>
        </section>

        <section title="REMOVE">
          <t>The REMOVE request is used to remove a stored element or elements
          from the storing peer. Any successful remove of an
          existing element for a given kind MUST increment the generation
          counter by at least one.</t>
          
            <figure>
              <!--begin-pdu-->
              <artwork><![CDATA[
      struct {
        ResourceId              resource;
        StoredDataSpecifier     specifiers<0..2^16-1>;
      } RemoveQ;

      ]]>
              </artwork>
            </figure>

          <t>A remove-request has exactly the same syntax as a FETCH request
          except that each entry represents a set of values to be removed
          rather than returned. The same kind-id MUST NOT be used twice in a
          given remove-request. Each specifier is then processed in
          turn. These operations MUST be atomic. If any operation fails, the
          state MUST be rolled back to before the request was received.</t>

          <t>Before processing the REMOVE request, the peer MUST perform the
          following checks.</t>

          <t><list style="symbols">
              <t>The kind-id is known.</t>

              <t>The signature over the message is valid or (depending on
              overlay policy) no signature is required.</t>

              <t>The signer of the message has permissions which permit him to
              remove this kind of data. Although each kind defines its own access
	      control requirements, in general only the original signer of the
	      data should be allowed to remove it.</t>

              <t>If the generation-counter is non-zero, it must equal the
              current value of the generation-counter for this kind. This
              feature allows the generation counter to be used in a way
              similar to the HTTP Etag feature.</t>
            </list></t>

          <t>Assuming that the request is permitted, the operations proceed as
          follows.</t>

          <section title="Single Value">
            <t>A REMOVE of a single value element simple causes it not to
            exist. If no such element exists, then this simply is a silent
            success.</t>
          </section>

          <section title="Array">
            <t>A REMOVE of an array element (or element range) replaces those
            elements with null elements. Note that this does not cause the
            array to be packed. An array which contains ["A", "B", "C"] and
            then has element 0 removed produces an array containing [NA, "B",
            "C"]. Note, however, that the removal of the final element of the
            array shortens the array, so in the above case, the removal of
            element 2 makes the array ["A", "B"].</t>
          </section>

          <section title="Dictionary">
            <t>A REMOVE of a dictionary element (or elements) replaces those
            elements with null elements. If no such elements exist, then this
            is a silent success.</t>
          </section>

          <section title="Response Definition">
            <t>The response to a successful REMOVE simply contains a list of
            the new generation counters for each kind-id, using the same
            syntax as the response to a STORE request. Note that if the
            generation counter does not change, that means that the requested
            items did not exist. However, if the generation counter does
            change, that does not mean that the items existed.</t>
          </section>

            <figure>
              <!--begin-pdu-->
              <artwork><![CDATA[
      struct {
        StoreKindResponse          kind_responses<0..2^16-1>;
      } RemoveA;
      ]]>
              </artwork>
            </figure>
        </section>
        <section title="FIND">
          <t>The FIND request can be used to explore the DHT Instance. A FIND request for a
          resource-id R and a kind-id T retrieves the resource-id (if any) of
          the resource of kind T known to the target peer which is closes to
          R. This method can be used to walk the DHT Instance by interactively fetching
          R_n+1=nearest(1 + R_n).</t>

          <section title="Request Definition">
            <t>The FIND_Q message contains a series of resource-IDs and
            kind-ids identifying the resource the peer is interested in.</t>

            <figure>
              <!--begin-pdu-->
              <artwork><![CDATA[
   struct {
     ResourceID                 resource;
     KindId                     kinds<0..255>;
   } FindQ;

              ]]></artwork>
            </figure>

            <!-- find-request = resource-id 1*type-id -->
          </section>

          <t>The request contains a list of kind-ids which the FIND is for, as
          indicated below:

	  <list style="hanging">
              <t></t><t hangText="resource "></t><t>The desired resource-id</t>

              <t></t><t hangText="kinds "></t><t>The desired kind-ids. Each value MUST only
              appear once.</t>
            </list></t>

          <section title="Response Definition">
            <t>A response to a successful FIND request is a FIND_A message
            containing the closest resource-ID for each kind specified in the
            request.</t>

            <figure>
              <!--begin-pdu-->

              <artwork><![CDATA[
  struct {
    KindId                      kind;
    ResourceID                  closest;
  } FindKindData;

  struct {
    FindKindData                results<0..2^16-1>;
  } FindA;

              ]]></artwork>
            </figure>

            <t>If the processing peer is not responsible for the specified
            resource-id, it SHOULD return a 404 error.</t>

<!-- EKR removed. It is confusing here.

            <t>When each kind is defined, it can indicate if the kind is not
            allowed to be used in a FIND request. This would be done to help
            achieve some types of security properties for the data stored in
            that kind.</t>
-->
            <t>For each kind-id in the request the response MUST contain a
            FindKindData indicating the closest resource-id for that
            kind-id unless the kind is not allowed to be used with FIND in
            which case a find_kind_data for that kind_id MUST NOT be included
            in the response. If a kind-id is not known, then the corresponding
            resource-id MUST be 0. Note that different kind-ids may have
            different closest resource-ids.</t>

            <t>The response is simply a series of FindKindData elements, one
            per kind, concatenated end-to-end. The contents of each element
            are:</t>

            <t><list style="hanging">
                <t></t><t hangText="kind "></t><t>The kind-id.</t>

                <t></t><t hangText="closest "></t><t>The closest resource ID to the
                specified resource ID. This is 0 if no resource ID is
                known.</t>
              </list></t>

            <t>Note that the response does not contain the contents of the
            data stored at these resource-ids. If the requester wants this, it
            must retrieve it using FETCH.</t>
          </section>
           <section title="Defining New Kinds">
             <t>
               A new kind MUST define:
             </t>
               <t><list style="symbols">
                  <t>The meaning of the data to be stored.</t>
                  <t>The kind-id.</t>
                  <t>The data model (single value, array,
                  dictionary, etc.)</t>
                  <t>Access control rules for indicating what credentials
                  are allowed to read and write that kind-id at a given
                  location.</t>

                  <t>The minimum amounts of data that a conformant
                  implementation MUST be willing to store.</t>
               </list>
               </t>

               <t>While each kind MUST define what data model is used for its data,
               that does not mean that it must define new data models. Where
               practical, kinds SHOULD use the built-in data models. However, they MAY
               define any new required data models. The intention is that the basic
               data model set be sufficient for most applications/usages.</t>

               <t><list style="hanging">
                  <t></t><t hangText="Note:">New usages MAY reuse existing kind-ids. New
                  kind-ids only need to be defined where different data is stored or
                  different behavior is required.</t>
               </list>
               </t>
           </section>

        </section>

      </section>
    </section>

      <section anchor="sec-connect-ice" title="ICE and Connection Formation">
      <t>At numerous times during the operation of RELOAD, a node will need to
      establish a connection to another node. This may be for the purposes of
      building finger tables when the node joins the P2P network, or when the
      node learns of a new neighbor through an UPDATE and needs to establish a
      connection to that neighbor.</t>

      <t>In addition, a node may need to connect to another node for the
      purposes of an application connection. In the case of SIP, when a node
      has looked up the target AOR in the DHT Instance, it will obtain a Peer-ID that
      identifies that peer. The next step will be to establish a "direct"
      connection for the purposes of performing SIP signaling.</t>

      <t>In both of these cases, the node starts with a destination Peer-ID
      and its objective is to create a connection (ideally using TCP, but
      falling back to UDP when it is not available) to the node with that
      given Node-ID. The establishment of this connection is done using the
      CONNECT request in conjunction with ICE. It is assumed that the reader
      has familiarity with ICE.</t>

      <t>RELOAD implementations MUST implement full ICE. Because RELOAD always
      tries to use TCP and then UDP as a fallback, there will be multiple
      candidates of the same IP version, which requires full ICE.</t>

      <section title="Overview">
        <t>To utilize ICE, the CONNECT method provides a basic offer/answer
        operation that exchanges a set of candidates for a single "stream". In
        this case, the "stream" refers not to RTP or other types of media, but
        rather to a connection for RELOAD itself or for SIP signaling. The
        CONNECT request contains the candidates for this stream, and the
        CONNECT response contains the corresponding answer with candidates for
        that stream. Though CONNECT provides an offer/answer exchange, it does
        not actually carry or utilize Session Description Protocol (SDP)
        messages. Rather, it carries the raw ICE parameters required for ICE
        operation, and the ICE spec is utilized as if these parameters had
        actually been used in an SDP offer or answer. In essence, ICE is
        utilized by mapping the CONNECT parameters into an SDP for the
        purposes of following the details of ICE itself. That avoids the need
        for RELOAD to respecify ICE, yet allows it to operate without the
        baggage that SDP would bring.</t>

        <t>In addition, RELOAD only allows for a single offer/answer exchange.
        Unlike the usage of ICE within SIP, there is never a need to send a
        subsequent offer to update the default candidates to match the ones
        selected by ICE.</t>

        <t>RELOAD and SIP always run over TLS for TCP connections and DTLS
        <xref target="RFC4347"></xref> for UDP "connections". Consequently,
        once ICE processing has completed, both agents will begin TLS and DTLS
        procedures to establish a secure link. Its important to note that, had
        a TURN server been utilized for the TCP or UDP stream, the TURN server
        will transparently relay the TLS messaging and the encrypted TLS
        content, and thus will not have access to the contents of the
        connection once it is established. Any attack by the TURN server to
        insert itself as a man-in-the-middle are thwarted by the usage of the
        fingerprint mechanism of RFC 4572 <xref target="RFC4572"></xref>,
        which will reveal that the TLS and DTLS certificates do not match the
        ones used to sign the RELOAD messages.</t>

	<!-- [TODO: EKR: remove fingerprint? Does this make sense? --> 

        <t>An agent follows the ICE specification as described in <xref
        target="I-D.ietf-mmusic-ice"></xref> and <xref
        target="I-D.ietf-mmusic-ice-tcp"></xref> with the changes and
        additional procedures described in the subsections below.</t>
      </section>

      <section anchor="sec-collect" title="Collecting STUN Servers">
        <t>ICE relies on the node having one or more STUN servers to use. In
        conventional ICE, it is assumed that nodes are configured with one or
        more STUN servers through some out-of-band mechanism. This is still
        possible in RELOAD but RELOAD also learns STUN servers as it connects
        to other peers. Because all RELOAD peers implement ICE and use STUN
        keepalives, every peer is a STUN server<xref
        target="I-D.ietf-behave-rfc3489bis"></xref>. Accordingly, any peer you
        know about will be willing to be a STUN server for you -- though of
        course it may be behind a NAT.</t>

        <t>A peer on a well-provisioned wide-area overlay will be configured
        with one or more bootstrap peers. These peers make an initial list of
        STUN servers. However, as the peer forms connections with additional
        peers, it builds more peers it can use as STUN servers.</t>

        <t>Because complicated NAT topologies are possible, a peer may need
        more than one STUN server. Specifically, a peer that is behind a
        single NAT will typically observe only two IP addresses in its STUN
        checks: its local address and its server reflexive address from a STUN
        server outside its NAT. However, if there are more NATs involved, it
        may discover that it learns additional server reflexive addresses
        (which vary based on where in the topology the STUN server is). To
        maximize the chance of achieving a direct connection, A peer SHOULD
        group other peers by the peer-reflexive addresses it discovers through
        them. It SHOULD then select one peer from each group to use as a STUN
        server for future connections.</t>

        <t>Only peers to which the peer currently has connections may be used.
        If the connection to that host is lost, it MUST be removed from the
        list of stun servers and a new server from the same group SHOULD be
        selected.</t>

        <t>OPEN ISSUE: should the peer try to keep at least one peer in each
        group, even if it has no other reason for the connection? Need to
        specify when to stop adding new groups if the peer is behind a really
        bad NAT.</t>

        <t>OPEN ISSUE: RELOAD-01 had a Peer-Info structure that allowed peers
        to exchange information such as a "default" IP-port pair in UPDATEs.
        This structure could be expanded to include the candidate list for a
        peer, thus allowing ICE negotiation to begin or even direct
        communication before a CONNECT request has been received. (The
        candidate pairs for the P2P port are fixed because the same source
        port is used for all connections.) However, because this would require
        significant changes to the ICE algorithm, we have not introduced such
        an extension at this point.</t>
      </section>

      <section anchor="sec-gather" title="Gathering Candidates">
        <t>When a node wishes to establish a connection for the purposes of
        RELOAD signaling or SIP signaling (or any other application protocol
        for that matter), it follows the process of gathering candidates as
        described in Section 4 of ICE <xref
        target="I-D.ietf-mmusic-ice"></xref>. RELOAD utilizes a single
        component, as does SIP. Consequently, gathering for these "streams"
        requires a single component.</t>

        <t>An agent MUST implement ICE-tcp <xref
        target="I-D.ietf-mmusic-ice"></xref>, and MUST gather at least one UDP
        and one TCP host candidate for RELOAD and for SIP.</t>

        <t>The ICE specification assumes that an ICE agent is configured with,
        or somehow knows of, TURN and STUN servers. RELOAD provides a way for
        an agent to learn these by querying the ring, as described in <xref
        target="sec-collect"></xref> 
         [XREF] <!-- EKR: this was TURN. Remove? -->.</t>

        <t>The agent SHOULD prioritize its TCP-based candidates over its
        UDP-based candidates in the prioritization described in Section 4.1.2
        of ICE <xref target="I-D.ietf-mmusic-ice"></xref>.</t>

        <t>The default candidate selection described in Section 4.1.3 of ICE
        is ignored; defaults are not signaled or utilized by RELOAD.</t>
      </section>

      <section title="Encoding the CONNECT Message">
        <t>Section 4.3 of ICE describes procedures for encoding the SDP.
        Instead of actually encoding an SDP, the candidate information (IP
        address and port and transport protocol, priority, foundation,
        component ID, type and related address) is carried within the
        attributes of the CONNECT request or its response. Similarly, the
        username fragment and password are carried in the CONNECT message or
        its response. <xref target="sec-connect-details"></xref> describes the
        detailed attribute encoding for CONNECT. The CONNECT request and its
        response do not contain any default candidates or the ice-lite
        attribute, as these features of ICE are not used by RELOAD. The
        CONNECT request and its response also contain a application
        attribute, with a value of SIP or RELOAD, which indicates what
        protocol is to be run over the connection. The RELOAD CONNECT request
        MUST only be utilized to set up connections for application protocols
        that can be multiplexed with STUN and RELOAD itself.</t>

        <t>Since the CONNECT request contains the candidate information and
        short term credentials, it is considered as an offer for a single
        media stream that happens to be encoded in a format different than
        SDP, but is otherwise considered a valid offer for the purposes of
        following the ICE specification. Similarly, the CONNECT response is
        considered a valid answer for the purposes of following the ICE
        specification.</t>

        <t>Since all messages with RELOAD are secured between nodes, the node
        MUST implement the fingerprint attribute of RFC 4572 <xref
        target="RFC4572"></xref>, and encode it into the CONNECT request and
        response as described in <xref target="sec-connect-details"></xref>.
        This fingerprint will be matched with the certificates utilized to
        authenticate the RELOAD CONNECT request and its response.</t>

        <t>Similarly, the node MUST implement the active, passive, and actpass
        attributes from RFC 4145 <xref target="RFC4145"></xref>. However, here
        they refer strictly to the role of active or passive for the purposes
        of TLS handshaking. The TCP connection directions are signaled as part
        of the ICE candidate attribute.</t>
      </section>

      <section title="Verifying ICE Support">
        <t>An agent MUST skip the verification procedures in Section 5.1 and
        6.1 of ICE. Since RELOAD requires full ICE from all agents, this check
        is not required.</t>
      </section>

      <section title="Role Determination">
        <t>The roles of controlling and controlled as described in Section 5.2
        of ICE are still utilized with RELOAD. However, the offerer (the
        entity sending the CONNECT request) will always be controlling, and
        the answerer (the entity sending the CONNECT response) will always be
        controlled. The connectivity checks MUST still contain the
        ICE-CONTROLLED and ICE-CONTROLLING attributes, however, even though
        the role reversal capability for which they are defined will never be
        needed with RELOAD. This is to allow for a common codebase between ICE
        for RELOAD and ICE for SDP.</t>
      </section>

      <section title="Connectivity Checks">
        <t>The processes of forming check lists in Section 5.7 of ICE,
        scheduling checks in Section 5.8, and checking connectivity checks in
        Section 7 are used with RELOAD without change.</t>
      </section>

      <section title="Concluding ICE">
        <t>The controlling agent MUST utilize regular nomination. This is to
        ensure consistent state on the final selected pairs without the need
        for an updated offer, as RELOAD does not generate additional
        offer/answer exchanges.</t>

        <t>The procedures in Section 8 of ICE are followed to conclude ICE,
        with the following exceptions:</t>

        <t><list style="symbols">
            <t>The controlling agent MUST NOT attempt to send an updated offer
            once the state of its single media stream reaches Completed.</t>

            <t>Once the state of ICE reaches Completed, the agent can
            immediately free all unused candidates. This is because RELOAD
            does not have the concept of forking, and thus the three second
            delay in Section 8.3 of ICE does not apply.</t>
          </list></t>
      </section>

      <section title="Subsequent Offers and Answers">
        <t>An agent MUST NOT send a subsequent offer or answer. Thus, the
        procedures in Section 9 of ICE MUST be ignored.</t>
      </section>

      <section title="Media Keepalives">
        <t>STUN MUST be utilized for the keepalives described in Section 10 of
        ICE.</t>
      </section>

      <section title="Sending Media">
        <t>The procedures of Section 11 apply to RELOAD as well. However, in
        this case, the "media" takes the form of application layer protocols
        (RELOAD or SIP for example) over TLS or DTLS. Consequently, once ICE
        processing completes, the agent will begin TLS or DTLS procedures to
        establish a secure connection. The fingerprint from the CONNECT
        request and its response are used as described in RFC 4572 <xref
        target="RFC4572"></xref>, to ensure that another node in the P2P
        network, acting as a TURN server, has not inserted itself as a
        man-in-the-middle. Once the TLS or DTLS signaling is complete, the
        application protocol is free to use the connection.</t>

        <t>The concept of a previous selected pair for a component does not
        apply to RELOAD, since ICE restarts are not possible with RELOAD.</t>
      </section>

      <section title="Receiving Media">
        <t>An agent MUST be prepared to receive packets for the application
        protocol (TLS or DTLS carrying RELOAD, SIP or anything else) at any
        time. The jitter and RTP considerations in Section 11 of ICE do not
        apply to RELOAD or SIP.</t>
      </section>
    </section>
    <section title="Certificate Store Usage">
      <t>The Certificate Store usage allows a peer to store its certificate
      in the overlay, thus avoiding the need to send a certificate in each
      message - a reference may be sent instead.</t>

      <t>A user/peer MUST store its certificate at resource-ids derived from
      two Unhashed-IDs:</t>

      <t><list style="symbols">
         <t>The user names in the certificate.</t>

         <t>The Peer-IDs in the certificate.</t>
      </list></t>

      <t>Note that in the second case the certificate is not stored at the
      peer's Peer-ID but rather at a hash of the peer's Peer-ID. The
      intention here (as is common throughout RELOAD) is to avoid making a
      peer responsible for its own data.</t>

      <t>A peer MUST ensure that the user's certificates are stored in the
      DHT Instance when joining and redo the check about every 24 hours after that.
      Certificate data should be stored with an expiry time of 60 days. When
      a client is checking the existence of data, if the expiry is less than
      30 days, it should be refreshed to have an expiry of 60 days. The
      certificate information is frequently used for many operations, and
      peers should cache it for 8 hours.</t>

      <t><list style="hanging">
         <t></t><t hangText="Kind IDs">This usage defines the CERTIFICATE kind-id
         to store a peer or user's certificate.</t>

         <t></t><t hangText="Data Model">The data model for CERTIFICATE data is
         array.</t>

         <t></t><t hangText="Access Control">The CERTIFICATE MUST contain a
         Peer-ID or user name which, when hashed, maps to the resource-id at
         which the value is being stored.</t>

         <t></t><t hangText="Data Sizes">[TODO: EKR: Maximum size...]</t>
      </list></t>
    </section>
      <section title="SIP Usage">

<!-- EKR: Fodder from previous P2PSIP overview 
          <t>All SIP URIs for a given overlay MUST be constructed so that they
          terminate in the domain name of the overlay. For instance, if the
          overlay name is "example.com", then all AORs must be of the form
          {sip,sips}:username@example.com. Accordingly, to dereference a URI,
          a P2PSIP implementation MUST check to see if the domain matches an
          overlay which it is a member of. If so, it uses the following
          procedures. Otherwise, it MUST follow <xref target="RFC3263"></xref>
          procedures. Note that unless the P2PSIP overlay provides some kind
          of gateway to ordinary SIP (e.g., a publicly accessible SIP server)
          this is likely to be only partially successful, since, for instance,
          the callee may not be able to call back.</t>

          <section title="SIP Location">
             <t>A peer acting as a SIP UA stores their registration information
             in the DHT by storing either another URI (for retargeting) or a
             destination lists to reach them at a Resource-ID in the DHT formed
             from the user's SIP AOR. When another peer wishes to find a peer
             that is registered for a SIP URI, the lookup of the user's name is
             done by taking the user's SIP Address of Record (AOR) and using it
             as the Unhashed-ID that is hashed to get a Resource-ID. When the
             Unhashed-ID is dereferenced, the result is a set of values. Each
             value is either another SIP URI or a destination list. If the
             value is a SIP URI, the calling peer looks up that URI and
             continues the process until it gets a destination list.</t>

             <t>If the value is a destination list, then it is used to reach a
             peer that represents a SIP UA registered for that AOR. Typically
             this destination list will have just one entry but in the case of
             peers or clients that can not be directly reached (for instance
             via a strict NAT or firewall), a destination list with more than
             one entry may need to be used.</t>

             <t>The Unhashed-ID for this usage is a user's SIP AOR, such as
             "sip:alice@example.com". This allows the set to store many values
             in a dictionary structure. The authorization policy is that STORE
             requests are only allowed if the user name in the signing
             certificate, when turned into a SIP URL and hashed, matches the
             Resource-ID. This policy ensures that only a user with the
             certificate with the user name "alice@example.com" can write to
             the Resource-ID that will be used to look up calls to
             "sip:alice@example.com".</t>

             <t>[[Open Issue: Should the Unhashed-ID be
             "sip:alice@example.com", "alice@example.com", or a string that
             includes the code point defined for the kind? The issue here is
             determining whether different usages that store data at a
             Unhashed-ID that is primarily formed from "alice@example.com"
             should hash to the same Resource-ID as the SIP Usage. For example,
             if a buddy list had a Unhashed-ID that was roughly the same, would
             we want the buddy list information to end up on the same peers
             that stored the SIP location data or on different peers?]]</t>
           </section>

-->

        <t>
	  The SIP usage allows a RELOAD overlay to be used as a distributed
	  SIP registrar/proxy network. This entails three primary operations:
	</t>
	<t>
	  <list style="symbols">
	    <t>Registering one's own AOR with the overlay.</t>
	    <t>Looking up a given AOR in the overlay.</t>
	    <t>Forming a direct connection to a given peer.</t>
	  </list>
	</t>
	<section title="Registering AORs">
	  <t>
	    In ordinary SIP, a UA registers its AOR and location with
	    a registrar. In RELOAD, this registrar function is
	    provided by the overlay as a whole. To register its
	    location, a RELOAD peer stores a SipRegistration 
	    structure under its own AOR. This uses the
	    SIP-REGISTRATION kind-id, which is formally defined
	    in <xref target="sec.sip-reg-kind"/>.
	  </t>
	  <t>
	    As a simple example,
	    if Alice's
	    AOR were "sip:alice@dht.example.com" and her Peer-ID
	    were "1234", she might store
	    the mapping "sip:alice@example.org -> 1234". This
	    would tell anyone who wanted to call Alice to contact
	    node "1234".
	  </t>
	  <t>
	    RELOAD peers are allowed to store two kinds of SIP mappings:
	  </t>
	  <t>
	    <list style="symbols">
	      <t>
		From AORs to destination lists (a single Peer-ID is just
		a trivial destination list.
	      </t>
	      <t>
		From AORs to other AORs. 
	      </t>
	    </list>
	  </t>
	  <t>
	    The meaning of the first kind of mapping is "in order to contact
	    me, form a connection with this peer." The meaning of the
	    second kind of mapping is "in order to contact me, 
	    dereference this AOR". This allows for forwarding. For instance,
	    if Alice wants calls to her to be forwarded to her secretary,
	    Sam, she might insert the following mapping 
	    "sip:alice@dht.example.org -> sip:sam@dht.example.org". 
	  </t>
	  <t>
	    The contents of a SipRegistration structure are as follows:
	  </t>
          <figure>
            <!--begin-pdu-->

            <artwork><![CDATA[

       enum {sip_registration_uri (1), sip_registration_route (2), 
          (255)} SipRegistrationType;
      
       select (SipRegistration.type) {
         case sip_registration_uri:
           opaque               uri<0..2^16-1>;

         case sip_registration_route:
           opaque               contact_prefs<0..2^16-1>;
           Destination          destination_list<0..2^16-1>;

         /* This type can be extended */

       } SipRegistrationData;

       struct {
          SipRegistrationType   type;
          uint16                length;
          SipRegistrationData   data;          
      } SipRegistration;


                ]]></artwork>
          </figure>

          <t>
            The contents of the SipRegistration PDU are:
          </t>
	  <t>
          <list style="hanging">
            <t></t><t hangText="type "></t><t>the type of the registration</t>
            <t></t><t hangText="length "></t><t>the length of the rest of the PDU</t>
            <t></t><t hangText="data "></t><t>the registration data</t>
          </list>
	  </t>
	  <t>
	  <list style="symbols">
          <t>
            If the registration is of type "sip_registration_uri", then the
            contents are an opaque string containing the URI.
          </t>
          <t>
            If the registration is of type "sip_registration_route",
            then the contents are an opaque string containing the callee's
            contact preferences and a destination list for the peer.
          </t>
	  </list>
	  </t>
	  <t>
	    RELOAD explicitly supports multiple registrations for a single
	    AOR. The registrations are stored in a Dictionary with the
	    dictionary keys being Peer-IDs. Consider, for instance, the
	    case where Alice has two peers:
	  </t>
	  <t>
	    <list style="symbols">
	      <t>her desk phone (1234)</t>
	      <t>her cell phone (5678)</t>
	    </list>
	  </t>
	  <t>
	    Alice might store the following in the overlay at
	    resource "sip:alice@dht.example.com".
	    <list style="symbols">
	      <t>A SipRegistration of type "sip_registration_route"
	      with dictionary key "1234" and value "1234".</t>
	      <t>A SipRegistration of type "sip_registration_route"
	      with dictionary key "5678" and value "5678".</t>
	    </list>
	  </t>
	  <t>
	    Note that this structure explicitly allows one Peer-ID to
	    forward to another Peer-ID. For instance, Alice could
	    set calls to her desk phone to ring at her cell phone.
	    It's not clear that this is useful in this case, but
	    may be useful if Alice has two AORs.
	    [TODO: EKR: ??? ]
	  </t>
	  <t>
	    In order to prevent hijacking, registrations are subject
	    to access control rules. Before a STORE is permitted,
	    the storing peer MUST check that:
	  </t>
	  <t>
	    <list style="symbols">
	      <t>
		The certificate contains a username that is a
		SIP AOR that hashes to the resource-id being stored at.
	      </t>
	      <t>
		The certificate contains a Peer-ID that is the
		same as the dictionary key being stored at.
	      </t>
	    </list>
	  </t>
	  <t>
	    Note that these rules permit Alice to forward calls to Bob
	    without his permission. However, they do not permit Alice
	    to forward Bob's calls to her.
	  </t>
        </section>
	<section title="Looking up an AOR">
	  <t>
	    When a RELOAD user wishes to call another user, starting
	    with a non-GRUU AOR, he follows the following procedure.
	    (GRUUs are discussed in [XREF]).
	  </t>
	  <t>
	    <list style="numbers">
	      <t>
		Check to see if the domain part of the AOR matches
		the domain name of an overlay of which he is a
		member. If not, then this is an external AOR,
		and he MUST do one of the following:
		
		<list style="symbols">
		  <t>Fail the call.</t>
		  <t>Use ordinary SIP procedures.</t>
		  <t>
		    Attempt to become a member of the overlay indicated
		    by the domain part (only possible if the enrollment
		    procedure defined in [XREF] indicates that this
		    is a RELOAD overlay.)
		  </t>
		</list>
	      </t>
	      <t>
		Perform a FETCH for kind SIP-REGISTRATION at the
		resource-id corresponding to the AOR. This FETCH
		SHOULD not indicate any dictionary keys, which
		will result in fetching all the stored values.
	      </t>
	      <t>
		If any of the results of the FETCH are non-GRUU
		AORs, then repeat step 1 for that AOR.
	      </t>
	      <t>
		Once only GRUUs and destination
		lists remain, the peer 
		removes duplicate destination
		lists and GRUUs from the list and forms a SIP
		connection to the appropriate peers as described in
		the following section. If there are also external
		AORs, the peer follows the appropriate procedure
		for contacting them as well.
	      </t>
	    </list>
	  </t>
	</section>
	
	<section title="Forming a Direct Connection">
	  <t>
	    Once the peer has translated the AOR into a set of
	    destination lists, it then uses the overlay to route
	    CONNECT messages to each of those peers. The "application"
	    field MUST be 5160 to indicate SIP. 
	    If
	    certificate-based authentication is in use, the responding peer MUST
	    present a certificate with a Peer-ID matching the terminal entry in
	    the route list.
	    Note that it is possible that the peers already
	    have a RELOAD connection between them. This MUST NOT
	    be used for SIP messages. However, if a SIP connection
	    already exists, that MAY be used.
	    Once the CONNECT
	    succeeds, the peer sends SIP messages over the
	    connection as in normal SIP.
	  </t>
	</section>
	<section title="GRUUs">
          <t>
	    GRUUs do not require storing data in the DHT Instance. Rather, they are
	    constructed by embedding a base64-encoded destination list in the gr
	    URI parameter of the GRUU. The base64 encoding is done with the
	    alphabet specified in table 1 of RFC 4648 with the exception that ~
	    is used in place of =. An example GRUU is
	    "sip:alice@example.com;gr=MDEyMzQ1Njc4OTAxMjM0NTY3ODk~". When a peer
	    needs to route a message to a GRUU in the same P2P network, it
	    simply uses the destination list and connects to that peer.
	  </t>
	  <t>
	    Because a GRUU contains a destination list, it MAY have the
	    same contents as a destination list stored elsewhere in the
	    resource dictionary. 
	  </t>
          <t>
	    Anonymous GRUUs are done in roughly the same way but require
	    either that the enrollment server issue a different Peer-ID for each
	    anonymous GRUU required or that a destination list be used that
	    includes a peer that compresses the destination list to stop the
	    Peer-ID from being revealed.
	  </t>


        </section>
	  
        <section anchor="sec.sip-reg-kind" title="SIP-REGISTRATION Kind Definition">
          <t>The first mapping is provided using the SIP-REGISTRATION
          kind-id:</t>

          <t><list style="hanging">
              <t></t><t hangText="Kind IDs">The Unhashed-ID for the SIP-REGISTRATION
              kind-id is the AOR of the user.
	      The data
              stored is a SipRegistrationData, which can contain either
              another URI or a destination list to the peer which is acting
              for the user.</t>

              <t></t><t hangText="Data Model">The data model for the SIP-REGISTRATION
              kind-id is dictionary. The dictionary key is the Peer-ID of the
              storing peer. This allows each peer (presumably corresponding to
              a single device) to store a single route mapping.</t>

              <t></t><t hangText="Access Control">If certificate-based access control
              is being used, stored data of kind-id SIP-REGISTRATION must be
              signed by a certificate which (1) contains user name matching
              the storing URI used as the Unhashed-ID for the resource-id and
              (2) contains a Peer-ID matching the storing dictionary key.</t>

              <t></t><t hangText="Data Sizes">Peers MUST be prepared to store
              SIP-REGISTRATION values of up to 10 kilobytes and must be
              prepared to store up to 10 values for each user name.</t>
            </list></t>
            
            <t>
              Data stored under the SIP-REGISTRATION kind is of type
              SipRegistration. This comes in two varieties:
              <list style="hanging">
                <t></t><t hangText="sip_registration_uri "></t><t>a URI
                which the user can be reached at.</t>
                <t></t><t hangText="sip_registration_route "></t><t>a
                destination list which can be used to
                reach the user's peer.</t>
              </list>
            </t>
	</section>
	</section>
         <!-- EKR REMOVED

        <section title="SIP Tunnel">
          <t>This usage allows two peers to exchange SIP messages across the
          overlay using the TUNNEL method. TUNNEL is provided as an
          alternative to using CONNECT because it allows a SIP message to be
          sent immediately, without the delay associated with CONNECT. For a
          simple SIP exchange, it may result in fewer messages being sent.</t>

          <t>An implementation SHOULD use CONNECT for a dialog that is
          expected to endure for sufficient time and exchange significant
          numbers of messages. An implementation MAY establish an initial
          dialog using TUNNELing and then migrate it to a direct dialog opened
          with CONNECT once that negotiation is complete.</t>

          <t>As an application of TUNNEL, this usage defines the following
          items:</t>

          <t><list style="symbols">
              <t>For SIP, the application attribute is 5060.</t>

              <t>The application MAY establish any dialog using TUNNEL if it
              expects to replace it once a CONNECT request completes. The
              application SHOULD NOT exchange messages with another SIP UA
              repeatedly using a TUNNEL unless it is unable to complete a
              CONNECT.</t>

              <t>The Replaces header should be used to migrate dialogs
              established via TUNNEL to a direct connection.</t>

              <t>The dialogid is the GRUU of the destination of the
              request.</t>

              <t>By using the GRUU of the destination as the dialogid, the
              receiving peer is able to deliver the message to the appropriate
              process without parsing the SIP message.</t>
            </list></t>

          <t>In constructing the message, the SIP UA forms the message as if
          it were being routed directly to the GRUU of the destination. The
          SIP stack hands the message to RELOAD for delivery. Although the
          message is passed through a sequence of untrusted peers, it is not
          subject to modification by those peers because of the message's
          signature.</t>

          <t>OPEN ISSUE: should specify how to request encryption of the
          message end-to-end.</t>

          <t><list style="hanging">
              <t></t><t hangText="Note:">The easiest implementation of TUNNEL is
              likely to default to sending all messages across a TUNNEL when
              the first message is sent to a new destination GRUU and
              simultaneously issuing a CONNECT. Messages then continue through
              the TUNNEL until the CONNECT completes, at which point they are
              delivered via the new connection.</t>
            </list></t>

          <t>OPEN ISSUE: If the tunneling vs direct decision can be made
          equivalently to a link-layer decision, it may not be necessary to
          modify the dialog or inform the SIP UA in any way that it has now
          obtained a direct route.</t>
        </section>
      </section>

      <section title="HIP Tunnel">
        <t>This usage allows two peers to exchange HIP messages across the
        overlay using the TUNNEL method. This is meant to be used as part of
        the HIP BONE architecture described in <xref
        target="I-D.camarillo-hip-bone"></xref>.</t>

        <t>As an application of TUNNEL, this usage defines the following
        items:</t>

        <t><list style="symbols">
            <t>For HIP, the application attribute is TBD (IANA port
            number).</t>

            <t>The dialogid is empty and set to zero length.</t>
          </list></t>

        <t>In order to route HIP messages correctly, there needs to be an
        unambiguous mapping between the ORCHID assigned to each HIP node and
        the Peer-ID assigned to that node. The ORCHID MUST be used as the
        Unhashed-ID to generate the Peer-ID. [TODO: We need a general scheme
        for mapping Unhashed-IDs to IDs so they don't collide. This isn't the
        place to define it.] Messages to a given ORCHID are then routed to the
        mapped Peer-ID. <xref target="sec-credentials"></xref> describes more
        considerations for the generation of ORCHIDs for use with RELOAD.</t>

        <t>TODO - should discuss interaction of HIP and P2P retransmission
        timers</t>
      </section>
      -->

      <section title="Diagnostic Usage" toc="default">
         <t>[TODO: SAB]</t>
        <t>[[TODO: reduce text of motivation description in the next
        version]]</t>

        <t>The development and deployment of a peer-to-peer system is a
        continuous process. The developers write code which is tested on a
        scale that may be smaller than the actual deployment size. After this
        local testing, the code is deployed in a real environment. Bugs arise
        during development and deployment phases. The designers of the
        peer-to-peer system need mechanisms which can help identify problems
        and bugs in a peer-to-peer system during development and deployment
        phases. Peer-to-peer systems are an example of a distributed system
        and it is not a trivial task to provide protocol mechanisms, tools and
        techniques to identify problems that may arise in such systems.</t>

        <t>The diagnostic mechanisms can broadly be classified into online and
        offline mechanisms. The online mechanisms attempt to identify faults
        in a running system where as offline mechanisms try to infer faults by
        gathering the log files of machines participating in a distributed
        system.</t>

        <t>In a peer-to-peer system, a peer maintains routing state to forward
        messages according to the overlay protocol being used. In addition, a
        peer stores information published by other peers. The routing and
        storage of resources consume network, space (memory), and CPU
        resources. A peer also needs to keep track of how long the P2PSIP
        application has been running and the last time peers in the routing
        table were last contacted. During development and deployment phase, an
        overlay designer needs mechanisms to query some or all of the above
        mentioned information.</t>

        <t>The overlay designer may also treat overlay as a black box and
        determine if the routing mechanisms are working correctly under
        various levels of churn.</t>

        <t>Thus, there are at least two types of online diagnostic mechanisms:
        1) state acquisition 2) black-box diagnostics</t>

        <section title="State Acquisition Mechanisms">
          <t>The protocol provides a DIAGNOSTIC method [TODO] which queries
          the peer for its routing state, average bandwidth, CPU utilization,
          and storage state. The state acquisition mechanism can be used to
          construct a local view of the connectivity state of the system. It
          can also be used to construct a geographical map of the system.</t>

          <t>Below, we identify potential issues with the state acquisition
          mechanisms.</t>

          <t>Security: If any peer can query the routing or storage state of
          any other peer, then clearly privacy and security concerns arise. To
          address this, the state acquisition mechanisms need an access list
          like mechanism so that only the overlay implementer can query the
          state of all the nodes. Alternatively, the state acquisition
          mechanisms are only enabled during the development phase or are only
          enabled for 'admin' users.</t>

          <t>Scalability: It is possible to query the state of few hundred or
          a few thousand nodes (as it is currently done in our live system on
          Planet lab); however, a serial state acquisition of a million node
          is a non starter. In large scale networks, one option is to query
          the state of few hundred nodes and to construct an high level
          connectivity map. CAIDA [ref] collects data at a few vantage points
          to construct BGP maps.</t>

          <t>Instantaneous vs. long term state: Another issue with these state
          acquisitions mechanisms is whether they acquire the instantaneous
          state snapshot or an exponential moving average or a list of
          snapshots over a period of time. For diagnostic metrics such as CPU
          utilization, an exponential moving average metric is also helpful in
          addition to the instantaneous snapshot.</t>

          <t>Pull vs. push: The state acquisition mechanisms can either be
          pull-based or push-based or a combination of both. In pull-based
          mechanisms, peer explicitly request state of another peer. This may
          not be sufficient because pull-based mechanisms require a to
          periodically poll a peer for any change state. In a push-based
          mechanism, peers advertise any change in certain metrics to their
          routing or neighbor peers. As an example of push-based mechanism, a
          peer which starts to relay a call may indicate a change in its
          bandwidth to its routing or neighbor peers in a PING message.</t>

          <t>Development vs. deployment: A hard problem is to decide which
          diagnostics are absolutely necessary during deployment and which are
          needed during development.</t>

          <t>Clearly, complete state acquisition has security concerns in a
          deployed system. The other option an overlay implementer can use is
          to run a few peers and have complete control over the functionality
          of these peers. These peers are same as other peers with the
          difference that an overlay implementer can explicitly query the
          state of these peers. It can then use this information to 'crawl'
          the overlay network and construct a local map of the network.</t>
        </section>

        <section title="Black-box diagnostics">
          <t>[[TODO: a better name for this section]]</t>

          <t>Black-box diagnostics: DHTs are examples of structured
          peer-to-peer networks and they allow nodes to store key/value pairs
          in the overlay. A simple diagnostic mechanism is to treat the
          overlay as a black-box: publish several key/value pairs at one peer
          and then look them up from another peer. For this kind of diagnostic
          mechanism, clients are more suitable as they do not provide any
          routing or storage services to the overlay and can connect to an
          arbitrary peer.</t>
        </section>

        <t>The Diagnostic Usage allow a peer to report various statistics
        about itself that may be useful for diagnostics or performance
        management. It can be used to discover information such as the
        software version, uptime, and performance statistics of a peer. The
        usage defines several new kinds which can be retrieved to get the
        statistics. The Peer-ID is directly used when retrieving data so no
        Unhashed-ID is defined. The access control model for all of these is
        local policy defined by the peer. The peer MAY have a list of users
        (such as "admin") that it is willing to return the information for and
        restrict access to users with that name. The access control can be
        determined on a per kind basis - for example, a node may be willing to
        return the software version to any users while specific information
        about performance may not be returned.</t>

        <t>The following kinds are defined:</t>

        <t><list style="hanging">
            <t></t><t hangText="SOFTWARE_VERSION">A single value element containing a
            US-ASCII string that identifies the manufacture, model, and
            version of the software.</t>

            <t></t><t hangText="UPTIME">A single value element containing an unsigned
            64-bit integer specifying the time the nodes has been up in
            seconds.</t>

            <t></t><t hangText="AS_NUMBER">A single value element containing the
            Autonomous System [TODO REF] number as an unsigned 32-bit integer.
            Zero is returned if the AS number is unknown.</t>

            <t>(OPEN ISSUES: How to determine a AS number? This metric is
            primarily used for advertising and locating STUN/TURN servers. A
            TURN server is inserted and looked up under H(AS). What if there are
            no TURN servers in the same AS? ) [[TODO: I propose we remove this
            unless we can say how to compute it. I note most the software I have
            seen just uses the table lookup on IP address - if this is the case
            it is probably better just to return IP address of NAT. ]]</t>

            <t></t><t hangText="CPU_UTILIZATION">A single value element containing an
            unsigned 8-bit integer representing the percentage CPU load from 1
            to 100.</t>

            <t>(OPEN ISSUE: It is not a very precise metric.)</t>

            <t></t><t hangText="DATA_STORED">A single value element containing an
            unsigned 64-bit integer representing the number of bytes of data
            being stored by this node.</t>

            <t></t><t hangText="MESSAGES_SENT">An array element containing the number
            of messages sent and received. The array is indexed by method
            code. Each entry in the array is a pair of unsigned 64-bit
            integers (packed end to end) representing sent and received.</t>

            <t></t><t hangText="INSTANCES_STORED">An array element containing the
            number of instances of each kind stored. The array is index by
            kind-id. Each entry is an unsigned 64-bit integer.</t>

            <t></t><t hangText="ROUTING_TABLE_SIZE">A single value element containing
            an unsigned 32-bit integer representing the number of peers in the
            node's routing table.</t>

            <t></t><t hangText="NEIGHBOR_TABLE_SIZE">A single value element
            containing an unsigned 32-bit integer representing the number of
            peers in the node's neighbor table.</t>

            <t></t><t hangText="EWMA_BYTES_SENT">A single value element containing an
            unsigned 32-bit integer representing an exponential weighted
            average of bytes sent by this peer.</t>
            <t> [[ TODO : Bruce or SAB - say how to compute this ]] </t>

            <t></t><t hangText="EWMA_BYTES_RCVD">A single value element containing an
            unsigned 32-bit integer representing an exponential weighted
            average of bytes received by this peer.</t>

            <t></t><t hangText="LAST_CONTACT">A single value element containing an
            unsigned 32-bit integer specifying the time in number of seconds
            the node was last contacted.</t>

            <t></t><t hangText="MEMORY_FOOTPRINT">A single value element containing
            an unsigned 32-bit integer representing the memory footprint of
            the peer program in kilo bytes.</t>

            <t></t><t hangText="RTT">A single value element containing an unsigned
            32-bit integer specifying the recent RTT estimate in ms between
            two peers.</t>
          </list></t>

        <t>[[TODO: We would like some sort of bandwidth measurement, but we're
        kind of unclear on the units and representation.]]</t>

        <section title="Diagnostic Metrics for a P2PSIP Deployment">
          <t>Clearly, all diagnostic metrics are useful during development and
          testing. The hard question is which metrics are absolutely necessary
          for a deployed P2PSIP system. We attempt to identify these metrics
          and classify them under 'resource' and 'peer' metrics.</t>

          <t>For 'resource' metric, we identify CPU_UTILIZATION,
          EWMA_BYTES_SENT, EWMA_BYTES_RCVD, and MEMORY_FOOTPRINT as the key
          metrics and for 'peer' metric we identify UPTIME, LAST_CONTACT, and
          RTT as the metrics that are crucial for a deployed P2PSIP
          system.</t>

          <t>(OPEN QUESTION: any other metrics?)</t>

          <t>(OPEN: Below, we sketch how these metrics can be used. A peer can
          use EWMA_BYTES_SENT and EWMA_BYTES_RCVD of another peer to infer
          whether it is acting as a media relay. It may then choose not to
          forward any requests for media relay to this peer. Similarly, among
          the various candidates for filling up routing table, a peer may
          prefer a peer with a large UPTIME value, small RTT, and small
          LAST_CONTACT value. )</t>
        </section>

        <!--  <t>[[TODO: Why not MIB]]</t> -->
      </section>
      <section anchor="sec.chord-algorithm" title="Chord Algorithm ">
        <t>[TODO: BBL]</t>

        <t>This algorithm is assigned the name chord-128-2-16+ to indicate it
        is based on Chord, uses a SHA-1 then truncates that to 128 bit for the hash function, stores 2 redundant
        copies of all data, and has finger tables with at least 16
        entries.</t>

        <section title="Overview">
          <t>The algorithm described here is a modified version of the Chord
          algorithm. Each peer keeps track of a finger table of 16 entries and
          a neighborhood table of 6 entries. The neighborhood table contains
          the 3 peers before this peer and the 3 peers after it in the DHT
          ring. The first entry in the finger table contains the peer half-way
          around the ring from this peer; the second entry contains the peer
          that is 1/4 of the way around; the third entry contains the peer
          that is 1/8th of the way around, and so on. Fundamentally, the chord
          data structure can be thought of a doubly-linked list formed by
          knowing the successors and predecessor peers in the neighborhood
          table, sorted by the Peer-ID. As long as the successor peers are
          correct, the DHT will return the correct result. The pointers to the
          prior peers are kept to enable inserting of new peers into the list
          structure. Keeping multiple predecessor and successor pointers makes
          it possible to maintain the integrity of the data structure even
          when consecutive peers simultaneously fail. The finger table forms a
          skip list, so that entries in the linked list can rapidly be found -
          it needs to be there so that peers can be found in O(log(N)) time
          instead of the typical O(N) time that a linked list would
          provide.</t>

          <t>A peer, n, is responsible for a particular Resource-ID k if k is
          less than or equal to n and k is greater than p, where p is the peer
          id of the previous peer in the neighborhood table. Care must be
          taken when computing to note that all math is modulo 2^128.</t>
        </section>

        <section title="Routing">
          <t>If a peer is not responsible for a Resource-ID k, then it routes
          a request to that location by routing it to the peer in either the
          routing or connection table that has the largest Peer-ID that is in
          the interval between the peer and k.</t>
        </section>

        <section title="Redundancy ">
          <t>When a peer receives a STORE request for Resource-ID k, and it is
          responsible for Resource-ID k, it stores the data and returns a
          SUCCESS response. [[Open Issue: should it delay sending this SUCCESS
          until it has successfully stored the redundant copies?]]. It then
          sends a STORE request to its successor in the neighborhood table and
          to that peers successor. Note that these STORE requests are
          addressed to those specific peers, even though the Resource-ID they
          are being asked to store is outside the range that they are
          responsible for. The peers receiving these check they came from an
          appropriate predecessor in their neighborhood table and that they
          are in a range that this predecessor is responsible for, and then
          they store the data. [[ TODO - make it clear nodes storing look at resource-ID and what they are responsible for to decide if they need to the redudant stores since they are the "master" copy. ]]</t>

          <t>Note that a malicious node can return a success response but not
          store the data locally or in the replica set. Requesting peers which
          wish to ensure that the replication actually occurred SHOULD contact
          each peer listed in the replicas field of the STORE response and
          retrieve a copy of the data. [[TODO: Do we want to have some
          optimization in FETCH where they can retrieve just a digest instead
          of the data values?]]</t>
        </section>

        <section title="Joining">
          <t>The join process for a joining party (JP) with Peer-ID n is as
          follows.</t>

          <t><list style="numbers">
              <t>JP connects to its chosen bootstrap node.</t>

              <t>JP uses a series of PINGs to populate its routing table.</t>

              <t>JP sends CONNECT requests to initiate connections to each of
              the peers in the connection table as well as to the desired
              finger table entries. Note that this does not populate their
              routing tables, but only their connection tables, so JP will not
              get messages that it is expected to route to other nodes.</t>

              <t>JP enters all the peers it contacted into its routing
              table.</t>

              <t>JP sends a JOIN to its immediate successor, the admitting
              peer (AP) for Peer-ID n. The AP sends the response to the
              JOIN.</t>

              <t>AP does a series of STORE requests to JP to store the data
              that JP will be responsible for.</t>

              <t>AP sends JP an UPDATE explicitly labeling JP as its
              predecessor. At this point, JP is part of the ring and
              responsible for a section of the overlay. AP can now forget any
              data which is assigned to JP and not AP.</t>

              <t>AP sends an UPDATE to all of its neighbors with the new
              values of its neighbor set (including JP).</t>

              <t>JP sends UPDATES to all the peers in its routing table.</t>
            </list></t>

          <t>In order to populate its routing table, JP sends a PING via the
          bootstrap node directed at resource-id n+1 (directly after its own
          resource-id). This allows it to discover its own successor. Call
          that node p0. It then sends a ping to p0+1 to discover its successor
          (p1). This process can be repeated to discover as many successors as
          desired. The values for the two peers before p will be found at a
          later stage when n receives an UPDATE.</t>

          <t>In order to set up its neighbor table entry for peer i, JP simply
          sends a CONNECT to peer (n+2^(numBitsInPeerId-i). This will be
          routed to a peer in approximately the right location around the
          ring.</t>
        </section>

        <section title="Routing CONNECTs">
          <t>When a peer needs to CONNECT with a new peer in its neighborhood
          table, it MUST source-route the CONNECT request through the peer
          from which it learned the new peer's Peer-ID. Source-routing these
          requests allows the overlay to recover from instability.</t>

          <t>All other CONNECT requests, such as those for new finger table
          entries, are routed conventionally through the overlay.</t>

          <t>If a peer is unable to successfully CONNECT with a peer that
          should be in its neighborhood, it MUST locate either a TURN server
          or another peer in the overlay, but not in its neighborhood, through
          which it can exchange messages with its neighbor peer</t>
        </section>

        <section title="UPDATEs">
          <t>A chord UPDATE is defined as</t>

          <figure>
            <!--begin-pdu-->

            <artwork><![CDATA[


      struct {
        PeerId                  predecessors<0..2^16-1>;
        PeerId                  successors<0..2^16-1>;
      } ChordUpdate;


              ]]></artwork>
          </figure>

          <t>The contents of this message are:</t>

          <t><list style="hanging">
              <t></t><t hangText="predecessors "></t><t>The predecessor set of the
              UPDATEing peer.</t>

              <t></t><t hangText="successors "></t><t>The successor set of the UPDATEing
              peer.</t>
            </list></t>

          <t>A peer MUST maintain an association (via CONNECT) to every member
          of its neighbor set. A peer MUST attempt to maintain at least three
          predecessors and three successors. However, it MUST send its entire
          set in any UPDATE message.</t>

          <section title="Sending UPDATEs">
            <t>Every time a connection to a peer in the neighborhood set is
            lost (as determined by connectivity pings or failure of some
            request), the peer should remove the entry from its neighborhood
            table and replace it with the best match it has from the other
            peers in its routing table. It then sends an UPDATE to all its
            remaining neighbors. The update will contain all the Peer-IDs of
            the current entries of the table (after the failed one has been
            removed). Note that when replacing a successor the peer SHOULD
            delay the creation of new replicas for 30 seconds after removing
            the failed entry from its neighborhood table in order to allow a
            triggered update to inform it of a better match for its
            neighborhood table.</t>

            <t>If connectivity is lost to all three of the peers that succeed
            this peer in the ring, then this peer should behave as if it is
            joining the network and use PINGs to find a peer and send it a
            JOIN. If connectivity is lost to all the peers in the finger
            table, this peer should assume that it has been disconnected from
            the rest of the network, and it should periodically try to join
            the DHT.</t>
          </section>

          <section title="Receiving UPDATEs">
            <t>When a peer, N, receives an UPDATE request, it examines the
            Peer-IDs in the UPDATE_Q and at its neighborhood table and decides
            if this UPDATE_Q would change its neighborhood table. This is done
            by taking the set of peers currently in the neighborhood table and
            comparing them to the peers in the update request. There are three
            major cases:</t>

            <t><list style="symbols">
                <t>The UPDATE_Q contains peers that would not change the
                neighbor set because they match the neighborhood table.</t>

                <t>The UPDATE_Q contains peers closer to N than those in its
                neighborhood table.</t>

                <t>The UPDATE_Q defines peers that indicate a neighborhood
                table further away from N than some of its neighborhood table.
                Note that merely receiving peers further away does not
                demonstrate this, since the update could be from a node far
                away from N. Rather, the peers would need to bracket N.</t>
              </list></t>

            <t>In the first case, no change is needed.</t>

            <t>In the second case, N MUST attempt to CONNECT to the new peers
            and if it is successful it MUST adjust its neighbor set
            accordingly. Note that it can maintain the now inferior peers as
            neighbors, but it MUST remember the closer ones.</t>

            <t>The third case implies that a neighbor has disappeared, most
            likely because it has simply been disconnected but perhaps because
            of overlay instability. N MUST PING the questionable peers to
            discover if they are indeed missing and if so, remove them from
            its neighborhood table.</t>

            <t>After any PINGs and CONNECTs are done, if the neighborhood
            table changes, the peer sends an UPDATE request to each of its
            neighbors that was in either the old table or the new table. These
            UPDATE requests are what ends up filling in the
            predecessor/successor tables of peers that this peer is a neighbor
            to. A peer MUST NOT enter itself in its successor or predecessor
            table and instead should leave the entries empty.</t>

            <t>A peer N which is responsible for a resource-id R discovers
            that the replica set for R (the next two nodes in its successor
            set) has changed, it MUST send a STORE for any data associated
            with R to any new node in the replica set. It SHOULD not delete
            data from peers which have left the replica set.</t>

            <t>When a peer N detects that it is no longer in the replica set
            for a resource R (i.e., there are three predecessors between N and
            R), it SHOULD delete all data associated with R from its local
            store.</t>
          </section>

          <section title="Stabilization">
            <t>There are four components to stabilization: <list
                style="numbers">
                <t>exchange UPDATES will all peers in its routing table to
                exchange state</t>

                <t>search for better peers to place in its finger table</t>

                <t>search to determine if the current finger table size is
                sufficiently large</t>

                <t>search to determine if the overlay has partitioned and
                needs to recover</t>
              </list></t>

            <t>A peer MUST periodically send an UPDATE request to every peer
            in its routing table. The purpose of this is to keep the
            predecessor and successor lists up to date and to detect
            connection failures. The default time is about every ten minutes,
            but the enrollment server SHOULD set this in the configuration
            document using the "chord-128-2-16+-update-frequency" element
            (denominated in seconds.) A peer SHOULD randomly offset these
            UPDATE requests so they do not occur all at once. If an UPDATE
            request fails or times out, the peer MUST mark that entry in the
            neighbor table invalid and attempt to reestablish a connection. If
            no connection can be established, the peer MUST attempt to
            establish a new peer as its neighbor and do whatever replica set
            adjustments are required.</t>

            <t>Periodically a peer should select a random entry i from the
            finger table and do a PING to peer (n+2^(numBitsInPeerId-i). The
            purpose of this is to find a more accurate finger table entry if
            there is one. This is done less frequently than the connectivity
            checks in the previous section because forming new connections is
            somewhat expensive and the cost needs to be balanced against the
            cost of not having the most optimal finger table entries. The
            default time is about every hour, but the enrollment server SHOULD
            set this in the configuration document using the
            "chord-128-2-16+-ping-frequency" element (denominated in seconds).
            If this returns a different peer than the one currently in this
            entry of the peer table, then a new connection should be formed to
            this peer and it should replace the old peer in the finger
            table.</t>

            <t>As an overlay grows, more than 16 entries may be required in
            the finger table for efficient routing. To determine if its finger
            table is sufficiently large, one an hour the peer should perform a
            PING to determine whether growing its finger table by four entries
            would result in it learning at least two peers that it does not
            already have in its neighbor table. If so, then the finger table
            SHOULD be grown by four entries. Similarly, if the peer observes
            that its closest finger table entries are also in its neighbor
            table, it MAY shrink its finger table to the minimum size of 16
            entries. [[OPEN ISSUE: there are a variety of algorithms to gauge
            the population of the overlay and select an appropriate finger
            table size. Need to consider which is the best combination of
            effectiveness and simplicity.]]</t>

            <t>To detect that a partitioning has occurred and to heal the
            overlay, a peer P MUST periodically repeat the discovery process
            used in the initial join for the overay to locate an appropriate
            bootstrap peer, B. If an overlay has multiple mechanisms for
            discovery it should randomly select a method to locate a bootstrap
            peer. P should then send a PING for its own Peer-ID routed through
            B. If a response is received from a peer S', which is not P's
            successor, then the overlay is partitioned and P should send a
            CONNECT to S' routed through B, followed by an UPDATE sent to S'.
            (Note that S' may not be in P's neighborhood table once the
            overlay is healed, but the connection will allow S' to discover
            appropriate neighbor entries for itself via its own
            stabilization.)</t>
          </section>
        </section>

        <section title="Leaving">
          <t>Peers SHOULD send a LEAVE request prior to exiting the DHT Instance. Any
          peer which receives a LEAVE for a peer n in its neighbor set must
          remove it from the neighbor set, update its replica sets as
          appropriate (including STOREs of data to new members of the replica
          set) and send UPDATEs containing its new predecessor and successor
          tables.</t>
        </section>
      </section>

    <section anchor="secEnrollment" title="Enrollment and Bootstrap">
      <section title="Discovery">
        <t>When a peer first joins a new overlay, it starts with a discovery
        process to find an enrollment server. Related work to the approach
        used here is described in <xref
        target="I-D.garcia-p2psip-dns-sd-bootstrapping"></xref> and <xref
        target="I-D.matthews-p2psip-bootstrap-mechanisms"></xref>. The peer
        first determines the overlay name. This value is provided by the user
        or some other out of band provisioning mechanism. If the name is an IP
        address, that is directly used otherwise the peer MUST do a DNS SRV
        query using a Service name of "p2p_enroll" and a protocol of tcp to
        find an enrollment server.</t>

        <t>If the overlay name ends in .local, then the DNS SRV lookup is done
        using implement <xref target="I-D.cheshire-dnsext-dns-sd"></xref> with
        a Service name of "p2p_menroll" can also be tried to find an
        enrollment server. If they implement this, the user name MAY be used
        as the Instance Identifier label.</t>

        <t>Once an address for the enrollment servers is determined, the peer
        forms an HTTPS connection to that IP address. The certificate MUST
        match the overlay name as described in <xref target="RFC2818"></xref>.
        The peer then performs a GET to the URL formed by appending a path of
        "/p2psip/enroll" to the overlay name. For example, if the overlay name
        was example.com, the URL would be
        "https://example.com/p2psip/enroll".</t>

        <t>The result is an XML configuration file with the syntax described
        in the following section.</t>
      </section>

      <section anchor="sec-configuration" title="Overlay Configuration">
        <t>This specification defines a new content type
        "application/p2p-overlay+xml" for an MIME entity that contains overlay
        information. This information is fetched from the enrollment server,
        as described above. An example document is shown below.</t>

        <figure>
          <artwork><![CDATA[
   <?xml version="1.0" encoding="UTF-8"?>
     <overlay instance-name="chord.example.com" expiration="86400">
       <dht dht-algorithm="chord-128-2-16+"/>
       <root-cert>[PEM encoded certificate here]</root-cert>
       <required-usage name="SIP"/>
       <credential-server url="https://www.example.com/csr"/>
       <bootstrap-peer address="192.0.2.2" port="5678"/>
       <bootstrap-peer address="192.0.2.3" port="5678"/>
       <bootstrap-peer address="192.0.2.4" port="5678"/>
       <multicast-bootstrap="192.0.2.99" port="5678"/>
     </overlay>
              ]]></artwork>
        </figure>

        <t>The file MUST be a well formed XML document and it SHOULD contain
        an encoding declaration in the XML declaration. If the charset
        parameter of the MIME content type declaration is present and it is
        different from the encoding declaration, the charset parameter takes
        precedence. Every application conferment to this specification MUST
        accept the UTF-8 character encoding to ensure minimal
        interoperability. The namespace for the elements defined in this
        specification is urn:ietf:params:xml:ns:p2p:overlay.</t>

        <t>The file can contain multiple "overlay" elements where each one
        contains the configuration information for a different overlay. Each
        "overlay" has the following attributes:</t>

        <t><list style="hanging">
            <t></t><t hangText="instance-name:">name of the overlay</t>

            <t></t><t hangText="expiration:">time in future at which this overlay
            configuration is not longer valid and need to be retrieved again.
            This is expressed in seconds from the current time.</t>
          </list></t>

        <t>Inside each overlay element, the following elements can occur:</t>

        <t><list style="hanging">
            <t></t><t hangText="dht-algorithm"></t><t>This element has an attribute called name that
            describes which DHT algorithm is being used.</t>

            <t></t><t hangText="root-cert "></t><t>This element contains a PEM encoded
            X.509v3 certificate that is the root trust store used to sign all
            certificates in this overlay. There can be more than one of
            these.</t>

            <t></t><t hangText="required-usage "></t><t>This element has an attribute
            called "name" that describes a usage that peers in this overlay
            are required to support. More than one required-usage element may
            be present.</t>

            <t></t><t hangText="credential-server "></t><t>This element contains the URL at
            which the credential server can be reached in a "url" element.
            This URL MUST be of type "https:". More than one credential-server
            element may be present.</t>

            <t></t><t hangText="bootstrap-peer "></t><t>This elements represents the
            address of one of the bootstrap peers. It has an attribute called
            "address" that represents the IP address (either IPv4 or IPv6,
            since they can be distinguished) and an attribute called "port"
            that represents the port. More than one bootstrap-peer element may
            be present.</t>

            <t></t><t hangText="multicast-bootstrap "></t><t>This element represents the
            address of a multicast address and port that may be used for
            bootstrap and that peers SHOULD listen on to enable bootstrap. It
            has an attributed called "address" that represents the IP address
            and an attribute called "port" that represents the port. More than
            one "multicast-bootstrap" element may be present.</t>

            <t></t><t hangText="iterative-permitted "></t><t>This element indicates that
            iterative routing (see <xref target="sec-route-query"></xref>) MAY
            be used. If iterative routing is permitted, then this value MUST
            be set to "TRUE". Otherwise, it SHOULD be absent, but MAY be set
            to "FALSE".</t>

           <t></t><t hangText="chord-128-2-16+-update-frequency "></t><t></t>

           <t></t><t hangText="chord-128-2-16+-ping-frequency "></t><t></t>

           <t></t><t hangText="credential-server"></t><t>Base URL for credential server.</t>

           <t></t><t hangText="shared-secret"></t><t>If shared secret mode is used, this contains the shared secret.</t>

           <t></t><t hangText=" "></t><t></t>

           <t></t><t hangText=" "></t><t></t>

          </list></t>

        <t>[[TODO: Do a RelaxNG grammar.]]</t>
      </section>

      <section anchor="sec-credentials" title="Credentials">
        <t>If the configuration document contains a credential-server element,
        credentials are required to use the DHT Instance. A peer which does not yet
        have credentials MUST contact the credential server to acquire
        them.</t>

        <t>In order to acquire credentials, the peer generates an asymmetric
        key pair and then generates a "Simple Enrollment Request" (as defined
        in <xref target="I-D.ietf-pkix-2797-bis"></xref>) and sends this over
        HTTPS as defined in <xref target="I-D.ietf-pkix-cmc-trans"></xref> to
        the URL in the credential-server element. The subjectAltName in the
        request MUST contain the required user name.</t>

        <t>The credential server MUST authenticate the request using the
        proivded user name and password. If the authentication succeeds and the
        requested user name is acceptable, the server and returns a
        certificate. The SubjectAltName field in the certificate contains the
        following values:</t>

        <t><list style="symbols">
            <t>One or more Peer-IDs which MUST be cryptographically random
            <xref target="RFC4086"></xref>. These MUST be chosen by the
            credential server in such a way that they are unpredictable to the
            requesting user.</t>

            <t>The names this user is allowed to use in the overlay</t>
          </list></t>

        <t>The certificate is returned in a "Simple Enrollment Response". [[TODO: REF]]</t>

        <t>The client MUST check that the certificate returned was signed by
        one of the certificates received in the "root-cert" list of the
        overlay configuration data. The peer then reads the certificate to
        find the Peer-IDs it can use.</t>

        <section title="Credentials for HIP">
          <t>When RELOAD is used with HIP, the certificates MUST be generated
          so that: <list style="symbols">
              <t>Each node is assigned a unique ORCHID.</t>

              <t>The Peer-ID can be uniquely determined from the ORCHID.</t>
            </list> Because in general, ORCHIDs are shorter than Peer-IDs,
          this means that the ORCHIDS MUST be generated first and MUST be
          cryptographically random in order to make the Peer-IDs
          cryptographically random. The mapping function used to produce the
          Peer-ID from the ORCHID MUST be the same as that used by the DHT Instance to
          produce resource-ids from Unhashed-IDs.</t>

          <t>In addition to the usual attributes, when HIP is in use
          certificates MUST contain a subjectAltName with an iPAddress value
          containing the HIP ORCHID. This allows these certificates to be used
          by the HIP peers during the HIP base exchange.</t>
        </section>
      </section>

      <section title="Locating a Peer">
        <t>In order to join the overlay, the peer MUST contact a peer.
        Typically this means contacting the bootstrap peers, since they are
        guaranteed to have public IP addresses (the system should not
        advertise them as bootstrap peers otherwise). If the peer has cached
        peers it SHOULD contact them first by sending a PING request to the
        known peer address with the destination Peer-ID set to that peer's
        Peer-ID.</t>

        <t>If no cached peers are available, then the peer SHOULD send a PING
        request to the address and port found in the broadcast-peers element
        in the configuration document. This MAY be a multicast or anycast
        address. The PING should use the wildcard Peer-ID as the destination
        Peer-ID.</t>

        <t>The responder peer that receives the PING request SHOULD check that
        the overlay name is correct and that the requester peer sending the
        request has appropriate credentials for the overlay before responding
        to the PING request even if the response is only an error.</t>

        <t>When the requester peer finally does receive a response from some
        responding peer, it can note the Peer-ID in the response and use this
        Peer-ID to start sending requests to join the DHT Instance as described in
        <xref target="sec-join-leave-maint"></xref> and [XREF].</t>

        <t>After a peer has successfully joined the overlay network, it SHOULD
        periodically look at any peers to which it has managed to form direct
        connections. Some of these peers MAY be added to the cached-peers list
        and used in future boots. Peers that are not directly connected MUST
        NOT be cached. The RECOMMENDED number of peers to cache is 10.</t>
      </section>
    </section>

    <section title="Message Flow Example">
      <t>[TODO: SAB]</t>
    </section>

    <section title="Security Considerations">
      <section title="Overview">
        <t>RELOAD provides a generic storage service, albeit one designed to
        be useful for P2P SIP. In this section we discuss security issues that
        are likely to be relevant to any usage of RELOAD. In <xref
        target="section.sip-issues"></xref> we describe issues that are
        specific to SIP.</t>

        <t>In any DHT Instance, any given user depends on a number of peers with which
        they have no well-defined relationship except that they are fellow
        members of the DHT Instance. In practice, these other nodes may be friendly,
        lazy, curious, or outright malicious. No security system can provide
        complete protection in an environment where most nodes are malicious.
        The goal of security in RELOAD is to provide strong security
        guarantees of some properties even in the face of a large number of
        malicious nodes and to allow the DHT to function correctly in the face
        of a modest number of malicious nodes.</t>

        <t>P2PSIP deployments require the ability to authenticate both peers
        and resources (users) without the active presence of a trusted entity
        in the system. We describe two mechanisms. The first mechanism is
        based on public key certificates and is suitable for general
        deployments. The second is based on an overlay-wide shared symmetric
        key and is suitable only for limited deployments in which the
        relationship between admitted peers is not adversarial.</t>
      </section>

      <section title="Attacks on P2P Overlays">
        <t>The two basic functions provided by DHT nodes are storage and
        routing: some node is responsible for storing a peer's data and for
        allowing a peer to fetch other peer's data. Some other set of nodes
        are responsible for routing messages to and from the storing nodes.
        Each of these issues is covered in the following sections.</t>

        <t>P2P overlays are subject to attacks by subversive nodes that may
        attempt to disrupt routing, corrupt or remove user registrations, or
        eavesdrop on signaling. The certificate-based security algorithms we
        describe in this draft are intended to protect DHT routing and user
        registration information in RELOAD messages.</t>

        <t>To protect the signaling from attackers pretending to be valid
        peers (or peers other than themselves), the first requirement is to
        ensure that all messages are received from authorized members of the
        overlay. For this reason, RELOAD transports all messages over DTLS or
        TLS, which provides message integrity and authentication of the
        directly communicating peer. In addition, when the certificate-based
        security system is used, messages and data are digitally signed with
        the sender's private key, providing end-to-end security for
        communications.</t>
      </section>

      <section title="Certificate-based Security">
        <t>This specification stores users' registrations and possibly other
        data in a Distributed Hash table (DHT). This requires a solution to
        securing this data as well as securing, as well as possible, the
        routing in the DHT. Both types of security are based on requiring that
        every entity in the system (whether user or peer) authenticate
        cryptographically using an asymmetric key pair tied to a
        certificate.</t>

        <t>When a user enrolls in the DHT Instance, they request or are assigned a
        unique name, such as "alice@dht.example.net". These names are unique
        and are meant to be chosen and used by humans much like a SIP Address
        of Record (AOR) or an email address. The user is also assigned one or
        more Peer-IDs by the central enrollment authority. Both the name and
        the peer ID are placed in the certificate, along with the user's
        public key.</t>

        <t>Each certificate enables an entity to act in two sorts of
        roles:</t>

        <t><list style="symbols">
            <t>As a user, storing data at specific Resource-IDs in the DHT Instance
            corresponding to the user name.</t>

            <t>As a DHT peer with the peer ID(s) listed in the
            certificate.</t>
          </list></t>

        <t>Note that since only users of this DHT Instance need to validate a
        certificate, this usage does not require a global PKI. It does,
        however, require a central enrollment authority which acts as the
        certificate authority for the DHT Instance. This authority signs each peer's
        certificate. Because each peer possesses the CA's certificate (which
        they receive on enrollment) they can verify the certificates of the
        other entities in the overlay without further communication. Because
        the certificates contain the user/peer's public key, communications
        from the user/peer can be verified in turn.</t>

        <t>Because all stored data is signed by the owner of the data the 
         the storing peer can verify that the storer is authorized to
        perform a store at that resource-id and also allows any consumer of
        the data to verify the provenance and integrity of the data when it
        retrieves it.</t>

        <t>All implementations MUST implement certificate-based security.</t>
      </section>

      <section title="Shared-Secret Security">
        <t>For small environments where deployment of the PKI necessary to use
        a certificate-based model is impractical, RELOAD supports a shared
        secret security that relies on a single key that is shared among all
        members of the overlay. It is appropriate for small groups that wish
        to form a private network without complexity. In shared secret mode,
        all the peers share a single symmetric key which is used to key
        TLS-PSK <xref target="RFC4279"></xref> or TLS-SRP <xref
        target="I-D.ietf-tls-srp"></xref> mode. A peer which does not know the
        key cannot form TLS connections with any other peer and therefore
        cannot join the overlay.</t>

        <t>The shared-secret scheme prohibits unauthorized peers from joining
        the overlay, but it provides no protection from a compromised peer
        inserting arbitrary resource registrations, performing a Sybil
        attack<xref target="Sybil"></xref>, or performing other attacks on the
        resources or routing. Thus, it is only safe to use in limited settings
        in which peers are not adversarial. In addition, because the messages
        and data are not authenticated, each intermediate peer MUST take care
        to use TLS and check the other peer's knowledge of the shared secret,
        or message insertion is possible.</t>

        <t>If the shared secret key for the shared-key security scheme is
        discovered by an attacker, then most of the security of the scheme is
        lost: an attacker can impersonate any peer to any other peer. Thus,
        the shared-secret scheme is only appropriate for small deployments,
        such as a small office or ad hoc overlay set up among participants in
        a meeting.</t>

        <t>One natural approach to a shared-secret scheme is to use a
        user-entered password as the key. The difficulty with this is that in
        TLS-PSK mode, such keys are very susceptible to dictionary attacks. If
        passwords are used as the source of shared-keys, then TLS-SRP is a
        superior choice because it is not subject to dictionary attacks.</t>
      </section>

      <section title="Storage Security">
        <t>When certificate-based security is used in RELOAD, any given
        Resource-ID/kind-id pair (a slot) is bound to some small set of
        certificates. In order to write data in a slot, the writer must prove
        possession of the private key for one of those certificates. Moreover,
        all data is stored signed by the certificate which authorized its
        storage. This set of rules makes questions of authorization and data
        integrity - which have historically been thorny for DHTs - relatively
        simple.</t>

        <t>When shared-secret security is used, then all peers trust all other
        peers, provided that they have demonstrated that they have the
        credentials to join the overlay at all. The following text therefore
        applies only to certificate-based security.</t>

        <section title="Authorization">
          <t>When a client wants to store some value in a slot, it first
          digitally signs the value with its own private key. It then sends a
          STORE request that contains both the value and the signature towards
          the storing peer (which is defined by the Unhashed-ID construction
          algorithm for that particular kind of value).</t>

          <t>When the storing peer receives the request, it must determine
          whether the storing client is authorized to store in this slot. In
          order to do so, it executes the Unhashed-ID construction algorithm
          for the specified kind based on the user's certificate information.
          It then computes the Resource-ID from the Unhashed-ID and verifies
          that it matches the slot which the user is requesting to write to.
          If it does, the user is authorized to write to this slot, pending
          quota checks as described in the next section.</t>

          <t>For example, consider the certificate with the following
          properties:</t>

          <figure>
            <artwork><![CDATA[
        User name: alice@dht.example.com
        Peer-ID:   013456789abcdef
        Serial:    1234
        ]]></artwork>
          </figure>

          <t>If Alice wishes to STORE a value of the "SIP Location" kind, the
          Unhashed-ID will be the SIP AOR "sip:alice@dht.example.com". The
          Resource-ID will be determined by hashing the Unhashed-ID. When a
          peer receives a request to store a record at Resource-ID X, it takes
          the signing certificate and recomputes the Unhashed-ID, in this case
          "alice@dht.example.com". If H("alice@dht.example.com")=X then the
          STORE is authorized. Otherwise it is not. Note that the Unhashed-ID
          construction algorithm may be different for other kinds.</t>
        </section>

        <section title="Distributed Quota">
          <t>Being a peer in a DHT Instance carries with it the responsibility to store
          data for a given region of the DHT Instance. However, if clients were allowed
          to store unlimited amounts of data, this would create unacceptable
          burdens on peers, as well as enabling trivial denial of service
          attacks. RELOAD addresses this issue by requiring each usage to
          define maximum sizes for each kind of stored data. Attempts to store
          values exceeding this size MUST be rejected (if peers are
          inconsistent about this, then strange artifacts will happen when the
          zone of responsibility shifts and a different peer becomes
          responsible for overlarge data). Because each slot is bound to a
          small set of certificates, these size restrictions also create a
          distributed quota mechanism, with the quotas administered by the
          central enrollment server.</t>

          <t>Allowing different kinds of data to have different size
          restrictions allows new usages the flexibility to define limits that
          fit their needs without requiring all usages to have expansive
          limits.</t>
        </section>

        <section title="Correctness">
          <t>Because each stored value is signed, it is trivial for any
          retrieving peer to verify the integrity of the stored value. Some
          more care needs to be taken to prevent version rollback attacks.
          Rollback attacks on storage are prevented by the use of store times
          and lifetime values in each store. A lifetime represents the latest
          time at which the data is valid and thus limits (though does not
          completely prevent) the ability of the storing node to perform a
          rollback attack on retrievers. In order to prevent a rollback attack
          at the time of the STORE request, we require that storage times be
          monotonically increasing. Storing peers MUST reject STORE requests
          with storage times smaller than or equal to those they are currently
          storing. In addition, a fetching node which receives a data value
          with a storage time older than the result of the previous fetch
          knows a rollback has occurred.</t>
        </section>

        <section title="Residual Attacks">
          <t>The mechanisms described here provide a high degree of security,
          but some attacks remain possible. Most simply, it is possible for
          storing nodes to refuse to store a value (i.e., reject any request).
          In addition, a storing node can deny knowledge of values which it
          previously accepted. To some extent these attacks can be ameliorated
          by attempting to store to/retrieve from replicas, but a retrieving
          client does not know whether it should try this or not, since there
          is a cost to doing so.</t>

          <t>Although the certificate-based authentication scheme prevents a
          single peer from being able to forge data owned by other peers.
          Furthermore, although a subversive peer can refuse to return data
          resources for which it is responsible it cannot return forged data
          because it cannot provide authentication for such registrations.
          Therefore parallel searches for redundant registrations can mitigate
          most of the affects of a compromised peer. The ultimate reliability
          of such an overlay is a statistical question based on the
          replication factor and the percentage of compromised peers.</t>

          <t>In addition, when a kind is is multivalued (e.g., an array data
          model), the storing node can return only some subset of the values,
          thus biasing its responses. This can be countered by using single
          values rather than sets, but that makes coordination between
          multiple storing agents much more difficult. This is a tradeoff that
          must be made when designing any usage.</t>
        </section>
      </section>

      <section title="Routing Security">
        <t>Because the storage security system guarantees (within limits) the
        integrity of the stored data, routing security focuses on stopping the
        attacker from performing a DOS attack on the system by misrouting
        requests in the DHT. There are a few obvious observations to make
        about this. First, it is easy to ensure that an attacker is at least a
        valid peer in the DHT Instance. Second, this is a DOS attack only. Third, if a
        large percentage of the peers on the DHT Instance are controlled by the
        attacker, it is probably impossible to perfectly secure against
        this.</t>

        <section title="Background">
          <t>In general, attacks on DHT routing are mounted by the attacker
          arranging to route traffic through or two nodes it controls. In the
          Eclipse attack <xref target="Eclipse"></xref> the attacker tampers
          with messages to and from nodes for which it is on-path with respect
          to a given victim node. This allows it to pretend to be all the
          nodes that are reachable through it. In the Sybil attack <xref
          target="Sybil"></xref>, the attacker registers a large number of
          nodes and is therefore able to capture a large amount of the traffic
          through the DHT.</t>

          <t>Both the Eclipse and Sybil attacks require the attacker to be
          able to exercise control over her peer IDs. The Sybil attack
          requires the creation of a large number of peers. The Eclipse attack
          requires that the attacker be able to impersonate specific peers. In
          both cases, these attacks are limited by the use of centralized,
          certificate-based admission control.</t>
        </section>

        <section title="Admissions Control">
          <t>Admission to an RELOAD DHT Instance is controlled by requiring that each
          peer have a certificate containing its peer ID. The requirement to
          have a certificate is enforced by using TLS mutual authentication on
          each connection. Thus, whenever a peer connects to another peer,
          each side automatically checks that the other has a suitable
          certificate. These peer IDs are randomly assigned by the central
          enrollment server. This has two benefits:</t>

          <t><list style="symbols">
              <t>It allows the enrollment server to limit the number of peer
              IDs issued to any individual user.</t>

              <t>It prevents the attacker from choosing specific peer IDs.</t>
            </list></t>

          <t>The first property allows protection against Sybil attacks
          (provided the enrollment server uses strict rate limiting policies).
          The second property deters but does not completely prevent Eclipse
          attacks. Because an Eclipse attacker must impersonate peers on the
          other side of the attacker, he must have a certificate for suitable
          peer IDs, which requires him to repeatedly query the enrollment
          server for new certificates which only will match by chance. From
          the attacker's perspective, the difficulty is that if he only has a
          small number of certificates the region of the DHT Instance he is
          impersonating appears to be very sparsely populated by comparison to
          the victim's local region.</t>
        </section>

        <section title="Peer Identification and Authentication">
          <t>In general, whenever a peer engages in DHT activity that might
          affect the routing table it must establish its identity. This
          happens in two ways. First, whenever a peer establishes a direct
          connection to another peer it authenticates via TLS mutual
          authentication. All messages between peers are sent over this
          protected channel and therefore the peers can verify the data origin
          of the last hop peer for requests and responses without further
          cryptography.</t>

          <t>In some situations, however, it is desirable to be able to
          establish the identity of a peer with whom one is not directly
          connected. The most natural case is when a peer UPDATEs its state.
          At this point, other peers may need to update their view of the DHT
          structure, but they need to verify that the UPDATE message came from
          the actual peer rather than from an attacker. To prevent this, all
          DHT routing messages are signed by the peer that generated them.</t>

          <t>[TODO: this allows for replay attacks on requests. There are two
          basic defenses here. The first is global clocks and loose
          anti-replay. The second is to refuse to take any action unless you
          verify the data with the relevant node. This issue is
          undecided.]</t>

          <t>[TODO: I think we are probably going to end up with generic
          signatures or at least optional signatures on all DHT messages.]</t>
        </section>

        <section title="Protecting the Signaling">
          <t>The goal here is to stop an attacker from knowing who is
          signaling what to whom. An attacker being able to observe the
          activities of a specific individual is unlikely given the
          randomization of IDs and routing based on the present peers
          discussed above. Furthermore, because messages can be routed using
          only the header information, the actual body of the RELOAD message
          can be encrypted during transmission.</t>

          <t>There are two lines of defense here. The first is the use of TLS
          or DTLS for each communications link between peers. This provides
          protection against attackers who are not members of the overlay. The
          second line of defense, if certificate-based security is used, is to
          digitally sign each message. This prevents adversarial peers from
          modifying messages in flight, even if they are on the routing
          path.</t>
        </section>

        <section title="Residual Attacks">
          <t>The routing security mechanisms in RELOAD are designed to contain
          rather than eliminate attacks on routing. It is still possible for
          an attacker to mount a variety of attacks. In particular, if an
          attacker is able to take up a position on the DHT routing between A
          and B it can make it appear as if B does not exist or is
          disconnected. It can also advertise false network metrics in attempt
          to reroute traffic. However, these are primarily DoS attacks.</t>

          <t>The certificate-based security scheme secures the namespace, but
          if an individual peer is compromised or if an attacker obtains a
          certificate from the CA, then a number of subversive peers can still
          appear in the overlay. While these peers cannot falsify responses to
          resource queries, they can respond with error messages, effecting a
          DoS attack on the resource registration. They can also subvert
          routing to other compromised peers. To defend against such attacks,
          a resource search must still consist of parallel searches for
          replicated registrations.</t>
        </section>
      </section>

      <section anchor="section.sip-issues" title="SIP-Specific Issues">
        <section title="Fork Explosion">
          <t>Because SIP includes a forking capability (the ability to
          retarget to multiple recipients), fork bombs are a potential DoS
          concern. However, in the SIP usage of RELOAD, fork bombs are a much
          lower concern because the calling party is involved in each
          retargeting event and can therefore directly measure the number of
          forks and throttle at some reasonable number.</t>
        </section>

        <section title="Malicious Retargeting">
          <t>Another potential DoS attack is for the owner of an attractive
          number to retarget all calls to some victim. This attack is
          difficult to ameliorate without requiring the target of a SIP
          registration to authorize all stores. The overhead of that
          requirement would be excessive and in addition there are good use
          cases for retargeting to a peer without there explicit
          cooperation.</t>
        </section>

        <section title="Privacy Issues">
          <t>All RELOAD SIP registration data is public. Methods of providing
          location and identity privacy are still being studied.</t>
        </section>
      </section>
    </section>

    <section title="IANA Considerations">
      <t>This section contains the new code points registered by this
      document. The IANA policies are TBD.</t>

      <section title="Overlay Algorithm Types">
        <t>IANA SHALL create/(has created) a "RELOAD Overlay Algorithm Type"
        Registry. Entries in this registry are strings denoting the names of
        DHT algorithms. The registration policy for this registry is TBD.</t>

        <t>The initial contents of this registry are:</t>

        <t><list style="hanging">
            <t></t><t hangText="chord-128-2-16+ "></t><t>The algorithm defined in <xref
            target="sec.chord-algorithm"></xref> of this document.</t>
          </list></t>
      </section>

      <section title="Data Kind-Id">
        <t>IANA SHALL create/(has created) a "RELOAD Data Kind-Id" Registry.
        Entries in this registry are 32-bit integers denoting data kinds, as
        described in [XREF]. The registration
        policy for this registry is TBD.</t>

        <t>The initial contents of this registry are:</t>

        <t></t>

        <texttable>
          <ttcol align="left">Kind</ttcol>

          <ttcol align="right">Kind-Id</ttcol>

          <c>SIP-REGISTRATION</c>

          <c>1</c>

          <c>TURN_SERVICE</c>

          <c>2</c>

          <c>CERTIFICATE</c>

          <c>3</c>

          <c>SOFTWARE_VERSION</c>

          <c>4</c>

          <c>UPTIME</c>

          <c>5</c>

          <c>AS_NUMBER</c>

          <c>6</c>

          <c>CPU_UTILIZATION</c>

          <c>7</c>

          <c>DATA_STORED</c>

          <c>8</c>

          <c>MESSAGES_SENT</c>

          <c>9</c>

          <c>INSTANCES_STORED</c>

          <c>10</c>

          <c>ROUTING_TABLE_SIZE</c>

          <c>11</c>

          <c>NEIGHBOR_TABLE_SIZE</c>

          <c>12</c>
        </texttable>
      </section>

      <section title="Data Model">
        <t>IANA SHALL create/(has created) a "RELOAD Data Model" Registry.
        Entries in this registry are 8-bit integers denoting data models, as
        described in [XREF]. The
        registration policy for this registry is TBD.</t>

        <t></t>

        <texttable>
          <ttcol align="left">Data Model</ttcol>

          <ttcol align="right">Identifier</ttcol>

          <c>SINGLE_VALUE</c>

          <c>1</c>

          <c>ARRAY</c>

          <c>2</c>

          <c>DICTIONARY</c>

          <c>3</c>
        </texttable>
      </section>

      <section title="Message Codes">
        <t>IANA SHALL create/(has created) a "RELOAD Message Code" Registry.
        Entries in this registry are 16-bit integers denoting method codes as
        described in [XREF] The
        registration policy for this registry is TBD.</t>

        <t>The initial contents of this registry are:</t>

        <t></t>

        <texttable>
          <ttcol align="left">Message Code Name</ttcol>

          <ttcol align="right">Code Value</ttcol>

          <c>RESERVED</c>

          <c>0</c>

          <c>PING_Q</c>

          <c>1</c>

          <c>PING_A</c>

          <c>2</c>

          <c>CONNECT_Q</c>

          <c>3</c>

          <c>CONNECT_A</c>

          <c>4</c>

          <c>TUNNEL_Q</c>

          <c>5</c>

          <c>TUNNEL_A</c>

          <c>6</c>

          <c>STORE_Q</c>

          <c>7</c>

          <c>STORE_A</c>

          <c>8</c>

          <c>FETCH_Q</c>

          <c>9</c>

          <c>FETCH_A</c>

          <c>10</c>

          <c>REMOVE_Q</c>

          <c>11</c>

          <c>REMOVE_A</c>

          <c>12</c>

          <c>FIND_Q</c>

          <c>13</c>

          <c>FIND_A</c>

          <c>14</c>

          <c>JOIN_Q</c>

          <c>15</c>

          <c>JOIN_A</c>

          <c>16</c>

          <c>LEAVE_Q</c>

          <c>17</c>

          <c>LEAVE_A</c>

          <c>18</c>

          <c>UPDATE_Q</c>

          <c>19</c>

          <c>UPDATE_A</c>

          <c>20</c>

          <c>ROUTE_QUERY_Q</c>

          <c>21</c>

          <c>ROUTE_QUERY_A</c>

          <c>22</c>

          <c>RESERVED</c>

          <c>0x8000..0xfffe</c>

          <c>ERROR</c>

          <c>0xffff</c>
        </texttable>
      </section>

      <t>[[TODO - add IANA registration for p2p_enroll SRV and
      p2p_menroll]]</t>

      <section title="Error Codes">
         <t>IANA SHALL create/(has created) a "RELOAD Error Code" Registry.
         Entries in this registry are 16-bit integers denoting error codes.
         [[TODO: Complete this once we decide on error code strategy.</t>
      </section>
    </section>
    <section title="Acknowledgments">
      <t>This draft is a merge of the "REsource LOcation And Discovery
      (RELOAD)" draft by David A. Bryan, Marcia Zangrilli and Bruce B.
      Lowekamp, the "Address Settlement by Peer to Peer" draft by Cullen
      Jennings, Jonathan Rosenberg, and Eric Rescorla, the "Security
      Extensions for RELOAD" draft by Bruce B. Lowekamp and James Deverick,
      the "A Chord-based DHT for Resource Lookup in P2PSIP" by Marcia
      Zangrilli and David A. Bryan, and the Peer-to-Peer Protocol (P2PP) draft
      by Salman A. Baset, Henning Schulzrinne, and Marcin Matuszewski.</t>

      <t>Thanks to the many people who contributed including: Michael Chen,
      TODO - fill in.</t>
    </section>
  </middle>


  <back>
    <references title="Normative References">
      <reference anchor="RFC2119">
        <front>
          <title abbrev="RFC Key Words">Key words for use in RFCs to Indicate
          Requirement Levels</title>

          <author fullname="Scott Bradner" initials="S." surname="Bradner">
            <organization>Harvard University</organization>

            <address>
              <postal>
                <street>1350 Mass. Ave.</street>

                <street>Cambridge</street>

                <street>MA 02138</street>
              </postal>

              <phone>- +1 617 495 3864</phone>

              <email>sob@harvard.edu</email>
            </address>
          </author>

          <date month="March" year="1997" />

          <area>General</area>

          <keyword>keyword</keyword>
        </front>

        <seriesInfo name="BCP" value="14" />

        <seriesInfo name="RFC" value="2119" />

        <format octets="4723" target="ftp://ftp.isi.edu/in-notes/rfc2119.txt"
                type="TXT" />

        <format octets="15905"
                target="http://xml.resource.org/public/rfc/html/rfc2119.html"
                type="HTML" />

        <format octets="5661"
                target="http://xml.resource.org/public/rfc/xml/rfc2119.xml"
                type="XML" />
      </reference>

      <reference anchor="I-D.ietf-mmusic-ice">
        <front>
          <title>Interactive Connectivity Establishment (ICE): A Protocol for
          Network Address Translator (NAT) Traversal for Offer/Answer
          Protocols</title>

          <author fullname="Jonathan Rosenberg" initials="J"
                  surname="Rosenberg">
            <organization></organization>
          </author>

          <date day="12" month="June" year="2007" />

          <abstract>
            <t>This document describes a protocol for Network Address
            Translator (NAT) traversal for multimedia sessions established
            with the offer/ answer model. This protocol is called Interactive
            Connectivity Establishment (ICE). ICE makes use of the Session
            Traversal Utilities for NAT (STUN) protocol, applying its binding
            discovery and relay usages, in addition to defining a new usage
            for checking connectivity between peers. ICE can be used by any
            protocol utilizing the offer/answer model, such as the Session
            Initiation Protocol (SIP).</t>
          </abstract>
        </front>

        <seriesInfo name="Internet-Draft" value="draft-ietf-mmusic-ice-16" />

        <format target="http://www.ietf.org/internet-drafts/draft-ietf-mmusic-ice-16.txt"
                type="TXT" />
      </reference>

      <reference anchor="I-D.ietf-behave-rfc3489bis">
        <front>
          <title>Session Traversal Utilities for (NAT) (STUN)</title>

          <author fullname="Jonathan Rosenberg" initials="J"
                  surname="Rosenberg">
            <organization></organization>
          </author>

          <date day="8" month="March" year="2007" />

          <abstract>
            <t>Session Traversal Utilities for NAT (STUN) is a lightweight
            protocol that serves as a tool for application protocols in
            dealing with NAT traversal. It allows a client to determine the IP
            address and port allocated to them by a NAT and to keep NAT
            bindings open. It can also serve as a check for connectivity
            between a client and a server in the presence of NAT, and for the
            client to detect failure of the server. STUN works with many
            existing NATs, and does not require any special behavior from
            them. As a result, it allows a wide variety of applications to
            work through existing NAT infrastructure.</t>
          </abstract>
        </front>

        <seriesInfo name="Internet-Draft"
                    value="draft-ietf-behave-rfc3489bis-06" />

        <format target="http://www.ietf.org/internet-drafts/draft-ietf-behave-rfc3489bis-06.txt"
                type="TXT" />
      </reference>

      <reference anchor="I-D.ietf-behave-turn">
        <front>
          <title>Obtaining Relay Addresses from Simple Traversal Underneath
          NAT (STUN)</title>

          <author fullname="Jonathan Rosenberg" initials="J"
                  surname="Rosenberg">
            <organization></organization>
          </author>

          <date day="7" month="March" year="2007" />

          <abstract>
            <t>This specification defines a usage of the Simple Traversal
            Underneath NAT (STUN) Protocol for asking the STUN server to relay
            packets towards a client. This usage is useful for elements behind
            NATs whose mapping behavior is address and port dependent. The
            extension purposefully restricts the ways in which the relayed
            address can be used. In particular, it prevents users from running
            general purpose servers from ports obtained from the STUN
            server.</t>
          </abstract>
        </front>

        <seriesInfo name="Internet-Draft" value="draft-ietf-behave-turn-03" />

        <format target="http://www.ietf.org/internet-drafts/draft-ietf-behave-turn-03.txt"
                type="TXT" />
      </reference>

      <reference anchor="I-D.ietf-pkix-cmc-trans">
        <front>
          <title>Certificate Management over CMS (CMC) Transport
          Protocols</title>

          <author fullname="Jim Schaad" initials="J" surname="Schaad">
            <organization></organization>
          </author>

          <author fullname="Michael Myers" initials="M" surname="Myers">
            <organization></organization>
          </author>

          <date day="16" month="May" year="2006" />

          <abstract>
            <t>This document defines a number of transport mechanisms that are
            used to move CMC (Certificate Management over CMS (Cryptographic
            Message Syntax)) messages. The transport mechanisms described in
            this document are: HTTP, file, mail and TCP.</t>
          </abstract>
        </front>

        <seriesInfo name="Internet-Draft" value="draft-ietf-pkix-cmc-trans-05" />

        <format target="http://www.ietf.org/internet-drafts/draft-ietf-pkix-cmc-trans-05.txt"
                type="TXT" />
      </reference>

      <reference anchor="I-D.ietf-pkix-2797-bis">
        <front>
          <title>Certificate Management Messages over CMS</title>

          <author fullname="Michael Myers" initials="M" surname="Myers">
            <organization></organization>
          </author>

          <author fullname="Jim Schaad" initials="J" surname="Schaad">
            <organization></organization>
          </author>

          <date day="3" month="March" year="2006" />

          <abstract>
            <t>This document defines the base syntax for CMC, a Certificate
            Management protocol using CMS (Cryptographic Message Syntax). This
            protocol addresses two immediate needs within the Internet PKI
            community: 1. The need for an interface to public key
            certification products and services based on CMS and PKCS #10
            (Public Key Cryptography 2. The need in S/MIME (Secure MIME) for a
            certificate enrollment protocol for DSA-signed certificates with
            Diffie-Hellman public keys. CMC also requires the use of the
            transport document and the requirements usage document along with
            this document for a full definition.</t>
          </abstract>
        </front>

        <seriesInfo name="Internet-Draft" value="draft-ietf-pkix-2797-bis-04" />

        <format target="http://www.ietf.org/internet-drafts/draft-ietf-pkix-2797-bis-04.txt"
                type="TXT" />
      </reference>

      <reference anchor="RFC4279">
        <front>
          <title>Pre-Shared Key Ciphersuites for Transport Layer Security
          (TLS)</title>

          <author fullname="P. Eronen" initials="P." surname="Eronen">
            <organization></organization>
          </author>

          <author fullname="H. Tschofenig" initials="H." surname="Tschofenig">
            <organization></organization>
          </author>

          <date month="December" year="2005" />

          <abstract>
            <t>This document specifies three sets of new ciphersuites for the
            Transport Layer Security (TLS) protocol to support authentication
            based on pre-shared keys (PSKs). These pre-shared keys are
            symmetric keys, shared in advance among the communicating parties.
            The first set of ciphersuites uses only symmetric key operations
            for authentication. The second set uses a Diffie-Hellman exchange
            authenticated with a pre-shared key, and the third set combines
            public key authentication of the server with pre-shared key
            authentication of the client. [STANDARDS TRACK]</t>
          </abstract>
        </front>

        <seriesInfo name="RFC" value="4279" />

        <format octets="32160" target="ftp://ftp.isi.edu/in-notes/rfc4279.txt"
                type="TXT" />
      </reference>

      <reference anchor="I-D.ietf-tls-srp">
        <front>
          <title>Using SRP for TLS Authentication</title>

          <author fullname="Dave Taylor" initials="D" surname="Taylor">
            <organization></organization>
          </author>

          <date day="14" month="June" year="2007" />

          <abstract>
            <t>This memo presents a technique for using the Secure Remote
            Password protocol as an authentication method for the Transport
            Layer Security protocol.</t>
          </abstract>
        </front>

        <seriesInfo name="Internet-Draft" value="draft-ietf-tls-srp-14" />

        <format target="http://www.ietf.org/internet-drafts/draft-ietf-tls-srp-14.txt"
                type="TXT" />
      </reference>

      <reference anchor="I-D.ietf-mmusic-ice-tcp">
        <front>
          <title>TCP Candidates with Interactive Connectivity Establishment
          (ICE</title>

          <author fullname="Jonathan  Rosenberg" initials="J"
                  surname="Rosenberg">
            <organization></organization>
          </author>

          <date day="8" month="March" year="2007" />

          <abstract>
            <t>Interactive Connectivity Establishment (ICE) defines a
            mechanism for NAT traversal for multimedia communication protocols
            based on the offer/answer model of session negotiation. ICE works
            by providing a set of candidate transport addresses for each media
            stream, which are then validated with peer-to-peer connectivity
            checks based on Simple Traversal of UDP over NAT (STUN). ICE
            provides a general framework for describing alternates, but only
            defines UDP-based transport protocols. This specification extends
            ICE to TCP-based media, including the ability to offer a mix of
            TCP and UDP-based candidates for a single stream.</t>
          </abstract>
        </front>

        <seriesInfo name="Internet-Draft" value="draft-ietf-mmusic-ice-tcp-03" />

        <format target="http://www.ietf.org/internet-drafts/draft-ietf-mmusic-ice-tcp-03.txt"
                type="TXT" />
      </reference>

      <reference anchor="RFC3261">
        <front>
          <title>SIP: Session Initiation Protocol</title>

          <author fullname="J. Rosenberg" initials="J." surname="Rosenberg">
            <organization></organization>
          </author>

          <author fullname="H. Schulzrinne" initials="H."
                  surname="Schulzrinne">
            <organization></organization>
          </author>

          <author fullname="G. Camarillo" initials="G." surname="Camarillo">
            <organization></organization>
          </author>

          <author fullname="A. Johnston" initials="A." surname="Johnston">
            <organization></organization>
          </author>

          <author fullname="J. Peterson" initials="J." surname="Peterson">
            <organization></organization>
          </author>

          <date month="June" year="2002" />
        </front>

        <seriesInfo name="RFC" value="3261" />

        <format octets="647976"
                target="ftp://ftp.isi.edu/in-notes/rfc3261.txt" type="TXT" />
      </reference>

      <reference anchor="RFC3263">
        <front>
          <title>Session Initiation Protocol (SIP): Locating SIP
          Servers</title>

          <author fullname="J. Rosenberg" initials="J." surname="Rosenberg">
            <organization></organization>
          </author>

          <author fullname="H. Schulzrinne" initials="H."
                  surname="Schulzrinne">
            <organization></organization>
          </author>

          <date month="June" year="2002" />

          <abstract>
            <t>The Session Initiation Protocol (SIP) uses DNS procedures to
            allow a client to resolve a SIP Uniform Resource Identifier (URI)
            into the IP address, port, and transport protocol of the next hop
            to contact. It also uses DNS to allow a server to send a response
            to a backup client if the primary client has failed. This document
            describes those DNS procedures in detail. [STANDARDS TRACK]</t>
          </abstract>
        </front>

        <seriesInfo name="RFC" value="3263" />

        <format octets="42310" target="ftp://ftp.isi.edu/in-notes/rfc3263.txt"
                type="TXT" />
      </reference>

      <reference anchor="RFC4347">
        <front>
          <title>Datagram Transport Layer Security</title>

          <author fullname="E. Rescorla" initials="E." surname="Rescorla">
            <organization></organization>
          </author>

          <author fullname="N. Modadugu" initials="N." surname="Modadugu">
            <organization></organization>
          </author>

          <date month="April" year="2006" />

          <abstract>
            <t>This document specifies Version 1.0 of the Datagram Transport
            Layer Security (DTLS) protocol. The DTLS protocol provides
            communications privacy for datagram protocols. The protocol allows
            client/server applications to communicate in a way that is
            designed to prevent eavesdropping, tampering, or message forgery.
            The DTLS protocol is based on the Transport Layer Security (TLS)
            protocol and provides equivalent security guarantees. Datagram
            semantics of the underlying transport are preserved by the DTLS
            protocol. [STANDARDS TRACK]</t>
          </abstract>
        </front>

        <seriesInfo name="RFC" value="4347" />

        <format octets="56014" target="ftp://ftp.isi.edu/in-notes/rfc4347.txt"
                type="TXT" />
      </reference>

      <reference anchor="RFC4828">
        <front>
          <title>TCP Friendly Rate Control (TFRC): The Small-Packet (SP)
          Variant</title>

          <author fullname="S. Floyd" initials="S." surname="Floyd">
            <organization></organization>
          </author>

          <author fullname="E. Kohler" initials="E." surname="Kohler">
            <organization></organization>
          </author>

          <date month="April" year="2007" />

          <abstract>
            <t>This document proposes a mechanism for further experimentation,
            but not for widespread deployment at this time in the global
            Internet.&lt;/t&gt;&lt;t&gt; TCP-Friendly Rate Control (TFRC) is a
            congestion control mechanism for unicast flows operating in a
            best-effort Internet environment (RFC 3448). TFRC was intended for
            applications that use a fixed packet size, and was designed to be
            reasonably fair when competing for bandwidth with TCP connections
            using the same packet size. This document proposes TFRC-SP, a
            Small-Packet (SP) variant of TFRC, that is designed for
            applications that send small packets. The design goal for TFRC-SP
            is to achieve the same bandwidth in bps (bits per second) as a TCP
            flow using packets of up to 1500 bytes. TFRC-SP enforces a minimum
            interval of 10 ms between data packets to prevent a single flow
            from sending small packets arbitrarily
            frequently.&lt;/t&gt;&lt;t&gt; Flows using TFRC-SP compete
            reasonably fairly with large-packet TCP and TFRC flows in
            environments where large-packet flows and small-packet flows
            experience similar packet drop rates. However, in environments
            where small-packet flows experience lower packet drop rates than
            large-packet flows (e.g., with Drop-Tail queues in units of
            bytes), TFRC-SP can receive considerably more than its share of
            the bandwidth. This memo defines an Experimental Protocol for the
            Internet community.</t>
          </abstract>
        </front>

        <seriesInfo name="RFC" value="4828" />

        <format octets="116808"
                target="ftp://ftp.isi.edu/in-notes/rfc4828.txt" type="TXT" />
      </reference>
    </references>

    <references title="Informative References">
      <reference anchor="I-D.ietf-behave-tcp">
        <front>
          <title>NAT Behavioral Requirements for TCP</title>

          <author fullname="Saikat Guha" initials="S" surname="Guha">
            <organization></organization>
          </author>

          <date day="30" month="April" year="2007" />

          <abstract>
            <t>This document defines a set of requirements for NATs that
            handle TCP that would allow many applications, such as
            peer-to-peer applications and on-line games, to work consistently.
            Developing NATs that meet this set of requirements will greatly
            increase the likelihood that these applications will function
            properly.</t>
          </abstract>
        </front>

        <seriesInfo name="Internet-Draft" value="draft-ietf-behave-tcp-07" />

        <format target="http://www.ietf.org/internet-drafts/draft-ietf-behave-tcp-07.txt"
                type="TXT" />
      </reference>

      <reference anchor="I-D.ietf-p2psip-concepts">
        <front>
          <title>Concepts and Terminology for Peer to Peer SIP</title>

          <author fullname="David Bryan" initials="D" surname="Bryan">
            <organization></organization>
          </author>

          <date day="3" month="July" year="2007" />

          <abstract>
            <t>This document defines concepts and terminology for use of the
            Session Initiation Protocol in a peer-to-peer environment where
            the traditional proxy-registrar and message routing functions are
            replaced by a distributed mechanism that might be implemented
            using a distributed hash table or other distributed data mechanism
            with similar external properties. This document includes a
            high-level view of the functional relationships between the
            network elements defined herein, a conceptual model of operations,
            and an outline of the related open problems being addressed by the
            P2PSIP working group. As this document matures, it is expected to
            define the general framework for P2PSIP.</t>
          </abstract>
        </front>

        <seriesInfo name="Internet-Draft"
                    value="draft-ietf-p2psip-concepts-00" />

        <format target="http://www.ietf.org/internet-drafts/draft-ietf-p2psip-concepts-00.txt"
                type="TXT" />
      </reference>

      <reference anchor="RFC4145">
        <front>
          <title>TCP-Based Media Transport in the Session Description Protocol
          (SDP)</title>

          <author fullname="D. Yon" initials="D." surname="Yon">
            <organization></organization>
          </author>

          <author fullname="G. Camarillo" initials="G." surname="Camarillo">
            <organization></organization>
          </author>

          <date month="September" year="2005" />

          <abstract>
            <t>This document describes how to express media transport over TCP
            using the Session Description Protocol (SDP). It defines the SDP
            'TCP' protocol identifier, the SDP 'setup' attribute, which
            describes the connection setup procedure, and the SDP 'connection'
            attribute, which handles connection reestablishment. [STANDARDS
            TRACK]</t>
          </abstract>
        </front>

        <seriesInfo name="RFC" value="4145" />

        <format octets="30225" target="ftp://ftp.isi.edu/in-notes/rfc4145.txt"
                type="TXT" />
      </reference>

      <reference anchor="RFC4572">
        <front>
          <title>Connection-Oriented Media Transport over the Transport Layer
          Security (TLS) Protocol in the Session Description Protocol
          (SDP)</title>

          <author fullname="J. Lennox" initials="J." surname="Lennox">
            <organization></organization>
          </author>

          <date month="July" year="2006" />

          <abstract>
            <t>This document specifies how to establish secure
            connection-oriented media transport sessions over the Transport
            Layer Security (TLS) protocol using the Session Description
            Protocol (SDP). It defines a new SDP protocol identifier,
            'TCP/TLS'. It also defines the syntax and semantics for an SDP
            'fingerprint' attribute that identifies the certificate that will
            be presented for the TLS session. This mechanism allows media
            transport over TLS connections to be established securely, so long
            as the integrity of session descriptions is
            assured.&lt;/t&gt;&lt;t&gt; This document extends and updates RFC
            4145. [STANDARDS TRACK]</t>
          </abstract>
        </front>

        <seriesInfo name="RFC" value="4572" />

        <format octets="38658" target="ftp://ftp.isi.edu/in-notes/rfc4572.txt"
                type="TXT" />
      </reference>

      <reference anchor="RFC2617">
        <front>
          <title abbrev="HTTP Authentication">HTTP Authentication: Basic and
          Digest Access Authentication</title>

          <author fullname="John Franks" initials="J." surname="Franks">
            <organization>Northwestern University, Department of
            Mathematics</organization>

            <address>
              <postal>
                <street>Northwestern University</street>

                <city>Evanston</city>

                <region>IL</region>

                <code>60208-2730</code>

                <country>USA</country>
              </postal>

              <email>john@math.nwu.edu</email>
            </address>
          </author>

          <author fullname="Phillip M. Hallam-Baker" initials="P.M."
                  surname="Hallam-Baker">
            <organization>Verisign Inc.</organization>

            <address>
              <postal>
                <street>301 Edgewater Place</street>

                <street>Suite 210</street>

                <city>Wakefield</city>

                <region>MA</region>

                <code>01880</code>

                <country>USA</country>
              </postal>

              <email>pbaker@verisign.com</email>
            </address>
          </author>

          <author fullname="Jeffery L. Hostetler" initials="J.L."
                  surname="Hostetler">
            <organization>AbiSource, Inc.</organization>

            <address>
              <postal>
                <street>6 Dunlap Court</street>

                <city>Savoy</city>

                <region>IL</region>

                <code>61874</code>

                <country>USA</country>
              </postal>

              <email>jeff@AbiSource.com</email>
            </address>
          </author>

          <author fullname="Scott D. Lawrence" initials="S.D."
                  surname="Lawrence">
            <organization>Agranat Systems, Inc.</organization>

            <address>
              <postal>
                <street>5 Clocktower Place</street>

                <street>Suite 400</street>

                <city>Maynard</city>

                <region>MA</region>

                <code>01754</code>

                <country>USA</country>
              </postal>

              <email>lawrence@agranat.com</email>
            </address>
          </author>

          <author fullname="Paul J. Leach" initials="P.J." surname="Leach">
            <organization>Microsoft Corporation</organization>

            <address>
              <postal>
                <street>1 Microsoft Way</street>

                <city>Redmond</city>

                <region>WA</region>

                <code>98052</code>

                <country>USA</country>
              </postal>

              <email>paulle@microsoft.com</email>
            </address>
          </author>

          <date month="June" year="1999" />

          <abstract>
            <t>"HTTP/1.0", includes the specification for a Basic Access
            Authentication scheme. This scheme is not considered to be a
            secure method of user authentication (unless used in conjunction
            with some external secure system such as SSL ), as the user name
            and password are passed over the network as cleartext.</t>

            <t>This document also provides the specification for HTTP's
            authentication framework, the original Basic authentication scheme
            and a scheme based on cryptographic hashes, referred to as "Digest
            Access Authentication". It is therefore also intended to serve as
            a replacement for RFC 2069 . Some optional elements specified by
            RFC 2069 have been removed from this specification due to problems
            found since its publication; other new elements have been added
            for compatibility, those new elements have been made optional, but
            are strongly recommended.</t>

            <t>Like Basic, Digest access authentication verifies that both
            parties to a communication know a shared secret (a password);
            unlike Basic, this verification can be done without sending the
            password in the clear, which is Basic's biggest weakness. As with
            most other authentication protocols, the greatest sources of risks
            are usually found not in the core protocol itself but in policies
            and procedures surrounding its use.</t>
          </abstract>
        </front>

        <seriesInfo name="RFC" value="2617" />

        <format octets="77638" target="ftp://ftp.isi.edu/in-notes/rfc2617.txt"
                type="TXT" />

        <format octets="114842"
                target="http://xml.resource.org/public/rfc/html/rfc2617.html"
                type="HTML" />

        <format octets="87592"
                target="http://xml.resource.org/public/rfc/xml/rfc2617.xml"
                type="XML" />
      </reference>

      <reference anchor="RFC2818">
        <front>
          <title>HTTP Over TLS</title>

          <author fullname="E. Rescorla" initials="E." surname="Rescorla">
            <organization></organization>
          </author>

          <date month="May" year="2000" />

          <abstract>
            <t>This memo describes how to use Transport Layer Security (TLS)
            to secure Hypertext Transfer Protocol (HTTP) connections over the
            Internet. This memo provides information for the Internet
            community.</t>
          </abstract>
        </front>

        <seriesInfo name="RFC" value="2818" />

        <format octets="15170" target="ftp://ftp.isi.edu/in-notes/rfc2818.txt"
                type="TXT" />
      </reference>

      <reference anchor="RFC4086">
        <front>
          <title>Randomness Requirements for Security</title>

          <author fullname="D. Eastlake" initials="D." surname="Eastlake">
            <organization></organization>
          </author>

          <author fullname="J. Schiller" initials="J." surname="Schiller">
            <organization></organization>
          </author>

          <author fullname="S. Crocker" initials="S." surname="Crocker">
            <organization></organization>
          </author>

          <date month="June" year="2005" />

          <abstract>
            <t>Security systems are built on strong cryptographic algorithms
            that foil pattern analysis attempts. However, the security of
            these systems is dependent on generating secret quantities for
            passwords, cryptographic keys, and similar quantities. The use of
            pseudo-random processes to generate secret quantities can result
            in pseudo-security. A sophisticated attacker may find it easier to
            reproduce the environment that produced the secret quantities and
            to search the resulting small set of possibilities than to locate
            the quantities in the whole of the potential number
            space.&lt;/t&gt;&lt;t&gt; Choosing random quantities to foil a
            resourceful and motivated adversary is surprisingly difficult.
            This document points out many pitfalls in using poor entropy
            sources or traditional pseudo-random number generation techniques
            for generating such quantities. It recommends the use of truly
            random hardware techniques and shows that the existing hardware on
            many systems can be used for this purpose. It provides suggestions
            to ameliorate the problem when a hardware solution is not
            available, and it gives examples of how large such quantities need
            to be for some applications. This document specifies an Internet
            Best Current Practices for the Internet Community, and requests
            discussion and suggestions for improvements.</t>
          </abstract>
        </front>

        <seriesInfo name="BCP" value="106" />

        <seriesInfo name="RFC" value="4086" />

        <format octets="114321"
                target="ftp://ftp.isi.edu/in-notes/rfc4086.txt" type="TXT" />
      </reference>

      <reference anchor="RFC3280">
        <front>
          <title>Internet X.509 Public Key Infrastructure Certificate and
          Certificate Revocation List (CRL) Profile</title>

          <author fullname="R. Housley" initials="R." surname="Housley">
            <organization></organization>
          </author>

          <author fullname="W. Polk" initials="W." surname="Polk">
            <organization></organization>
          </author>

          <author fullname="W. Ford" initials="W." surname="Ford">
            <organization></organization>
          </author>

          <author fullname="D. Solo" initials="D." surname="Solo">
            <organization></organization>
          </author>

          <date month="April" year="2002" />

          <abstract>
            <t>This memo profiles the X.509 v3 certificate and X.509 v2
            Certificate Revocation List (CRL) for use in the Internet.
            [STANDARDS TRACK]</t>
          </abstract>
        </front>

        <seriesInfo name="RFC" value="3280" />

        <format octets="295556"
                target="ftp://ftp.isi.edu/in-notes/rfc3280.txt" type="TXT" />
      </reference>

      <!--
      <reference anchor="sosimple">
        <front>
          <title>SOSIMPLE: A Serverless, Standards-based, P2P SIP
          Communication System</title>

          <author fullname="David A. Bryan" initials="D. A." surname="Bryan">
            <organization>College of William and Mary</organization>
          </author>

          <author fullname="Cullen Jennings" initials="C." surname="Jennings">
            <organization>Cisco Systems</organization>
          </author>

          <author fullname="Bruce B. Lowekamp" initials="B. B."
                  surname="Lowekamp">
            <organization>College of William and Mary</organization>
          </author>

          <date month="June" year="2005" />
        </front>

        <seriesInfo name="Proceedings of the 2005 International Workshop on Advanced Architectures and Algorithms for Internet Delivery and Applications (AAA-IDEA)"
                    value="'05" />

        <format target="http://www.cs.wm.edu/~bryan/pubs/bryan-AAA-IDEA2005.pdf"
                type="PDF" />
      </reference>

      <reference anchor="I-D.bryan-p2psip-dsip">
        <front>
          <title>dSIP: A P2P Approach to SIP Registration and Resource
          Location</title>

          <author fullname="D. Bryan" initials="D." surname="Bryan">
            <organization></organization>
          </author>

          <author fullname="B. Lowekamp" initials="B." surname="Lowekamp">
            <organization></organization>
          </author>

          <author fullname="C. Jennings" initials="C." surname="Jennings">
            <organization></organization>
          </author>

          <date month="February" year="2007" />
        </front>

        <seriesInfo name="Internet Draft" value="draft-bryan-p2psip-dsip-00" />
      </reference>
-->

      <reference anchor="Sybil">
        <front>
          <title>The Sybil Attack</title>

          <author fullname="John R. Douceur" initials="J. R."
                  surname="Douceur">
            <organization>Microsoft Research</organization>
          </author>

          <date month="March" year="2002" />
        </front>

        <seriesInfo name="IPTPS" value="02" />

        <format target="http://www.cs.rice.edu/Conferences/IPTPS02/101.pdf"
                type="PDF" />
      </reference>

      <reference anchor="Eclipse">
        <front>
          <title>Eclipse Attacks on Overlay Networks: Threats and
          Defenses</title>

          <author fullname="Atul Singh" initials="A." surname="Singh">
            <organization></organization>
          </author>

          <author fullname="Tsuen-Wan Ngan" initials="T. W." surname="Ngan">
            <organization></organization>
          </author>

          <author fullname="Peter Druschel" initials="T." surname="Druschel">
            <organization></organization>
          </author>

          <author fullname="Dan S. Wallach" initials="D. S." surname="Wallach">
            <organization></organization>
          </author>

          <date month="April" year="2006" />
        </front>

        <seriesInfo name="INFOCOM" value="2006" />
      </reference>

      <reference anchor="I-D.cheshire-dnsext-multicastdns">
        <front>
          <title>Multicast DNS</title>

          <author fullname="Stuart Cheshire" initials="S" surname="Cheshire">
            <organization></organization>
          </author>

          <author fullname="Marc Krochmal" initials="M" surname="Krochmal">
            <organization></organization>
          </author>

          <date day="25" month="August" year="2006" />
        </front>

        <seriesInfo name="Internet-Draft"
                    value="draft-cheshire-dnsext-multicastdns-06" />

        <format target="http://www.ietf.org/internet-drafts/draft-cheshire-dnsext-multicastdns-06.txt"
                type="TXT" />
      </reference>

      <reference anchor="I-D.cheshire-dnsext-dns-sd">
        <front>
          <title>DNS-Based Service Discovery</title>

          <author fullname="Marc Krochmal" initials="M" surname="Krochmal">
            <organization></organization>
          </author>

          <author fullname="Stuart Cheshire" initials="S" surname="Cheshire">
            <organization></organization>
          </author>

          <date day="28" month="August" year="2006" />

          <abstract>
            <t>This document describes a convention for naming and structuring
            DNS resource records. Given a type of service that a client is
            looking for, and a domain in which the client is looking for that
            service, this convention allows clients to discover a list of
            named instances of that desired service, using only standard DNS
            queries. In short, this is referred to as DNS-based Service
            Discovery, or DNS-SD.</t>
          </abstract>
        </front>

        <seriesInfo name="Internet-Draft"
                    value="draft-cheshire-dnsext-dns-sd-04" />

        <format target="http://www.ietf.org/internet-drafts/draft-cheshire-dnsext-dns-sd-04.txt"
                type="TXT" />
      </reference>

      <!--
<reference anchor='I-D.jennings-p2psip-security'>
<front>
<title>Security Mechanisms for Peer to Peer SIP</title>

<author initials='C' surname='Jennings' fullname='Cullen Jennings'>
    <organization />
</author>

<date month='February' day='27' year='2007' />

<abstract><t>This document describes an overview of some security mechanisms for P2P SIP. Specifically it discusses mechanisms that can be used to secure the stored data and the routing in the distributed storage. This draft is an very early draft to outline the possible solution space and far more details would be needed. This work is being discussed on the p2psip@ietf.org mailing list.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-jennings-p2psip-security-00' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-jennings-p2psip-security-00.txt' />
</reference>
-->

      <reference anchor="I-D.matthews-p2psip-bootstrap-mechanisms">
        <front>
          <title>Bootstrap Mechanisms for P2PSIP</title>

          <author fullname="Eric Cooper" initials="E" surname="Cooper">
            <organization></organization>
          </author>

          <date day="26" month="February" year="2007" />

          <abstract>
            <t>This document describes mechanisms that a peer can use to
            locate and establish a Peer Protocol connection to an admitting
            peer in order to join an overlay network. In the first mechanism,
            the joining peer uses multicast to locate a bootstrap peer; in the
            second, the node uses one or more bootstrap servers to locate a
            bootstrap peer; in both cases, the bootstrap peer then proxies the
            request by the joining peer on to the admitting peer. Each
            mechanism has its advantages and disadvantages, and a node can
            utilize both.</t>
          </abstract>
        </front>

        <seriesInfo name="Internet-Draft"
                    value="draft-matthews-p2psip-bootstrap-mechanisms-00" />

        <format target="http://www.ietf.org/internet-drafts/draft-matthews-p2psip-bootstrap-mechanisms-00.txt"
                type="TXT" />
      </reference>

      <reference anchor="I-D.garcia-p2psip-dns-sd-bootstrapping">
        <front>
          <title>P2PSIP bootstrapping using DNS-SD</title>

          <author fullname="Gustavo Garcia" initials="G" surname="Garcia">
            <organization></organization>
          </author>

          <date day="25" month="October" year="2007" />

          <abstract>
            <t>This document describes a DNS-based bootstrap mechanism to
            discover the initial peer or peers needed to join a P2PSIP
            Overlay. The document specifies the use of DNS Service Discovery
            (DNS-SD) and the format of the required resource records to
            support the discovery of P2PSIP peers. This mechanism can be
            applied in scenarios with DNS servers or combined with multicast
            DNS to fulfill different proposed P2PSIP use cases.</t>
          </abstract>
        </front>

        <seriesInfo name="Internet-Draft"
                    value="draft-garcia-p2psip-dns-sd-bootstrapping-00" />

        <format target="http://www.ietf.org/internet-drafts/draft-garcia-p2psip-dns-sd-bootstrapping-00.txt"
                type="TXT" />
      </reference>

      <reference anchor="I-D.camarillo-hip-bone">
        <front>
          <title>HIP BONE: Host Identity Protocol (HIP) Based Overlay
          Networking Environment</title>

          <author fullname="Gonzalo Camarillo" initials="G"
                  surname="Camarillo">
            <organization></organization>
          </author>

          <author fullname="Pekka Nikander" initials="P" surname="Nikander">
            <organization></organization>
          </author>

          <author fullname="Jani Hautakorpi" initials="J" surname="Hautakorpi">
            <organization></organization>
          </author>

          <date day="21" month="December" year="2007" />

          <abstract>
            <t>This document specifies a framework to build HIP (Host Identity
            Protocol)-based overlay networks. This framework uses HIP to
            perform connection management. Other functions, such as data
            storage and retrieval or overlay maintenance, are implemented
            using protocols other than HIP. These protocols are loosely
            referred to as peer protocols.</t>
          </abstract>
        </front>

        <seriesInfo name="Internet-Draft" value="draft-camarillo-hip-bone-00" />

        <format target="http://www.ietf.org/internet-drafts/draft-camarillo-hip-bone-00.txt"
                type="TXT" />
      </reference>

      <reference anchor='I-D.pascual-p2psip-clients'>
	<front>
	  <title>P2PSIP Clients</title>

	  <author initials='V' surname='Pascual' fullname='Victor Pascual'>
	    <organization />
	  </author>

	  <author initials='M' surname='Matuszewski' fullname='Marchin Matuszewski'>
	    <organization />
	  </author>

	  <author initials='E' surname='Shim' fullname='Eunsoo Shim'>
	    <organization />
	  </author>

	  <author initials='H' surname='Zhang' fullname='Hewen  Zhang'>
	    <organization />
	  </author>

	  <author initials='S' surname='Yongchao' fullname='Song Yongchao'>
	    <organization />
	  </author>

	  <date month='February' day='25' year='2008' />

	  <abstract><t>This document describes why and when some devices would better be a Client rather than a Peer.  The purpose of this document is to facilitate the discussion and understanding about the Client node type.</t></abstract>

	</front>

	<seriesInfo name='Internet-Draft' value='draft-pascual-p2psip-clients-01' />
	<format type='TXT'
		target='http://www.ietf.org/internet-drafts/draft-pascual-p2psip-clients-01.txt' />
      </reference>

      <reference anchor='RFC4787'>

	<front>
	  <title>Network Address Translation (NAT) Behavioral Requirements for Unicast UDP</title>
	  <author initials='F.' surname='Audet' fullname='F. Audet'>
	  <organization /></author>
	  <author initials='C.' surname='Jennings' fullname='C. Jennings'>
	  <organization /></author>
	  <date year='2007' month='January' />
	  <abstract>
	<t>This document defines basic terminology for describing different types of Network Address Translation (NAT) behavior when handling Unicast UDP and also defines a set of requirements that would allow many applications, such as multimedia communications or online gaming, to work consistently.  Developing NATs that meet this set of requirements will greatly increase the likelihood that these applications will function properly.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract></front>

	<seriesInfo name='BCP' value='127' />
	<seriesInfo name='RFC' value='4787' />
	<format type='TXT' octets='68693' target='ftp://ftp.isi.edu/in-notes/rfc4787.txt' />
      </reference>

      <reference anchor='I-D.jiang-p2psip-sep'>
	<front>
	  <title>Service Extensible P2P Peer Protocol</title>

	  <author initials='X' surname='Jiang' fullname='XingFeng Jiang'>
	    <organization />
	  </author>

	  <author initials='H' surname='Zhang' fullname='Hewen Zhang'>
	    <organization />
	  </author>

	  <date month='February' day='22' year='2008' />

	  <abstract><t>This document describes the Service Extensible Protocol (SEP), which is the peer protocol spoken between P2PSIP Overlay peers to share information and organize the P2PSIP Overlay Network.  SEP uses a flexible forwarding mechanism to avoid congestion in the Overlay.  It also proposes a general service discovery method and a built-in NATtraversal mechanism. By using these methods, SEP tries to improve the success rate and reduce the latency of the transaction.</t></abstract>

	</front>

	<seriesInfo name='Internet-Draft' value='draft-jiang-p2psip-sep-01' />
	<format type='TXT'
		target='http://www.ietf.org/internet-drafts/draft-jiang-p2psip-sep-01.txt' />
      </reference>

    </references>
  </back>
</rfc>
