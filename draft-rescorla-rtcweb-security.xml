<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC3261 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3261.xml">
<!ENTITY I-D.ietf-avt-dtls-srtp SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-avt-dtls-srtp">
<!ENTITY I-D.abarth-origin SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.abarth-origin">
]>
<?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc strict="yes" ?>
<?rfc compact="yes" ?>
<?rfc sortrefs="yes" ?>
<?rfc colonspace="yes" ?>
<?rfc rfcedstyle="no" ?>
<!-- Don't change this. It breaks stuff -->
<?rfc tocdepth="4"?>
<rfc category="std" docName="draft-rescorla-rtcweb-security-00"
     ipr="pre5378Trust200902">
  <front>
    <title abbrev="RTC-Web Security">Security Considerations for RTC-Web</title>

    <author fullname="Eric Rescorla" initials="E.K." surname="Rescorla">
      <organization>RTFM, Inc.</organization>

      <address>
        <postal>
          <street>2064 Edgewood Drive</street>

          <city>Palo Alto</city>

          <region>CA</region>

          <code>94303</code>

          <country>USA</country>
        </postal>

        <phone>+1 650 678 2350</phone>

        <email>ekr@rtfm.com</email>
      </address>
    </author>

    <date day="30" month="May" year="2011" />

    <area>RAI</area>

    <workgroup>RTC-Web</workgroup>

    <abstract>
      <t>
	The Real-Time Communications on the Web (RTC-Web) working group is tasked with
	standardizing protocols for real-time communications between Web browsers. The
	two major use cases for RTC-Web technology are real-time audio and/or video calls
	and direct data transfer. Unlike most conventional real-time systems
	(e.g., SIP-based soft phones) RTC-Web communications are directly controlled
	by some Web server, which poses new security challenges.
	For instance, a Web browser might expose a JavaScript
	API which allows a server to place a video call. Unrestricted access to such
	an API would allow any site which a user visited to "bug" a user's computer,
	capturing any activity which passed in front of their camera. This document
	defines the RTC-Web threat model and defines an architecture which provides
	security within that threat model.
      </t>
    </abstract>

    <note title="Legal">
      <t>THIS DOCUMENT AND THE INFORMATION CONTAINED THEREIN ARE PROVIDED ON
      AN &ldquo;AS IS&rdquo; BASIS AND THE CONTRIBUTOR, THE ORGANIZATION
      HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE
      IETF TRUST, AND THE INTERNET ENGINEERING TASK FORCE, DISCLAIM ALL
      WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY
      WARRANTY THAT THE USE OF THE INFORMATION THEREIN WILL NOT INFRINGE ANY
      RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A
      PARTICULAR PURPOSE.</t>
    </note>
  </front>

  <middle>
    <section title="Introduction" anchor="sec.introduction">
      <t>
	The Real-Time Communications on the Web (RTC-Web) working group is tasked with
	standardizing protocols for real-time communications between Web browsers. The
	two major use cases for RTC-Web technology are real-time audio and/or video calls
	and direct data transfer. Unlike most conventional real-time systems, 
	(e.g., SIP-based<xref target="RFC3261"></xref> soft phones) RTC-Web communications are directly controlled
	by some Web server. A simple case is shown below.
      </t>

      <figure title="A simple RTC-Web system" anchor="fig.simple">
	<artwork><![CDATA[
                            +----------------+
                            |                |
                            |   Web Server   |
                            |                |
                            +----------------+
                                ^        ^
                               /          \
                       HTTP   /            \   HTTP
                             /              \                               
                            /                \                               
                           v                  v
                        JS API              JS API
                  +-----------+            +-----------+
                  |           |    Media   |           |
                  |  Browser  |<---------->|  Browser  |
                  |           |            |           |                  
                  +-----------+            +-----------+
 	]]></artwork>
      </figure>
      <t>
	In the system shown in <xref target="fig.simple"/>, Alice and Bob both have
	RTC-Web enabled browsers and they visit some Web server which operates a
	calling service. Each of their browsers exposes standardized JavaScript calling APIs
	which are used by the Web server to set up a call between Alice and Bob.
	While this system is topologically similar to a conventional SIP-based
	system (with the Web server acting as the signaling service and browsers
	acting as softphones), control has moved to the central Web server;
	the browser simply provides API points that are used by the calling service.
	As with any Web application, the Web server can move logic between 
	the server and JavaScript in the browser, but regardless of where the 
	code is executing, it is ultimately under control of the server.
      </t>
      <t>
	It should be immediately apparent that this type of system poses new
	security challenges beyond those of a conventional VoIP system. In particular,
	it needs to contend with malicious calling services.
	For example, if the calling service
	can cause the browser to make a call at any time to any callee of its
	choice, then this facility can be used to bug a user's computer without
	their knowledge, simply by placing a call to some recording service.
	More subtly, if the exposed APIs allow the server to instruct the
	browser to send arbitrary content, then they can be used to bypass
	firewalls or mount denial of service attacks. Any successful system
	will need to be resistant to this and other attacks.
      </t>
    </section>
    <section anchor="sec-term" title="Terminology">
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
      document are to be interpreted as described in <xref
      target="RFC2119">RFC 2119</xref>.</t>
    </section>

    <section title="The Browser Threat Model" anchor="sec.web-security">
      <t>
	The security requirements for RTC-Web follow directly from the 
	requirement that the browser's job is to protect the user. 
	Huang et al. [REF] summarize the core browser security guarantee as:
      </t>
      <t>
	<list style="hanging">
	  <t>
	    Users can safely visit arbitrary web sites and execute scripts provided by those sites.
	  </t>
	</list>
      </t>
      <t></t>
      <t>
	It is important to realize that this includes sites hosting arbitrary malicious
	scripts. The motivation for this requirement is simple: it is trivial for attackers
	to divert users to sites of their choice. For instance, an attacker can purchase
	display advertisements which direct the user (either automatically or via user
	clicking) to their site, at which point the browser will execute the attacker's
	scripts. Thus, it is important that it be safe to view arbitrarily malicious pages.
	Of course, browsers inevitably have bugs which cause them to fall short of this
	goal, but any new RTC-Web functionality must be designed with the intent to 
	meet this standard. The remainder of this section provides more background 
	on the existing Web security model.
      </t>
      <t>
	In this model, then, the browser acts as a TRUSTED COMPUTING BASE (TCB) both
	from the user's perspective and to some extent from the server's. While HTML
	and JS provided by the server can cause the browser to execute a variety of
	actions, those scripts operate in a sandbox that isolates them both from
	the user's computer and from each other, as detailed below.
      </t>
      <section title="Access to Local Resources" anchor="sec.resources">
	<t>
	  While the browser has access to local resources such as keying material,
	  files, the camera and the microphone, it strictly limits or forbids web
	  servers from accessing those same resources. For instance, while it is possible
	  to produce an HTML form which will allow file upload, a script cannot do
	  so without user consent and in fact cannot even suggest a specific file
	  (e.g., /etc/passwd); the user must explicitly select the file and consent
	  to its upload. [Note: in many cases browsers are explicitly designed to 
	  avoid dialogs with the semantics of "click here to screw yourself", as
	  extensive research shows that users are prone to consent under such
	  circumstances.
	</t>
	<t>
	  Similarly, while Flash SWFs can access the camera and microphone, they
	  explicitly require that the user consent to that access. In addition,
	  some resources simply cannot be accessed from the browser at all. For
	  instance, there is no real way to run specific executables directly from a 
	  script (though the user can of course be induced to download executable
	  files and run them).
	</t>
      </section>
      <section title="Same Origin Policy" anchor="sec.same-origin">
	<t>
	  Many other resources are accessible but isolated. For instance, 
	  while scripts are allowed to make HTTP requests via the XMLHttpRequest() API
	  those requests are not allowed to be made to any server, but rather solely
	  to the same ORIGIN from whence the script came.<xref target="I-D.abarth-origin"/>
	  (although CORS [REF] and WebSockets [REF] provides a escape hatch from this restriction,
	  as described below. This SAME ORIGIN POLICY (SOP) prevents server A
	  from mounting attacks on server B via the user's browser, which protects both
	  the user (e.g., from misuse of his credentials) and the server (e.g., from DoS attack).
	</t>
	<t>
	  More generally, SOP forces scripts from each site to run in their own, isolated,
	  sandboxes. While there are techniques to allow them to interact, those interactions
	  generally must be mutually consensual (by each site) and are limited to certain
	  channels. For instance, multiple pages/browser panes from the same origin
	  can read each other's JS variables, but pages from the different origins--or 
	  even iframes from different origins on the same page--cannot.
	</t>
	<!-- TODO: Picture -->
	  
      </section>
      <section title="Bypassing SOP: CORS, WebSockets, and consent to communicate" anchor="sec.cors-etc">
	<t>
	  While SOP serves an important security function, it also makes it inconvenient to
	  write certain classes of applications. In particular, mash-ups, in which a script
	  from origin A uses resources from origin B, can only be achieved via a certain amount of hackery.
	  The W3C Cross-Origin Resource Sharing (CORS) spec [REF] is a response to this 
	  demand. In CORS, when a script from origin A executes what would otherwise be a forbidden
	  cross-origin request, the browser instead contacts the target server to determine
	  whether it is willing to allow cross-origin requests from A. If it is so willing,
	  the browser then allows the request. This consent verification process is designed
	  to safely allow cross-origin requests.
	</t>
	<t>
	  While CORS is designed to allow cross-origin HTTP requests, WebSockets [REF] allows
	  cross-origin establishment of transparent channels. Once a WebSockets connection
	  has been established from a script to a site, the script can exchange any traffic it
	  likes without being required to frame it as a series of HTTP request/response
	  transactions. As with CORS, a WebSockets transaction starts with a consent verification
	  stage to avoid allowing scripts to simply send arbitrary data to another origin.
	</t>
	<t>
	  While consent verification is conceptually simple--just do a handshake before you
	  start exchanging the real data--experience has shown that designing a
	  correct consent verification system is difficult. In particular, Huang et al. [REF]
	  have shown vulnerabilities in the existing Java and Flash consent verification 
	  techniques and in a simplified version of the WebSockets handshake. In particular,
	  it is important to be wary of CROSS-PROTOCOL attacks in which the attacking script
	  generates traffic which is acceptable to some non-Web protocol state machine.
	  In order to resist this form of attack, WebSockets incorporates a masking technique
	  intended to randomize the bits on the wire, thus making it more difficult to generate
	  traffic which resembles a given protocol.
	</t>
      </section>		
    </section>

    <section title="Security Considerations" anchor="sec.sec_cons">
      <t>This entire document is about security.</t>
    </section>

    <section title="Acknowledgements">
      <t></t>
    </section>
  </middle>

  <back>
    <references title="Normative References">
      &RFC2119;
    </references>
    <references title="Informative References">
      &RFC3261;
      &I-D.abarth-origin;
    </references>
  </back>
</rfc>
