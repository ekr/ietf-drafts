<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>DTLS key establisihment for SRTP</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="DTLS key establisihment for SRTP">
<meta name="generator" content="xml2rfc v1.30 (http://xml.resource.org/)">
<style type='text/css'>
<!--
    body {
        font-family: verdana, charcoal, helvetica, arial, sans-serif;
        margin: 2em;
        font-size: small ; color: #000000 ; background-color: #ffffff ; }
    .title { color: #990000; font-size: x-large ;
        font-weight: bold; text-align: right;
        font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
        background-color: transparent; }
    .filename { color: #666666; font-size: 18px; line-height: 28px;
        font-weight: bold; text-align: right;
        font-family: helvetica, arial, sans-serif;
        background-color: transparent; }
    td.rfcbug { background-color: #000000 ; width: 30px ; height: 30px ;
        text-align: justify; vertical-align: middle ; padding-top: 2px ; }
    td.rfcbug span.RFC { color: #666666; font-weight: bold; text-decoration: none;
        background-color: #000000 ;
        font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
        font-size: x-small ; }
    td.rfcbug span.hotText { color: #ffffff; font-weight: normal; text-decoration: none;
        text-align: center ;
        font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
        font-size: x-small ; background-color: #000000; }
    /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
    div#counter{margin-top: 100px}

    a.info{
        position:relative; /*this is the key*/
        z-index:24;
        text-decoration:none}

    a.info:hover{z-index:25; background-color:#990000 ; color: #ffffff ;}

    a.info span{display: none}

    a.info:hover span.info{ /*the span will display just on :hover state*/
        display:block;
        position:absolute;
        font-size: smaller ;
        top:2em; left:2em; width:15em;
        padding: 2px ;
        border:1px solid #333333;
        background-color:#eeeeee; color:#990000;
        text-align: left ;}

     A { font-weight: bold; }
     A:link { color: #990000; background-color: transparent ; }
     A:visited { color: #333333; background-color: transparent ; }
     A:active { color: #333333; background-color: transparent ; }

    p { margin-left: 2em; margin-right: 2em; }
    p.copyright { font-size: x-small ; }
    p.toc { font-size: small ; font-weight: bold ; margin-left: 3em ;}
    table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
    td.toc { font-size: small; font-weight: bold; vertical-align: text-top; }

    span.emph { font-style: italic; }
    span.strong { font-weight: bold; }
    span.verb, span.vbare { font-family: "Courier New", Courier, monospace ; }

    span.vemph { font-style: italic; font-family: "Courier New", Courier, monospace ; }
    span.vstrong { font-weight: bold; font-family: "Courier New", Courier, monospace ; }
    span.vdeluxe { font-weight: bold; font-style: italic; font-family: "Courier New", Courier, monospace ; }

    ol.text { margin-left: 2em; margin-right: 2em; }
    ul.text { margin-left: 2em; margin-right: 2em; }
    li { margin-left: 3em;  }

    pre { margin-left: 3em; color: #333333;  background-color: transparent;
        font-family: "Courier New", Courier, monospace ; font-size: small ;
        text-align: left;
        }

    h3 { color: #333333; font-size: medium ;
        font-family: helvetica, arial, sans-serif ;
        background-color: transparent; }
    h4 { font-size: small; font-family: helvetica, arial, sans-serif ; }

    table.bug { width: 30px ; height: 15px ; }
    td.bug { color: #ffffff ; background-color: #990000 ;
        text-align: center ; width: 30px ; height: 15px ;
         }
    td.bug A.link2 { color: #ffffff ; font-weight: bold;
        text-decoration: none;
        font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
        font-size: x-small ; background-color: transparent }

    td.header { color: #ffffff; font-size: x-small ;
        font-family: arial, helvetica, sans-serif; vertical-align: top;
        background-color: #666666 ; width: 33% ; }
    td.author { font-weight: bold; margin-left: 4em; font-size: x-small ; }
    td.author-text { font-size: x-small; }
    table.full { vertical-align: top ; border-collapse: collapse ;
        border-style: solid solid solid solid ;
        border-color: black black black black ;
        font-size: small ; text-align: center ; }
    table.headers, table.none { vertical-align: top ; border-collapse: collapse ;
        border-style: none;
        font-size: small ; text-align: center ; }
    table.full th { font-weight: bold ;
        border-style: solid ;
        border-color: black black black black ; }
    table.headers th { font-weight: bold ;
        border-style: none none solid none;
        border-color: black black black black ; }
    table.none th { font-weight: bold ;
        border-style: none; }
    table.full td {
        border-style: solid solid solid solid ;
        border-color: #333333 #333333 #333333 #333333 ; }
    table.headers td, table.none td { border-style: none; }

    hr { height: 1px }
-->
</style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">Network Working Group</td><td class="header">D. McGrew</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">Cisco Systems</td></tr>
<tr><td class="header">Expires:  September 21, 2006</td><td class="header">E. Rescorla</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">Network Resonance</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">March 20, 2006</td></tr>
</table></td></tr></table>
<div align="right"><span class="title"><br />DTLS key establisihment for SRTP</span></div>
<div align="right"><span class="title"><br />draft-mcgrew-tls-srtp-00.txt</span></div>

<h3>Status of this Memo</h3>
<p>
By submitting this Internet-Draft,
each author represents that any applicable patent or other IPR claims of which
he or she is aware have been or will be disclosed,
and any of which he or she becomes aware will be disclosed,
in accordance with Section&nbsp;6 of BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF), its areas, and its working groups.
Note that other groups may also distribute working documents as
Internet-Drafts.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
The list of current Internet-Drafts can be accessed at
<a href='http://www.ietf.org/ietf/1id-abstracts.txt'>http://www.ietf.org/ietf/1id-abstracts.txt</a>.</p>
<p>
The list of Internet-Draft Shadow Directories can be accessed at
<a href='http://www.ietf.org/shadow.html'>http://www.ietf.org/shadow.html</a>.</p>
<p>
This Internet-Draft will expire on September 21, 2006.</p>

<h3>Copyright Notice</h3>
<p>
Copyright &copy; The Internet Society (2006).</p>

<h3>Abstract</h3>

<p>Secure Real-time Transport Protocol (SRTP) is a profile of
      the Real-time Transport Protocol which can provide
      confidentiality, message authentication, and replay protection
      to the RTP traffic and to the control traffic for RTP, the
      Real-time Transport Control Protocol (RTCP). This document
      describes a method of using DTLS key management for SRTP by
      using a new extension that indicates that SRTP is to be used for
      data protection, and which establishes SRTP keys.
   
</p><a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#anchor1">1.</a>&nbsp;
Introduction<br />
<a href="#anchor2">2.</a>&nbsp;
Conventions Used In This Document<br />
<a href="#anchor3">3.</a>&nbsp;
Protocol Description<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor4">3.1.</a>&nbsp;
Usage Model<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor5">3.2.</a>&nbsp;
use_srtp Extension<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor6">3.2.1.</a>&nbsp;
use_srtp Extension Definition<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.propro">3.2.2.</a>&nbsp;
SRTP Protection Profiles<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor7">3.3.</a>&nbsp;
Key Derivation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor8">3.4.</a>&nbsp;
Key Scope<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor9">3.5.</a>&nbsp;
Key Usage Limitations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor10">3.6.</a>&nbsp;
Data Protection<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.transmit">3.6.1.</a>&nbsp;
Transmission<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor11">3.6.2.</a>&nbsp;
Reception<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.rehandshake">3.7.</a>&nbsp;
Rehandshake and Re-key<br />
<a href="#section.sec">4.</a>&nbsp;
Security Considerations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor12">4.1.</a>&nbsp;
Security of Negotiation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor13">4.2.</a>&nbsp;
Security of Established Keys<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor14">4.3.</a>&nbsp;
Framing Confusion<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor15">4.4.</a>&nbsp;
Sequence Number Interactions<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor16">4.4.1.</a>&nbsp;
Alerts<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor17">4.4.2.</a>&nbsp;
Rehandshake<br />
<a href="#section.iana">5.</a>&nbsp;
IANA Considerations<br />
<a href="#anchor18">6.</a>&nbsp;
Acknowledgments<br />
<a href="#rfc.references1">7.</a>&nbsp;
References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references1">7.1.</a>&nbsp;
Normative References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references2">7.2.</a>&nbsp;
Informational References<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Authors' Addresses<br />
<a href="#rfc.copyright">&#167;</a>&nbsp;
Intellectual Property and Copyright Statements<br />
</p>
<br clear="all" />

<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;Introduction</h3>

<p>
    Secure Real-time Transport Protocol (SRTP) <a class="info" href="#RFC3711">[11]<span> (</span><span class="info">Baugher, M., McGrew, D., Naslund, M., Carrara, E., and K. Norrman, &ldquo;The Secure Real-time Transport Protocol (SRTP),&rdquo; March&nbsp;2004.</span><span>)</span></a>
    is a profile of the
    Real-time Transport Protocol (RTP) <a class="info" href="#RFC1889">[1]<span> (</span><span class="info">Schulzrinne, H., Casner, S., Frederick, R., and V. Jacobson, &ldquo;RTP: A Transport Protocol for Real-Time Applications,&rdquo; January&nbsp;1996.</span><span>)</span></a> which can provide
    confidentiality, message authentication, and replay protection to
    RTP
    traffic and to the control traffic for RTP, the Real-time
    Transport Control Protocol (RTCP). SRTP does not provide key
    management functionality but instead depends on external key
    management.
    
</p>
<p>
    Datagram Transport Layer Security (DTLS) <a class="info" href="#I-D.rescorla-dtls">[5]<span> (</span><span class="info">Rescorla, E. and N. Modadugu, &ldquo;Datagram Transport Layer Security,&rdquo; June&nbsp;2005.</span><span>)</span></a>
    is a channel security protocol that offers integrated key management,
    parameter negotiation, and secure data transfer. Because DTLS's
    data transfer protocol is generic, it is less highly optimized
    for use with RTP than is SRTP, which has been specifically tuned
    for that purpose. This document describes an SRTP extension
    for DTLS which combine the the performance and encryption flexibility
    benefits of SRTP 
    with the flexibility and convenience of DTLS's integrated key
    and association management. This extension MUST only be used
    when the data being transported is RTP and RTCP <a class="info" href="#RFC3550">[4]<span> (</span><span class="info">Schulzrinne, H., Casner, S., Frederick, R., and V. Jacobson, &ldquo;RTP: A Transport Protocol for Real-Time Applications,&rdquo; July&nbsp;2003.</span><span>)</span></a>.
    
</p>
<p>
   The key points of our approach are as follows:
   </p>
<ul class="text">
<li>Application data is protected using SRTP.
</li>
<li>The DTLS handshake is used to establish keying material, algorithms, and
     parameters for SRTP.
</li>
<li>The DTLS pseudo-random function (PRF) is used to generate the SRTP encryption and authentication keys.
</li>
<li>A DTLS extension used to negotiate SRTP algorithms.
</li>
<li>Other content types are protected using the usual DTLS record
      format.
</li>
</ul><p>
   The next section provides details of the new extension.
   
</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;Conventions Used In This Document</h3>

<p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
      document are to be interpreted as described in <a class="info" href="#RFC2119">[2]<span> (</span><span class="info">Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a>.
</p>
<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;Protocol Description</h3>

<p>
   In this section we provide a description of the new protocol
   elements introduced by this proposal.
   
</p>
<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1"></a><h3>3.1.&nbsp;Usage Model</h3>

<p>
        DTLS-SRTP is defined for point-to-point media sessions, in
        which there are exactly two participants.  A DTLS-SRTP session
        corresponds to a pair of complementary unidirectional RTP
        flows.  Between a single pair of participants, there may be
        multiple media sessions; each session MUST have its own
        DTLS-SRTP session.  Additionally, each RTCP flow is protected
        by a separate DTLS-SRTP session.  One or both of the DTLS-SRTP
        session participants MAY be RTP mixers.
	Each DTLS-SRTP session contains a single DLTS association
	(called a "connection" in TLS jargon).
	
        
        
      
</p>
<p>
     A DTLS-SRTP session can be indicated by an external
     signaling protocol like SIP.  When the signaling
     exchange is integrity-protected (e.g when SIP Identity
     protection via digital signatures is used), 
     DTLS-SRTP can leverage this integrity guarantee  
      to provide complete security of the media stream.
   A description of how to indicate DTLS-SRTP sessions  in SIP and SDP,
     and how to  authenticate
   the endpoints using fingerprints can be found in 
   <a class="info" href="#I-D.fischl-mmusic-sdp-dtls">[7]<span> (</span><span class="info">Fischl, J. and H. Tschofenig, &ldquo;Session Description Protocol (SDP) Indicators for Datagram Transport Layer  Security (DTLS),&rdquo; March&nbsp;2006.</span><span>)</span></a> and
   <a class="info" href="#I-D.fischl-sipping-media-dtls">[6]<span> (</span><span class="info">Fischl, J., &ldquo;Session Initiation Protocol (SIP) for Media Over Datagram Transport Layer  Security (DTLS),&rdquo; March&nbsp;2006.</span><span>)</span></a>.
   
   
</p>
<p>
     Each RTP stream participates in a single DTLS session.  In a
     naive implementation, this results in new DTLS session
     establishment (complete with public key cryptography) for each
     media channel.  For example, a videophone may be sending both an
     audio stream and a video stream, each of which would use a
     separate DTLS session establishment exchange, which would proceed
     in parallel.  As an optimization, the DTLS-SRTP implementation
     SHOULD use the following strategy: a single DTLS connection is
     established, and all other DTLS sessions wait until that
     connection is established before proceeding with their session
     establishment exchanges.  This strategy allows the later sessions
     to use the DTLS session re-start, which allows the amortization of
     the expensive public key cryptography operations over multiple
     DTLS session establishment instances.
   
</p>
<p>
    One issue that arises in this context is multiple RTP sender over
    the same DTLS channel. In order to avoid the "two-time pad" problem
    (as described in Section 9.1 of RFC 3711), distinct keys are used
    for each participant in the DTLS-SRTP session.
   
</p>
<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2"></a><h3>3.2.&nbsp;use_srtp Extension</h3>

<p>
   In order to negotiate the use of SRTP data protection,
   clients MAY include an extension of type "use_srtp" in
   the extended client hello. The "extension_data" field of this
   extension contains the list of acceptable SRTP protection
   profiles, as indicated below.
   
</p>
<p>
   Servers that receive an extended hello containing a "use_srtp"
   extension, MAY agree to use SRTP by including an 
   extension of type "use_srtp", with the chosen protection
   profile in the extended server hello. This process is shown below.
   
</p><pre>
      Client                                               Server

      ClientHello + use_srtp       --------&gt;
                                           ServerHello + use_srtp
                                                     Certificate*
                                               ServerKeyExchange*
                                              CertificateRequest*
                                   &lt;--------      ServerHelloDone
      Certificate*
      ClientKeyExchange
      CertificateVerify*
      [ChangeCipherSpec]
      Finished                     --------&gt;
                                               [ChangeCipherSpec]
                                   &lt;--------             Finished
      SRTP packets                 &lt;-------&gt;      SRTP packets
</pre>
<p>
   Once the "use_srtp" extension is negotiated, packets 
   of type "application_data" in
   the newly negotiated association (i.e., after the change_cipher_spec)
   SHOULD be protected using SRTP. 
   
   Records of type other than
   "application_data" MUST use ordinary DTLS framing. When the "use_srtp"
   extension is in effect, implementations MUST NOT place more than
   one "record" per datagram. (This is only meaningful from the
   perspective of DTLS because SRTP is inherently oriented towards
   one payload per packet, but is stated purely for clarification.)
   
</p>
<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2.1"></a><h3>3.2.1.&nbsp;use_srtp Extension Definition</h3>

<p>
   The client MUST fill the extension_data field of the 
   the "use_rtp" extension with an SRTPProtectionProfiles value:
   
</p><pre>
   uint8 SRTPProtectionProfile[2];

   SRTPProtectionProfiles SRTPProtectionProfiles;
</pre>
<p>
   This list indicates the SRTP protection profiles that the 
   client is willing to support, listed in descending order
   of preference.
   
</p>
<p>
   If the server is willing to accept the use_srtp extension, it MUST
   respond with its own "use_srtp" extension in the
   ExtendedServerHello.  The extension_data field MUST be a
   SRTPProtectionProfile which contains the
   protection profile which the server has chosen for use with this
   connection. The server MUST NOT select a value which the client
   has not offered. If there is no shared profile, the 
   server should not return the use_srtp extension at which point
   the connection falls back to the negotiated DTLS cipher suite.
   If that is not acceptable the server should return an appropriate
   DTLS alert.
   
</p>
<a name="section.propro"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2.2"></a><h3>3.2.2.&nbsp;SRTP Protection Profiles</h3>

<p>
     A DTLS-SRTP SRTP Protection Profile defines the parameters and
     options that are in effect for the SRTP processing.  This
     document defines the following SRTP protection profiles.
   
</p><pre>
   SRTPProtectionProfile SRTP_AES128_CM_SHA1_80 ={0x00, 0x01};
   SRTPProtectionProfile SRTP_AES128_CM_SHA1_32 ={0x00, 0x02};
   SRTPProtectionProfile SRTP_AES128_F8_SHA1_80 ={0x00, 0x03};
   SRTPProtectionProfile SRTP_AES128_F8_SHA1_32 ={0x00, 0x04};
   SRTPProtectionProfile SRTP_NULL_SHA1_80      ={0x00, 0x05};
   SRTPProtectionProfile SRTP_NULL_SHA1_32      ={0x00, 0x06};
</pre>
<p>
   The following list indicates the SRTP transform parameters for each
   protection profile.  The parameters cipher_key_length,
   cipher_salt_length, auth_key_length, and auth_tag_length express
   the number of bits in the values to which they refer.  The
   maximum_lifetime parameter indicates the maximum number of packets
   that can be protected with each single set of keys when the
   parameter profile is in use. 
   
</p>
<p>
 
     </p>
<blockquote class="text"><dl>
<dt>SRTP_AES128_CM_SHA1_80</dt>
<dd>
	 
<blockquote class="text"><dl>
<dt></dt>
<dd> cipher: AES_128_CM  
</dd>
<dt></dt>
<dd> cipher_key_length: 128
</dd>
<dt></dt>
<dd> cipher_salt_length: 112 
</dd>
<dt></dt>
<dd> maximum_lifetime:   2^48 
</dd>
<dt></dt>
<dd> auth_function: HMAC-SHA1 
</dd>
<dt></dt>
<dd> auth_key_length: 160 
</dd>
<dt></dt>
<dd> auth_tag_length: 80 
</dd>
</dl></blockquote>
       
</dd>
<dt>SRTP_AES128_CM_SHA1_32</dt>
<dd>
	   Because of the short authentication tag provides limited authentication, this
	 profile SHOULD NOT be used with RTCP.
	 
<blockquote class="text"><dl>
<dt></dt>
<dd> cipher: AES_128_CM  
</dd>
<dt></dt>
<dd> cipher_key_length: 128
</dd>
<dt></dt>
<dd> cipher_salt_length: 112 
</dd>
<dt></dt>
<dd> maximum_lifetime:   2^48 
</dd>
<dt></dt>
<dd> auth_function: HMAC-SHA1 
</dd>
<dt></dt>
<dd> auth_key_length: 160 
</dd>
<dt></dt>
<dd> auth_tag_length: 32 
</dd>
</dl></blockquote>
       
</dd>
<dt>SRTP_AES128_F8_SHA1_80</dt>
<dd>	 
	 
<blockquote class="text"><dl>
<dt></dt>
<dd> cipher: AES_128_F8  
</dd>
<dt></dt>
<dd> cipher_key_length: 128
</dd>
<dt></dt>
<dd> cipher_salt_length: 112 
</dd>
<dt></dt>
<dd> maximum_lifetime:   2^48 
</dd>
<dt></dt>
<dd> auth_function: HMAC-SHA1 
</dd>
<dt></dt>
<dd> auth_key_length: 160 
</dd>
<dt></dt>
<dd> auth_tag_length: 80 
</dd>
</dl></blockquote>
       
</dd>
<dt>SRTP_AES128_F8_SHA1_32</dt>
<dd>
	   	 Because the short authentication tag provides limited authentication, this
	 profile SHOULD NOT be used with RTCP.
	 
<blockquote class="text"><dl>
<dt></dt>
<dd> cipher: AES_128_F8  
</dd>
<dt></dt>
<dd> cipher_key_length: 128
</dd>
<dt></dt>
<dd> cipher_salt_length: 112 
</dd>
<dt></dt>
<dd> maximum_lifetime:   2^48 
</dd>
<dt></dt>
<dd> auth_function: HMAC-SHA1 
</dd>
<dt></dt>
<dd> auth_key_length: 160 
</dd>
<dt></dt>
<dd> auth_tag_length: 32 
</dd>
</dl></blockquote>
       
</dd>
<dt>SRTP_AES128_NULL_SHA1_80</dt>
<dd>	 
	 
<blockquote class="text"><dl>
<dt></dt>
<dd> cipher: NULL  
</dd>
<dt></dt>
<dd> cipher_key_length: 0
</dd>
<dt></dt>
<dd> cipher_salt_length: 0 
</dd>
<dt></dt>
<dd> maximum_lifetime:   2^48 
</dd>
<dt></dt>
<dd> auth_function: HMAC-SHA1 
</dd>
<dt></dt>
<dd> auth_key_length: 160 
</dd>
<dt></dt>
<dd> auth_tag_length: 80 
</dd>
</dl></blockquote>
       
</dd>
<dt>SRTP_AES128_NULL_SHA1_32</dt>
<dd>
	   	 Because the short authentication tag provides limited authentication, this
	 profile SHOULD NOT be used with RTCP.
	 
<blockquote class="text"><dl>
<dt></dt>
<dd> cipher: NULL  
</dd>
<dt></dt>
<dd> cipher_key_length: 0
</dd>
<dt></dt>
<dd> cipher_salt_length: 0 
</dd>
<dt></dt>
<dd> maximum_lifetime:   2^48 
</dd>
<dt></dt>
<dd> auth_function: HMAC-SHA1 
</dd>
<dt></dt>
<dd> auth_key_length: 160 
</dd>
<dt></dt>
<dd> auth_tag_length: 32 
</dd>
</dl></blockquote>
       
</dd>
</dl></blockquote><p>
     With all of these SRTP Parameter profiles, the following SRTP
     options are in effect:
     </p>
<blockquote class="text">
<p>
	 The TLS Key Derivation Function (KDF) is used, and the SRTP default
       KDF is not used.
	 
</p>
<p>
	 The Key Derivation Rate (KDR) is equal to zero.  Thus, keys are not
	 re-derived based on the sequence number.     
	 
</p>
<p>
	 For all other parameters, the default values are used.
	 
</p>
</blockquote><p>
     All SRTP parameters that are not determined by the SRTP
     Protection Profile MAY be established via the signaling system.
     In particular, the relative order of Forward Error Correction and
     SRTP processing, and a suggested SRTP replay window size SHOULD
     be established in this manner.  An example of how these parameters can 
     be defined for SDP by is contained in <a class="info" href="#I-D.ietf-mmusic-sdescriptions">[8]<span> (</span><span class="info">Andreasen, F., &ldquo;Session Description Protocol Security Descriptions for Media Streams,&rdquo; September&nbsp;2005.</span><span>)</span></a>. 
   
</p>
<p>
   New SRTPProtectionProfile values must be defined by RFC 2434 
   Standards Action. See Section <a class="info" href="#section.iana">Section&nbsp;5<span> (</span><span class="info">IANA Considerations</span><span>)</span></a>
   for IANA Considerations.
   
</p>
<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3"></a><h3>3.3.&nbsp;Key Derivation</h3>

<p>
   When SRTP mode is in effect, different keys are used for 
   ordinary DTLS record protection and SRTP record protection.
   These keys are generated as additional keying material at
   the end of the DTLS key block. Thus, the key block becomes:
   
</p><pre>
client_write_MAC_secret[SecurityParameters.hash_size]
server_write_MAC_secret[SecurityParameters.hash_size]
client_write_key[SecurityParameters.key_material_length]
server_write_key[SecurityParameters.key_material_length]
srtp_client_write_MAC_secret[SRTPSecurityParams.auth_key_length]
srtp_server_write_MAC_secret[SRTPSecurityParams.auth_key_length]
srtp_client_write_key[SRTPSecurityParams.cipher_key_length]
srtp_server_write_key[SRTPSecurityParams.cipher_key_length]
srtp_client_write_salt_secret[SRTPSecurityParams.cipher_salt_length]
srtp_server_write_salt_secret[SRTPSecurityParams.cipher_salt_length]
</pre>
<p>
     
   
</p>
<p>
   The last six values are mapped directly onto the SRTP values
   for each transform. The following table shows the mapping
   in the client to server direction:
   
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="right">
<tr><th align="left">DTLS Value</th><th align="right">SRTP Value</th></tr>
<tr>
<td align="left">srtp_client_write_MAC_secret</td>
<td align="right">k_a</td>
</tr>
<tr>
<td align="left">srtp_client_write_key</td>
<td align="right">k_e</td>
</tr>
<tr>
<td align="left">srtp_client_write_salt</td>
<td align="right">k_s</td>
</tr>
</table>

<p>
   Because we generate the SRTP keys directly, 
   the SRTP key derivation mechanism described in Section 4.3 
   of <a class="info" href="#RFC3711">[11]<span> (</span><span class="info">Baugher, M., McGrew, D., Naslund, M., Carrara, E., and K. Norrman, &ldquo;The Secure Real-time Transport Protocol (SRTP),&rdquo; March&nbsp;2004.</span><span>)</span></a> is not used. 
   
</p>
<a name="anchor8"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4"></a><h3>3.4.&nbsp;Key Scope</h3>

<p>
     The SRTP cipher and authentication function keys provided by DTLS-SRTP 
     are used as follows.
     </p>
<blockquote class="text">
<p>
	 The srtp_client_write_key is used to encrypt traffic that is
	 sent by the client.  It MUST NOT be used in encryption by the
	 server.
       
</p>
<p>
	 The srtp_client_write_salt_secret is used to randomize IV by some SRTP
	 ciphers; may be used as input to the encryption of traffic that is
	 sent by the client.  It MUST NOT be used in encryption by the
	 server.
       
</p>
<p>
	 The srtp_client_write_MAC_secret is used to generate authentication
	 tags for traffic that is sent by the client.  It MUST NOT be used
	 to generate tags for traffic that is sent by the server.
       
</p>
<p>
	 The srtp_server_write_key is used to encrypt traffic that is sent by
	 the server.  It MUST NOT be used in encryption by the client.
       
</p>
<p>
	 The srtp_server_write_salt_secret is used to randomize IV by some SRTP
	 ciphers; may be used as input to the encryption of traffic that is
	 sent by the server.  It MUST NOT be used in encryption by the
	 client.
       
</p>
<p>	 
	 The srtp_server_write_MAC_secret is used to generate authentication
	 tags for traffic that is sent by the server.  It MUST NOT be used
	 to generate tags for traffic that is sent by the client.
       
</p>
</blockquote><p>
     
</p>
<p>
       The "use_srtp" extension conveys the RTP sequence number at
       which the SRTP keys derived after a DTLS handshake will be
       used.  Because of the possibility of packet reorder, DTLS-SRTP
       implementations SHOULD store multiple SRTP keys sets during a
       re-key in order to avoid the need for receivers to drop packets
       for which they lack a key. 
     
</p>
<a name="anchor9"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.5"></a><h3>3.5.&nbsp;Key Usage Limitations</h3>

<p>
     The maximum_lifetime parameter in the SRTP protection profile
     indicates the maximum number of packets that can be protected
     with each single encryption and authentication key.  Each profile
     defines its own limit.  When this limit is reached, a new DTLS
     session SHOULD be used to establish replacement keys, and SRTP
     implementations MUST NOT use the existing keys for the processing
     of either outbound or inbound traffic.
   
</p>
<a name="anchor10"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.6"></a><h3>3.6.&nbsp;Data Protection</h3>

<p>
   Once the DTLS handshake has completed the peers can send RTP and
   RTCP over the newly created channel. We describe the transmission
   process first followed by the reception process.
   
</p>
<p>
     Within each RTP session, SRTP processing MUST NOT take
     place before the DTLS handshake completes. 
   
</p>
<a name="section.transmit"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.6.1"></a><h3>3.6.1.&nbsp;Transmission</h3>

<p>
   DTLS and TLS define a number of record content types. In
   ordinary TLS/DTLS, all data is protected using the same 
   record encoding and mechanisms. When the mechanism described
   in this document is in effect, this is modified so that 
   data of type "application_data" (used to transport data traffic)
   is encrypted using SRTP rather than the standard TLS record encoding.
   
</p>
<p>
   When a user of DTLS wishes to send an RTP packet in SRTP mode
   it delivers it to the DTLS implementation as a single write
   of type "application_data". The DTLS implementation then 
   invokes the processing described in RFC 3711 Sections 3
   and 4. The resulting SRTP packet is then sent directly on
   the wire as a single datagram with no DTLS framing. This
   provides the same bits on the wire representation as SRTP for the data.
   Note that the RTP sequence number rather than the 
   DTLS sequence number is used for these packets.
   
</p>
<a name="anchor11"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.6.2"></a><h3>3.6.2.&nbsp;Reception</h3>

<p>
   In ordinary DTLS, the receiver can unambiguously determine
   the type of the record from the DTLS record header. However
   when SRTP and DTLS data is mixed over the same channel,
   the recipient must first determine which decryption
   mechanism to use. This can be done unambiguously using the
   following procedure.
   </p>
<ol class="text">
<li>Assume that the datagram is a DTLS record.
</li>
<li>If the first byte does not match a known DTLS content type go to step 6.
</li>
<li>If the version field does not match the current version go to step 6.
</li>
<li>If the length does not match the rest of the record, go to step 6.
</li>
<li>Attempt to decrypt and verify the DTLS record--omitting
   the replay check. If this process succeeds, the record must
   be DTLS. Deliver it to the rest of the DTLS implementation.
</li>
<li>Assume that the datagram is an SRTP packet and follow
   the procedure of Section 3 of RFC 3711. Note that the 
   replay detection check specified in DTLS SHOULD NOT be done for these packets. 
     If anti-replay is desired SRTP anti-replay mechanisms SHOULD be used.

</li>
</ol><p>
   
</p>
<p>
   The first byte of a
   DTLS packet is "Type" which can currently have values of 20,21,22, and
   23 as defined in ContentType declaration in <a class="info" href="#I-D.ietf-tls-rfc2246-bis">[9]<span> (</span><span class="info">Dierks, T. and E. Rescorla, &ldquo;The TLS Protocol Version 1.1,&rdquo; June&nbsp;2005.</span><span>)</span></a>. It is reasonable to expect
   the first byte to remain under 64 and greater than 1. For RTP the
   first byte has a value that is 196 or above. 
   Thus, in general, the type check specified in step (2) is sufficient
   for unambigous interpretation, and checks (3), (4), and (5)
   are merely fallbacks in case of the unlikely event that
   the headers do change enough to make this first check less
   than completely definitive.
   
</p>
<p>
   If this procedure does not result in a successful verification
   and reception, the datagram SHOULD be silently discarded. 
   For testing and debugging purposes it MAY be desirable to generate
   an "invalid_MAC" alert, as specified in Section 4.1.2.1 of
   <a class="info" href="#I-D.rescorla-dtls">[5]<span> (</span><span class="info">Rescorla, E. and N. Modadugu, &ldquo;Datagram Transport Layer Security,&rdquo; June&nbsp;2005.</span><span>)</span></a>.
   
</p>
<a name="section.rehandshake"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.7"></a><h3>3.7.&nbsp;Rehandshake and Re-key</h3>

<p>
   Rekeying in DTLS is accomplished by performing a new handshake
   over the existing DTLS channel. This handshake can be performed
   in parallel with data transport, so no interruption of the 
   data flow is required. Once the handshake is finished, all records,
   including application_data records, simply switch over to the
   new keys.
   
</p>
<p>
   Because of packet reordering, data from the previous association
   can appear on the wire after the handshake has completed. This
   means that receivers must maintain both sets of keys for some
   time in order to be able to decrypt and verify older data records. In
   the ordinary DTLS record layer, this is accomplished by having
   an "epoch" value in each record that indicates which handshake
   the record is from. However, no such explicit field is present in SRTP.
   
</p>
<p>
   One approach would be to simply place the DTLS epoch value in
   the Master Key Identifier, but this would add two bytes to 
   every packet, which seems undesirable, given that rekeying is
   an infrequent event. Instead, we propose adapting the 
   rollover counter management algorithm of Section 3.3.1 of 
   RFC 3711. When a handshake has just been performed (during
   the MSL period after the handshake), the implementation
   SHOULD retain the pre-handshake set of keys. When a new
   packet arrives, it should try decrypting/authenticating
   with both sets of keys (using the sequence number to guess
   which key to try first). If either set succeeds, it should
   pass on the packet, otherwise it should be rejected.
   Once the MSL has expired, the previous keys can be discarded.
   This algorithm is easily extensible to the case where
   several handshakes happen in close succession, but such
   practice is NOT RECOMMENDED.
   
</p>
<a name="section.sec"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;Security Considerations</h3>

<p>
   The use of multiple data protection framings negotiated
   in the same handshake creates some complexities, which are
   discussed here.
   
</p>
<a name="anchor12"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1"></a><h3>4.1.&nbsp;Security of Negotiation</h3>

<p>
   One concern here is that attackers might be able to implement a
   bid-down attack forcing the peers to use ordinary DTLS rather than
   SRTP. However, because the negotiation of this extension is
   performed in the DTLS handshake, it is protected by the Finished
   messages. Therefore, any bid-down attack is automatically detected,
   which reduces this to a denial of service attack--which any attacker who can 
   control the channel can always mount.
   
</p>
<a name="anchor13"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2"></a><h3>4.2.&nbsp;Security of Established Keys</h3>

<p>
   [TODO: David, can you say something about NIST, the PRF, etc...?]
   
</p>
<a name="anchor14"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3"></a><h3>4.3.&nbsp;Framing Confusion</h3>

<p>
   Because two different framing formats are used, there is concern
   that an attacker could convince the receiver to treat an SRTP-framed
   RTP packet as a DTLS record (e.g., a handshake message) or 
   vice versa. This attack is prevented by using different keys
   for MAC verification for each type of data. Therefore, this type
   of attack reduces to being able to forge a packet with a valid
   MAC, which violates a basic security invariant of both DTLS
   and SRTP.
   
</p>
<p>
   As an additional defense against injection into the DTLS handshake
   channel, the DTLS record type is included in the MAC. Therefore,
   an SRTP record would be treated as an unknown type and
   ignored. (See Section 6 of <a class="info" href="#I-D.ietf-tls-rfc2246-bis">[9]<span> (</span><span class="info">Dierks, T. and E. Rescorla, &ldquo;The TLS Protocol Version 1.1,&rdquo; June&nbsp;2005.</span><span>)</span></a>).
   
</p>
<a name="anchor15"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4"></a><h3>4.4.&nbsp;Sequence Number Interactions</h3>

<p>
   As described in Section <a class="info" href="#section.transmit">Section&nbsp;3.6.1<span> (</span><span class="info">Transmission</span><span>)</span></a>,
   the SRTP and DTLS sequence number spaces are distinct. This means
   that it is not possible to unambiguously order a given DTLS
   control record with respect to an SRTP packet. In general, this
   is relevant in two situations: alerts and rehandshake.
   
</p>
<a name="anchor16"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4.1"></a><h3>4.4.1.&nbsp;Alerts</h3>

<p>
   Because DTLS handshake and change_cipher_spec
   messages share the same sequence number space as alerts, they
   can be ordered correctly.
   Because DTLS alerts are inherently unreliable and SHOULD NOT
   be generated as a response to data packets, reliable 
   sequencing between SRTP packets and DTLS alerts is not an
   important feature. However, implementations which wish 
   to use DTLS alerts to signal problems with the SRTP encoding
   SHOULD simply act on alerts as soon as they are received
   and assume that they refer to the temporally contiguous stream.
   Such implementations MUST check for alert retransmission and
   discard retransmitted alerts to 
   avoid overreacting to replay attacks.
   
</p>
<a name="anchor17"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4.2"></a><h3>4.4.2.&nbsp;Rehandshake</h3>

<p>
   Because the rehandshake transition algorithm specified in Section <a class="info" href="#section.rehandshake">Section&nbsp;3.7<span> (</span><span class="info">Rehandshake and Re-key</span><span>)</span></a> requires trying multiple sets of keys,
   it slightly weakens the authentication. For instance, if an n-bit
   MAC is used and k different sets of keys are present, then the MAC
   is weakened by log_2(k) bits to n - log_2(k). In practice, since
   the number of keys used will be very small and the MACs in use
   are typically strong (the default for SRTP is 80 bits) the decrease
   in security involved here is minimal.
   
</p>
<p>
   Another concern here is that this algorithm slightly increases
   the work factor on the receiver because it needs to attempt multiple
   validations. However, again, the number of potential keys will
   be very small (and the attacker cannot force it to be larger) and
   this technique is already used for rollover counter management,
   so the authors do not consider this to be a serious flaw.
   
</p>
<a name="section.iana"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;IANA Considerations</h3>

<p>
      This document a new extension for DTLS, in
accordance with <a class="info" href="#I-D.ietf-tls-rfc3546bis">[10]<span> (</span><span class="info">Blake-Wilson, S., &ldquo;Transport Layer Security (TLS) Extensions,&rdquo; October&nbsp;2005.</span><span>)</span></a>:

</p><pre>
      enum { use_srtp (??) } ExtensionType;
</pre>
<p>
   [[ NOTE: This value needs to be assigned by IANA ]]

</p>
<p>
This extension MUST only be used with DTLS.

</p>
<p>
Section <a class="info" href="#section.propro">Section&nbsp;3.2.2<span> (</span><span class="info">SRTP Protection Profiles</span><span>)</span></a> requires that all SRTPProtectionProfile
values be defined by RFC 2434 Standards Action. IANA SHOULD
create a DTLS SRTPProtectionProfile registry initially populated
with values from Section <a class="info" href="#section.propro">Section&nbsp;3.2.2<span> (</span><span class="info">SRTP Protection Profiles</span><span>)</span></a> of this document.
Future values MUST be allocated via Standards Action as described
in <a class="info" href="#RFC2434">[3]<span> (</span><span class="info">Narten, T. and H. Alvestrand, &ldquo;Guidelines for Writing an IANA Considerations Section in RFCs,&rdquo; October&nbsp;1998.</span><span>)</span></a>

</p>
<a name="anchor18"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;Acknowledgments</h3>

<p>
    Some people.
   
</p>
<a name="rfc.references"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;References</h3>

<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>7.1.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC1889">[1]</a></td>
<td class="author-text"><a href="mailto:schulzrinne@fokus.gmd.de">Schulzrinne, H.</a>, <a href="mailto:casner@precept.com">Casner, S.</a>, <a href="mailto:frederic@parc.xerox.com">Frederick, R.</a>, and <a href="mailto:van@ee.lbl.gov">V. Jacobson</a>, &ldquo;<a href="ftp://ftp.isi.edu/in-notes/rfc1889.txt">RTP: A Transport Protocol for Real-Time Applications</a>,&rdquo; RFC&nbsp;1889, January&nbsp;1996.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2119">[2]</a></td>
<td class="author-text"><a href="mailto:sob@harvard.edu">Bradner, S.</a>, &ldquo;<a href="ftp://ftp.isi.edu/in-notes/rfc2119.txt">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997 (<a href="ftp://ftp.isi.edu/in-notes/rfc2119.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2119.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2119.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2434">[3]</a></td>
<td class="author-text"><a href="mailto:narten@raleigh.ibm.com">Narten, T.</a> and <a href="mailto:Harald@Alvestrand.no">H. Alvestrand</a>, &ldquo;<a href="ftp://ftp.isi.edu/in-notes/rfc2434.txt">Guidelines for Writing an IANA Considerations Section in RFCs</a>,&rdquo; BCP&nbsp;26, RFC&nbsp;2434, October&nbsp;1998 (<a href="ftp://ftp.isi.edu/in-notes/rfc2434.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2434.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2434.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3550">[4]</a></td>
<td class="author-text">Schulzrinne, H., Casner, S., Frederick, R., and V. Jacobson, &ldquo;<a href="ftp://ftp.isi.edu/in-notes/rfc3550.txt">RTP: A Transport Protocol for Real-Time Applications</a>,&rdquo; STD&nbsp;64, RFC&nbsp;3550, July&nbsp;2003 (<a href="ftp://ftp.isi.edu/in-notes/rfc3550.txt">TXT</a>, <a href="ftp://ftp.isi.edu/in-notes/rfc3550.ps">PS</a>, <a href="ftp://ftp.isi.edu/in-notes/rfc3550.pdf">PDF</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.rescorla-dtls">[5]</a></td>
<td class="author-text">Rescorla, E. and N. Modadugu, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-rescorla-dtls-05.txt">Datagram Transport Layer Security</a>,&rdquo; draft-rescorla-dtls-05 (work in progress), June&nbsp;2005.</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.fischl-sipping-media-dtls">[6]</a></td>
<td class="author-text">Fischl, J., &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-fischl-sipping-media-dtls-00.txt">Session Initiation Protocol (SIP) for Media Over Datagram Transport Layer  Security (DTLS)</a>,&rdquo; draft-fischl-sipping-media-dtls-00 (work in progress), March&nbsp;2006.</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.fischl-mmusic-sdp-dtls">[7]</a></td>
<td class="author-text">Fischl, J. and H. Tschofenig, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-fischl-mmusic-sdp-dtls-00.txt">Session Description Protocol (SDP) Indicators for Datagram Transport Layer  Security (DTLS)</a>,&rdquo; draft-fischl-mmusic-sdp-dtls-00 (work in progress), March&nbsp;2006.</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-mmusic-sdescriptions">[8]</a></td>
<td class="author-text">Andreasen, F., &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-mmusic-sdescriptions-12.txt">Session Description Protocol Security Descriptions for Media Streams</a>,&rdquo; draft-ietf-mmusic-sdescriptions-12 (work in progress), September&nbsp;2005.</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>7.2.&nbsp;Informational References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="I-D.ietf-tls-rfc2246-bis">[9]</a></td>
<td class="author-text">Dierks, T. and E. Rescorla, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-tls-rfc2246-bis-13.txt">The TLS Protocol Version 1.1</a>,&rdquo; draft-ietf-tls-rfc2246-bis-13 (work in progress), June&nbsp;2005.</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-tls-rfc3546bis">[10]</a></td>
<td class="author-text">Blake-Wilson, S., &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-tls-rfc3546bis-02.txt">Transport Layer Security (TLS) Extensions</a>,&rdquo; draft-ietf-tls-rfc3546bis-02 (work in progress), October&nbsp;2005.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3711">[11]</a></td>
<td class="author-text">Baugher, M., McGrew, D., Naslund, M., Carrara, E., and K. Norrman, &ldquo;<a href="ftp://ftp.isi.edu/in-notes/rfc3711.txt">The Secure Real-time Transport Protocol (SRTP)</a>,&rdquo; RFC&nbsp;3711, March&nbsp;2004.</td></tr>
</table>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">David McGrew</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Cisco Systems</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">510 McCarthy Blvd.</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Milpitas, CA  95305</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">USA</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:mcgrew@cisco.com">mcgrew@cisco.com</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Eric Rescorla</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Network Resonance</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">2483 E. Bayshore #212</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Palo Alto, CA  94303</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">USA</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:ekr@networkresonance.com">ekr@networkresonance.com</a></td></tr>
</table>
<a name="rfc.copyright"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Intellectual Property Statement</h3>
<p class='copyright'>
The IETF takes no position regarding the validity or scope of any
Intellectual Property Rights or other rights that might be claimed
to pertain to the implementation or use of the technology
described in this document or the extent to which any license
under such rights might or might not be available; nor does it
represent that it has made any independent effort to identify any
such rights.
Information on the procedures with respect to
rights in RFC documents can be found in BCP&nbsp;78 and BCP&nbsp;79.</p>
<p class='copyright'>
Copies of IPR disclosures made to the IETF Secretariat and any
assurances of licenses to be made available,
or the result of an attempt made to obtain a general license or
permission for the use of such proprietary rights by implementers or
users of this specification can be obtained from the IETF on-line IPR
repository at <a href='http://www.ietf.org/ipr'>http://www.ietf.org/ipr</a>.</p>
<p class='copyright'>
The IETF invites any interested party to bring to its attention
any copyrights,
patents or patent applications,
or other
proprietary rights that may cover technology that may be required
to implement this standard.
Please address the information to the IETF at <a href='mailto:ietf-ipr@ietf.org'>ietf-ipr@ietf.org</a>.</p>
<h3>Disclaimer of Validity</h3>
<p class='copyright'>
This document and the information contained herein are provided
on an &ldquo;AS IS&rdquo; basis and THE CONTRIBUTOR,
THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY),
THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM
ALL WARRANTIES,
EXPRESS OR IMPLIED,
INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE
INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.</p>
<h3>Copyright Statement</h3>
<p class='copyright'>
Copyright &copy; The Internet Society (2006).
This document is subject to the rights,
licenses and restrictions contained in BCP&nbsp;78,
and except as set forth therein,
the authors retain all their rights.</p>
<h3>Acknowledgment</h3>
<p class='copyright'>
Funding for the RFC Editor function is currently provided by the
Internet Society.</p>
</body></html>
