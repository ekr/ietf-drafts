<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>Secure Real-time Transport
    Protocol (SRTP) Extensions for Datagram Transport Layer Security
    (DTLS)</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="Secure Real-time Transport
    Protocol (SRTP) Extensions for Datagram Transport Layer Security
    (DTLS)">
<meta name="generator" content="xml2rfc v1.30 (http://xml.resource.org/)">
<style type='text/css'>
<!--
    body {
        font-family: verdana, charcoal, helvetica, arial, sans-serif;
        margin: 2em;
        font-size: small ; color: #000000 ; background-color: #ffffff ; }
    .title { color: #990000; font-size: x-large ;
        font-weight: bold; text-align: right;
        font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
        background-color: transparent; }
    .filename { color: #666666; font-size: 18px; line-height: 28px;
        font-weight: bold; text-align: right;
        font-family: helvetica, arial, sans-serif;
        background-color: transparent; }
    td.rfcbug { background-color: #000000 ; width: 30px ; height: 30px ;
        text-align: justify; vertical-align: middle ; padding-top: 2px ; }
    td.rfcbug span.RFC { color: #666666; font-weight: bold; text-decoration: none;
        background-color: #000000 ;
        font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
        font-size: x-small ; }
    td.rfcbug span.hotText { color: #ffffff; font-weight: normal; text-decoration: none;
        text-align: center ;
        font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
        font-size: x-small ; background-color: #000000; }
    /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
    div#counter{margin-top: 100px}

    a.info{
        position:relative; /*this is the key*/
        z-index:24;
        text-decoration:none}

    a.info:hover{z-index:25; background-color:#990000 ; color: #ffffff ;}

    a.info span{display: none}

    a.info:hover span.info{ /*the span will display just on :hover state*/
        display:block;
        position:absolute;
        font-size: smaller ;
        top:2em; left:2em; width:15em;
        padding: 2px ;
        border:1px solid #333333;
        background-color:#eeeeee; color:#990000;
        text-align: left ;}

     A { font-weight: bold; }
     A:link { color: #990000; background-color: transparent ; }
     A:visited { color: #333333; background-color: transparent ; }
     A:active { color: #333333; background-color: transparent ; }

    p { margin-left: 2em; margin-right: 2em; }
    p.copyright { font-size: x-small ; }
    p.toc { font-size: small ; font-weight: bold ; margin-left: 3em ;}
    table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
    td.toc { font-size: small; font-weight: bold; vertical-align: text-top; }

    span.emph { font-style: italic; }
    span.strong { font-weight: bold; }
    span.verb, span.vbare { font-family: "Courier New", Courier, monospace ; }

    span.vemph { font-style: italic; font-family: "Courier New", Courier, monospace ; }
    span.vstrong { font-weight: bold; font-family: "Courier New", Courier, monospace ; }
    span.vdeluxe { font-weight: bold; font-style: italic; font-family: "Courier New", Courier, monospace ; }

    ol.text { margin-left: 2em; margin-right: 2em; }
    ul.text { margin-left: 2em; margin-right: 2em; }
    li { margin-left: 3em;  }

    pre { margin-left: 3em; color: #333333;  background-color: transparent;
        font-family: "Courier New", Courier, monospace ; font-size: small ;
        text-align: left;
        }

    h3 { color: #333333; font-size: medium ;
        font-family: helvetica, arial, sans-serif ;
        background-color: transparent; }
    h4 { font-size: small; font-family: helvetica, arial, sans-serif ; }

    table.bug { width: 30px ; height: 15px ; }
    td.bug { color: #ffffff ; background-color: #990000 ;
        text-align: center ; width: 30px ; height: 15px ;
         }
    td.bug A.link2 { color: #ffffff ; font-weight: bold;
        text-decoration: none;
        font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
        font-size: x-small ; background-color: transparent }

    td.header { color: #ffffff; font-size: x-small ;
        font-family: arial, helvetica, sans-serif; vertical-align: top;
        background-color: #666666 ; width: 33% ; }
    td.author { font-weight: bold; margin-left: 4em; font-size: x-small ; }
    td.author-text { font-size: x-small; }
    table.full { vertical-align: top ; border-collapse: collapse ;
        border-style: solid solid solid solid ;
        border-color: black black black black ;
        font-size: small ; text-align: center ; }
    table.headers, table.none { vertical-align: top ; border-collapse: collapse ;
        border-style: none;
        font-size: small ; text-align: center ; }
    table.full th { font-weight: bold ;
        border-style: solid ;
        border-color: black black black black ; }
    table.headers th { font-weight: bold ;
        border-style: none none solid none;
        border-color: black black black black ; }
    table.none th { font-weight: bold ;
        border-style: none; }
    table.full td {
        border-style: solid solid solid solid ;
        border-color: #333333 #333333 #333333 #333333 ; }
    table.headers td, table.none td { border-style: none; }

    hr { height: 1px }
-->
</style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">Network Working Group</td><td class="header">D. McGrew</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">Cisco Systems</td></tr>
<tr><td class="header">Expires:  September 21, 2006</td><td class="header">E. Rescorla</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">Network Resonance</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">March 20, 2006</td></tr>
</table></td></tr></table>
<div align="right"><span class="title"><br />Secure Real-time Transport
    Protocol (SRTP) Extensions for Datagram Transport Layer Security
    (DTLS)</span></div>
<div align="right"><span class="title"><br />draft-mcgrew-tls-srtp-00.txt</span></div>

<h3>Status of this Memo</h3>
<p>
By submitting this Internet-Draft,
each author represents that any applicable patent or other IPR claims of which
he or she is aware have been or will be disclosed,
and any of which he or she becomes aware will be disclosed,
in accordance with Section&nbsp;6 of BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF), its areas, and its working groups.
Note that other groups may also distribute working documents as
Internet-Drafts.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
The list of current Internet-Drafts can be accessed at
<a href='http://www.ietf.org/ietf/1id-abstracts.txt'>http://www.ietf.org/ietf/1id-abstracts.txt</a>.</p>
<p>
The list of Internet-Draft Shadow Directories can be accessed at
<a href='http://www.ietf.org/shadow.html'>http://www.ietf.org/shadow.html</a>.</p>
<p>
This Internet-Draft will expire on September 21, 2006.</p>

<h3>Copyright Notice</h3>
<p>
Copyright &copy; The Internet Society (2006).</p>

<h3>Abstract</h3>

<p>Secure Real-time Transport Protocol (SRTP) is a profile of
      the Real-time Transport Protocol which can provide
      confidentiality, message authentication, and replay protection
      to the RTP traffic and to the control traffic for RTP, the
      Real-time Transport Control Protocol (RTCP). This document
      describes a method of using DTLS key management for SRTP by
      creating a new extension which indicates that SRTP is to
      be used for data encryption.
   
</p><a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#anchor1">1.</a>&nbsp;
Introduction<br />
<a href="#anchor2">2.</a>&nbsp;
Conventions Used In This Document<br />
<a href="#anchor3">3.</a>&nbsp;
Protocol Description<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor4">3.1.</a>&nbsp;
Usage Model<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor5">3.2.</a>&nbsp;
Extension Definition<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor6">3.3.</a>&nbsp;
Key Derivation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor7">3.4.</a>&nbsp;
Key Usage Limitations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor8">3.5.</a>&nbsp;
Data Protection<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.transmit">3.5.1.</a>&nbsp;
Transmission<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor9">3.5.2.</a>&nbsp;
Reception<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.rehandshake">3.6.</a>&nbsp;
Rehandshake and Re-key<br />
<a href="#section.sec">4.</a>&nbsp;
Security Considerations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor10">4.1.</a>&nbsp;
Security of Negotiation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor11">4.2.</a>&nbsp;
Security of Established Keys<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor12">4.3.</a>&nbsp;
Framing Confusion<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor13">4.4.</a>&nbsp;
Sequence Number Interactions<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor14">4.4.1.</a>&nbsp;
Alerts<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor15">4.4.2.</a>&nbsp;
Rehandshake<br />
<a href="#anchor16">5.</a>&nbsp;
IANA Considerations<br />
<a href="#anchor17">6.</a>&nbsp;
Acknowledgments<br />
<a href="#rfc.references1">7.</a>&nbsp;
References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references1">7.1.</a>&nbsp;
Normative References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references2">7.2.</a>&nbsp;
Informational References<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Authors' Addresses<br />
<a href="#rfc.copyright">&#167;</a>&nbsp;
Intellectual Property and Copyright Statements<br />
</p>
<br clear="all" />

<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;Introduction</h3>

<p>
    Secure Real-time Transport Protocol (SRTP) <a class="info" href="#RFC3711">[9]<span> (</span><span class="info">Baugher, M., McGrew, D., Naslund, M., Carrara, E., and K. Norrman, &ldquo;The Secure Real-time Transport Protocol (SRTP),&rdquo; March&nbsp;2004.</span><span>)</span></a>
    is a profile of the
    Real-time Transport Protocol (RTP) <a class="info" href="#RFC1889">[1]<span> (</span><span class="info">Schulzrinne, H., Casner, S., Frederick, R., and V. Jacobson, &ldquo;RTP: A Transport Protocol for Real-Time Applications,&rdquo; January&nbsp;1996.</span><span>)</span></a> which can provide
    confidentiality, message authentication, and replay protection to
    RTP
    traffic and to the control traffic for RTP, the Real-time
    Transport Control Protocol (RTCP). SRTP does not provide key
    management functionality but instead depends on external key
    management.
    
</p>
<p>
    Datagram Transport Layer Security (DTLS) <a class="info" href="#I-D.rescorla-dtls">[4]<span> (</span><span class="info">Rescorla, E. and N. Modadugu, &ldquo;Datagram Transport Layer Security,&rdquo; June&nbsp;2005.</span><span>)</span></a>
    is a channel security protocol that offers integrated key management,
    parameter negotiation, and secure data transfer. Because DTLS's
    data transfer protocol is generic, it is less highly optimized
    for use with RTP than is SRTP, which has been specifically tuned
    for that purpose. This document describes an SRTP extension
    for DTLS which combine the the performance and encryption flexibility
    benefits of SRTP 
    with the flexibility and convenience of DTLS's integrated key
    and association management. This extension MUST only be used
    when the data being transported is RTP and RTCP <a class="info" href="#RFC3550">[3]<span> (</span><span class="info">Schulzrinne, H., Casner, S., Frederick, R., and V. Jacobson, &ldquo;RTP: A Transport Protocol for Real-Time Applications,&rdquo; July&nbsp;2003.</span><span>)</span></a>.
    
</p>
<p>
   The key points of our approach are as follows:
   </p>
<ul class="text">
<li>New mode negotiated via DTLS extension mechanism.
</li>
<li>Application data is protected using SRTP.
</li>
<li>Other content types are protected using the usual DTLS record
      format.
</li>
<li>The DTLS handshake is used to establish keying material and
   algorithm parameters for SRTP.
</li>
<li>The DTLS pseudo-random function (PRF) is used to generate the SRTP traffic encryption keys.
</li>
<li>The DTLS handshake is used to negotiate the algorithms.
</li>
</ul><p>
   The next section provides details of the new extension.
   
</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;Conventions Used In This Document</h3>

<p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
      document are to be interpreted as described in <a class="info" href="#RFC2119">[2]<span> (</span><span class="info">Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a>.
</p>
<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;Protocol Description</h3>

<p>
   In this section we provide a description of the new protocol
   elements introduced by this proposal.
   
</p>
<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1"></a><h3>3.1.&nbsp;Usage Model</h3>

<p>
   Our general model is to have a single DTLS association (called
   a "connection" in TLS jargon) for each media channel 
   (pair of unidirectional SRTP flows).
   [TODO: is this the right terminology?]
   A description of how to indicate this in SIP and SDP 
   and authenticate
   the endpoints using fingerprints can be found in 
   <a class="info" href="#I-D.fischl-mmusic-sdp-dtls">[6]<span> (</span><span class="info">Fischl, J. and H. Tschofenig, &ldquo;Session Description Protocol (SDP) Indicators for Datagram Transport Layer  Security (DTLS),&rdquo; March&nbsp;2006.</span><span>)</span></a> and
   <a class="info" href="#I-D.fischl-sipping-media-dtls">[5]<span> (</span><span class="info">Fischl, J., &ldquo;Session Initiation Protocol (SIP) for Media Over Datagram Transport Layer  Security (DTLS),&rdquo; March&nbsp;2006.</span><span>)</span></a>.
   
</p>
<p>
   In a naive implementation, this results in new DTLS session
   establishment (complete with public key cryptography) for
   each media channel. 
   A superior approach is to establish single DTLS connection
   in order to create the DTLS session and then use DTLS session
   resumption to establish DTLS connections for any additional
   media channels. This allows the amortization of the expensive
   public key cryptography operations over multiple handshakes.
   
</p>
<p>
   One issue that arises in this context is multiple RTP sender
   over the same DTLS channel. In order to avoid the "two-time pad"
   problem, each sender over the same DTLS association MUST
   use a distinct SSRC value, as described in Section 9.1 of RFC 3711.
   
</p>
<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2"></a><h3>3.2.&nbsp;Extension Definition</h3>

<p>
   [TODO: When we discussed this we had discussed using 
   a new cipher suite. However, after thinking about it a
   bit, I concluded an extension was cleaner (and at least
   less text for me to write.) If you feel differently, let
   me know and we can totally do it the other way.]
   
</p>
<p>
   In order to negotiate the use of SRTP data protection,
   clients MAY include an extension of type "use_srtp" in
   the extended client hello. The "extension_data" field of this
   extension shall be empty.
   
</p>
<p>
   Servers that receive an extended hello containing a "use_srtp"
   extension, MAY agree to use SRTP by including an 
   extension of type "use_srtp", with empty "extension_data", in
   the extended server hello. This process is shown below.
   
</p><pre>
      Client                                               Server

      ClientHello + use_srtp       --------&gt;
                                           ServerHello + use_srtp
                                                     Certificate*
                                               ServerKeyExchange*
                                              CertificateRequest*
                                   &lt;--------      ServerHelloDone
      Certificate*
      ClientKeyExchange
      CertificateVerify*
      [ChangeCipherSpec]
      Finished                     --------&gt;
                                               [ChangeCipherSpec]
                                   &lt;--------             Finished
      SRTP packets                 &lt;-------&gt;         SRTP packets
</pre>
<p>
   Once the "use_srtp" extension is negotiated, packets 
   of type "application_data" in
   the newly negotiated association (i.e., after the change_cipher_spec)
   SHOULD be protected using SRTP. [TODO: Note that you actually can 
   in theory intermix DTLS "application_data" traffic as well. Is there any
   value here?]
   Records of type other than
   "application_data" MUST use ordinary DTLS framing. When the "use_srtp"
   extension is in effect, implementations MUST NOT place more than
   one "record" per datagram. (This is only meaningful from the
   perspective of DTLS because SRTP is inherently oriented towards
   one payload per packet, but is stated purely for clarification.)
   
</p>
<p>
   The SRTP cipher and MAC algorithm used correspond directly to
   those in the negotiated DTLS cipher suite with the following exception:
   DTLS cipher suites which are block ciphers in CBC mode are
   used in CTR mode with SRTP (but still in CBC mode with DTLS
   records). DTLS only defines block ciphers so there is no concern
   about the use of stream ciphers.
   
</p>
<p>
   [TODO: Note that this precludes the use of F8 mode. I don't have
   a good sense of whether this is important or not. This is obviously
   a drawback of this extension approach. We could have the extension
   above indicate the block cipher mode (CTR or F8) if that's 
   important to preserve.]
   
</p>
<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3"></a><h3>3.3.&nbsp;Key Derivation</h3>

<p>
   When SRTP mode is in effect, different keys are used for 
   ordinary DTLS record protection and SRTP record protection.
   These keys are generated as additional keying material at
   the end of the DTLS key block. Thus, the key block becomes:
   
</p><pre>
     client_write_MAC_secret[SecurityParameters.hash_size]
     server_write_MAC_secret[SecurityParameters.hash_size]
     client_write_key[SecurityParameters.key_material_length]
     server_write_key[SecurityParameters.key_material_length]
     srtp_client_write_MAC_secret[SecurityParameters.hash_size]
     srtp_server_write_MAC_secret[SecurityParameters.hash_size]
     srtp_client_write_key[SecurityParameters.key_material_length]
     srtp_server_write_key[SecurityParameters.key_material_length]
     srtp_client_write_salt_secret[SecurityParameters.salt_size]
     srtp_server_write_salt_secret[SecurityParameters.salt_size]
</pre>
<p>
   [TODO: I think we can just use the same key sizes for the 
   algorithms as does DTLS. Is there a problem here I missed?]
   
</p>
<p>
   The last six values are mapped directly onto the SRTP values
   for each transform. The following table shows the mapping
   in the client to server direction:
   
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="right">
<tr><th align="left">DTLS Value</th><th align="right">SRTP Value</th></tr>
<tr>
<td align="left">srtp_client_write_MAC_secret</td>
<td align="right">k_a</td>
</tr>
<tr>
<td align="left">srtp_client_write_key</td>
<td align="right">k_e</td>
</tr>
<tr>
<td align="left">srtp_client_write_salt</td>
<td align="right">k_s</td>
</tr>
</table>

<p>
   Because we generate the SRTP keys directly, 
   the SRTP key derivation mechanism described in Section 4.3 
   of <a class="info" href="#RFC3711">[9]<span> (</span><span class="info">Baugher, M., McGrew, D., Naslund, M., Carrara, E., and K. Norrman, &ldquo;The Secure Real-time Transport Protocol (SRTP),&rdquo; March&nbsp;2004.</span><span>)</span></a> is not used. 
   
</p>
<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4"></a><h3>3.4.&nbsp;Key Usage Limitations</h3>

<p>
   [TODO: David McGrew]
   
</p>
<a name="anchor8"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.5"></a><h3>3.5.&nbsp;Data Protection</h3>

<p>
   Once the DTLS handshake has completed the peers can send
   RTP and RTCP over the newly created channel. We describe
   the transmission process first followed by the reception
   process.
   
</p>
<a name="section.transmit"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.5.1"></a><h3>3.5.1.&nbsp;Transmission</h3>

<p>
   DTLS and TLS define a number of record content types. In
   ordinary TLS/DTLS, all data is protected using the same 
   record encoding and mechanisms. When the mechanism described
   in this document is in effect, this is modified so that 
   data of type "application_data" (used to transport data traffic)
   is encrypted using SRTP rather than the standard TLS record encoding.
   
</p>
<p>
   When a user of DTLS wishes to send an RTP packet in SRTP mode
   it delivers it to the DTLS implementation as a single write
   of type "application_data". The DTLS implementation then 
   invokes the processing described in RFC 3711 Sections 3
   and 4. The resulting SRTP packet is then sent directly on
   the wire as a single datagram with no DTLS framing. This
   provides the same bits on the wire representation as SRTP for the data.
   Note that the RTP sequence number rather than the 
   DTLS sequence number is used for these packets.
   
</p>
<p>
   [TODO: How fixed is the SRTP MAC? Could we include the DTLS 
   record header in the MAC somehow just to make absolutely sure
   that we know the content type? That seems like it would be 
   nice from a security perspective for maximal ambiguity, even
   though the different keys thing does provide a fair amount 
   of insulation.]
   
</p>
<a name="anchor9"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.5.2"></a><h3>3.5.2.&nbsp;Reception</h3>

<p>
   In ordinary DTLS, the receiver can unambiguously determine
   the type of the record from the DTLS record header. However
   when SRTP and DTLS data is mixed over the same channel,
   the recipient must first determine which decryption
   mechanism to use. This can be done unambiguously using the
   following procedure.
   </p>
<ol class="text">
<li>Assume that the datagram is a DTLS record.
</li>
<li>If the first byte does not match a known DTLS content type go to step 6.
</li>
<li>If the version field does not match the current version go to step 6.
</li>
<li>If the length does not match the rest of the record, go to step 6.
</li>
<li>Attempt to decrypt and verify the DTLS record--omitting
   the replay check. If this process succeeds, the record must
   be DTLS. Deliver it to the rest of the DTLS implementation.
</li>
<li>Assume that the datagram is an SRTP packet and follow
   the procedure of Section 3 of RFC 3711. Note that the 
   replay detection check specified in DTLS SHOULD NOT be done for these packets. If anti-replay is desired SRTP anti-replay mechanisms SHOULD be used.

</li>
</ol><p>
   
</p>
<p>
   The first byte of a
   DTLS packet is "Type" which can currently have values of 20,21,22, and
   23 as defined in ContentType declaration in <a class="info" href="#I-D.ietf-tls-rfc2246-bis">[7]<span> (</span><span class="info">Dierks, T. and E. Rescorla, &ldquo;The TLS Protocol Version 1.1,&rdquo; June&nbsp;2005.</span><span>)</span></a>. It is reasonable to expect
   the first byte to remain under 64 and greater than 1. For RTP the
   first byte has a value that is 196 or above. 
   Thus, in general, the type check specified in step (2) is sufficient
   for unambigous interpretation, and checks (3), (4), and (5)
   are merely fallbacks in case of the unlikely event that
   the headers do change enough to make this first check less
   than completely definitive.
   
</p>
<p>
   If this procedure does not result in a successful verification
   and reception, the datagram SHOULD be silently discarded. 
   For testing and debugging purposes it MAY be desirable to generate
   an "invalid_MAC" alert, as specified in Section 4.1.2.1 of
   <a class="info" href="#I-D.rescorla-dtls">[4]<span> (</span><span class="info">Rescorla, E. and N. Modadugu, &ldquo;Datagram Transport Layer Security,&rdquo; June&nbsp;2005.</span><span>)</span></a>.
   
</p>
<a name="section.rehandshake"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.6"></a><h3>3.6.&nbsp;Rehandshake and Re-key</h3>

<p>
   Rekeying in DTLS is accomplished by performing a new handshake
   over the existing DTLS channel. This handshake can be performed
   in parallel with data transport, so no interruption of the 
   data flow is required. Once the handshake is finished, all records,
   including application_data records, simply switch over to the
   new keys.
   
</p>
<p>
   Because of packet reordering, data from the previous association
   can appear on the wire after the handshake has completed. This
   means that receivers must maintain both sets of keys for some
   time in order to be able to decrypt and verify older data records. In
   the ordinary DTLS record layer, this is accomplished by having
   an "epoch" value in each record that indicates which handshake
   the record is from. However, no such explicit field is present in SRTP.
   
</p>
<p>
   One approach would be to simply place the DTLS epoch value in
   the Master Key Identifier, but this would add two bytes to 
   every packet, which seems undesirable, given that rekeying is
   an infrequent event. Instead, we propose adapting the 
   rollover counter management algorithm of Section 3.3.1 of 
   RFC 3711. When a handshake has just been performed (during
   the MSL period after the handshake), the implementation
   SHOULD retain the pre-handshake set of keys. When a new
   packet arrives, it should try decrypting/authenticating
   with both sets of keys (using the sequence number to guess
   which key to try first). If either set succeeds, it should
   pass on the packet, otherwise it should be rejected.
   Once the MSL has expired, the previous keys can be discarded.
   This algorithm is easily extensible to the case where
   several handshakes happen in close succession, but such
   practice is NOT RECOMMENDED.
   
</p>
<a name="section.sec"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;Security Considerations</h3>

<p>
   The use of multiple data protection framings negotiated
   in the same handshake creates some complexities, which are
   discussed here.
   
</p>
<a name="anchor10"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1"></a><h3>4.1.&nbsp;Security of Negotiation</h3>

<p>
   One concern here is that attackers might be able to implement a
   bid-down attack forcing the peers to use ordinary DTLS rather than
   SRTP. However, because the negotiation of this extension is
   performed in the DTLS handshake, it is protected by the Finished
   messages. Therefore, any bid-down attack is automatically detected,
   which reduces this to a denial of service attack--which any attacker who can 
   control the channel can always mount.
   
</p>
<a name="anchor11"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2"></a><h3>4.2.&nbsp;Security of Established Keys</h3>

<p>
   [TODO: David, can you say something about NIST, the PRF, etc...?]
   
</p>
<a name="anchor12"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3"></a><h3>4.3.&nbsp;Framing Confusion</h3>

<p>
   Because two different framing formats are used, there is concern
   that an attacker could convince the receiver to treat an SRTP-framed
   RTP packet as a DTLS record (e.g., a handshake message) or 
   vice versa. This attack is prevented by using different keys
   for MAC verification for each type of data. Therefore, this type
   of attack reduces to being able to forge a packet with a valid
   MAC, which violates a basic security invariant of both DTLS
   and SRTP.
   
</p>
<p>
   As an additional defense against injection into the DTLS handshake
   channel, the DTLS record type is included in the MAC. Therefore,
   an SRTP record would be treated as an unknown type and
   ignored. (See Section 6 of <a class="info" href="#I-D.ietf-tls-rfc2246-bis">[7]<span> (</span><span class="info">Dierks, T. and E. Rescorla, &ldquo;The TLS Protocol Version 1.1,&rdquo; June&nbsp;2005.</span><span>)</span></a>).
   
</p>
<a name="anchor13"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4"></a><h3>4.4.&nbsp;Sequence Number Interactions</h3>

<p>
   As described in Section <a class="info" href="#section.transmit">Section&nbsp;3.5.1<span> (</span><span class="info">Transmission</span><span>)</span></a>,
   the SRTP and DTLS sequence number spaces are distinct. This means
   that it is not possible to unambiguously order a given DTLS
   control record with respect to an SRTP packet. In general, this
   is relevant in two situations: alerts and rehandshake.
   
</p>
<a name="anchor14"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4.1"></a><h3>4.4.1.&nbsp;Alerts</h3>

<p>
   Because DTLS handshake and change_cipher_spec
   messages share the same sequence number space as alerts, they
   can be ordered correctly.
   Because DTLS alerts are inherently unreliable and SHOULD NOT
   be generated as a response to data packets, reliable 
   sequencing between SRTP packets and DTLS alerts is not an
   important feature. However, implementations which wish 
   to use DTLS alerts to signal problems with the SRTP encoding
   SHOULD simply act on alerts as soon as they are received
   and assume that they refer to the temporally contiguous stream.
   Such implementations MUST check for alert retransmission and
   discard retransmitted alerts to 
   avoid overreacting to replay attacks.
   
</p>
<a name="anchor15"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4.2"></a><h3>4.4.2.&nbsp;Rehandshake</h3>

<p>
   Because the rehandshake transition algorithm specified in Section <a class="info" href="#section.rehandshake">Section&nbsp;3.6<span> (</span><span class="info">Rehandshake and Re-key</span><span>)</span></a> requires trying multiple sets of keys,
   it slightly weakens the authentication. For instance, if an n-bit
   MAC is used and k different sets of keys are present, then the MAC
   is weakened by log_2(k) bits to n - log_2(k). In practice, since
   the number of keys used will be very small and the MACs in use
   are typically strong (the default for SRTP is 80 bits) the decrease
   in security involved here is minimal.
   
</p>
<p>
   Another concern here is that this algorithm slightly increases
   the work factor on the receiver because it needs to attempt multiple
   validations. However, again, the number of potential keys will
   be very small (and the attacker cannot force it to be larger) and
   this technique is already used for rollover counter management,
   so the authors do not consider this to be a serious flaw.
   
</p>
<a name="anchor16"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;IANA Considerations</h3>

<p>
      This document a new extension for DTLS, in
accordance with <a class="info" href="#I-D.ietf-tls-rfc3546bis">[8]<span> (</span><span class="info">Blake-Wilson, S., &ldquo;Transport Layer Security (TLS) Extensions,&rdquo; October&nbsp;2005.</span><span>)</span></a>:

</p><pre>
      enum { use_srtp (??) } ExtensionType;
</pre>
<p>
   [[ NOTE: This value needs to be assigned by IANA ]]

</p>
<p>
This extension MUST only be used with DTLS.
      
</p>
<a name="anchor17"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;Acknowledgments</h3>

<p>
    Some people.
   
</p>
<a name="rfc.references"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;References</h3>

<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>7.1.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC1889">[1]</a></td>
<td class="author-text"><a href="mailto:schulzrinne@fokus.gmd.de">Schulzrinne, H.</a>, <a href="mailto:casner@precept.com">Casner, S.</a>, <a href="mailto:frederic@parc.xerox.com">Frederick, R.</a>, and <a href="mailto:van@ee.lbl.gov">V. Jacobson</a>, &ldquo;<a href="ftp://ftp.isi.edu/in-notes/rfc1889.txt">RTP: A Transport Protocol for Real-Time Applications</a>,&rdquo; RFC&nbsp;1889, January&nbsp;1996.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2119">[2]</a></td>
<td class="author-text"><a href="mailto:sob@harvard.edu">Bradner, S.</a>, &ldquo;<a href="ftp://ftp.isi.edu/in-notes/rfc2119.txt">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997 (<a href="ftp://ftp.isi.edu/in-notes/rfc2119.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2119.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2119.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3550">[3]</a></td>
<td class="author-text">Schulzrinne, H., Casner, S., Frederick, R., and V. Jacobson, &ldquo;<a href="ftp://ftp.isi.edu/in-notes/rfc3550.txt">RTP: A Transport Protocol for Real-Time Applications</a>,&rdquo; STD&nbsp;64, RFC&nbsp;3550, July&nbsp;2003 (<a href="ftp://ftp.isi.edu/in-notes/rfc3550.txt">TXT</a>, <a href="ftp://ftp.isi.edu/in-notes/rfc3550.ps">PS</a>, <a href="ftp://ftp.isi.edu/in-notes/rfc3550.pdf">PDF</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.rescorla-dtls">[4]</a></td>
<td class="author-text">Rescorla, E. and N. Modadugu, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-rescorla-dtls-05.txt">Datagram Transport Layer Security</a>,&rdquo; draft-rescorla-dtls-05 (work in progress), June&nbsp;2005.</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.fischl-sipping-media-dtls">[5]</a></td>
<td class="author-text">Fischl, J., &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-fischl-sipping-media-dtls-00.txt">Session Initiation Protocol (SIP) for Media Over Datagram Transport Layer  Security (DTLS)</a>,&rdquo; draft-fischl-sipping-media-dtls-00 (work in progress), March&nbsp;2006.</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.fischl-mmusic-sdp-dtls">[6]</a></td>
<td class="author-text">Fischl, J. and H. Tschofenig, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-fischl-mmusic-sdp-dtls-00.txt">Session Description Protocol (SDP) Indicators for Datagram Transport Layer  Security (DTLS)</a>,&rdquo; draft-fischl-mmusic-sdp-dtls-00 (work in progress), March&nbsp;2006.</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>7.2.&nbsp;Informational References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="I-D.ietf-tls-rfc2246-bis">[7]</a></td>
<td class="author-text">Dierks, T. and E. Rescorla, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-tls-rfc2246-bis-13.txt">The TLS Protocol Version 1.1</a>,&rdquo; draft-ietf-tls-rfc2246-bis-13 (work in progress), June&nbsp;2005.</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-tls-rfc3546bis">[8]</a></td>
<td class="author-text">Blake-Wilson, S., &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-tls-rfc3546bis-02.txt">Transport Layer Security (TLS) Extensions</a>,&rdquo; draft-ietf-tls-rfc3546bis-02 (work in progress), October&nbsp;2005.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3711">[9]</a></td>
<td class="author-text">Baugher, M., McGrew, D., Naslund, M., Carrara, E., and K. Norrman, &ldquo;<a href="ftp://ftp.isi.edu/in-notes/rfc3711.txt">The Secure Real-time Transport Protocol (SRTP)</a>,&rdquo; RFC&nbsp;3711, March&nbsp;2004.</td></tr>
</table>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">David McGrew</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Cisco Systems</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">510 McCarthy Blvd.</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Milpitas, CA  95305</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">USA</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:mcgrew@cisco.com">mcgrew@cisco.com</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Eric Rescorla</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Network Resonance</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">2483 E. Bayshore #212</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Palo Alto, CA  94303</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">USA</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:ekr@networkresonance.com">ekr@networkresonance.com</a></td></tr>
</table>
<a name="rfc.copyright"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Intellectual Property Statement</h3>
<p class='copyright'>
The IETF takes no position regarding the validity or scope of any
Intellectual Property Rights or other rights that might be claimed
to pertain to the implementation or use of the technology
described in this document or the extent to which any license
under such rights might or might not be available; nor does it
represent that it has made any independent effort to identify any
such rights.
Information on the procedures with respect to
rights in RFC documents can be found in BCP&nbsp;78 and BCP&nbsp;79.</p>
<p class='copyright'>
Copies of IPR disclosures made to the IETF Secretariat and any
assurances of licenses to be made available,
or the result of an attempt made to obtain a general license or
permission for the use of such proprietary rights by implementers or
users of this specification can be obtained from the IETF on-line IPR
repository at <a href='http://www.ietf.org/ipr'>http://www.ietf.org/ipr</a>.</p>
<p class='copyright'>
The IETF invites any interested party to bring to its attention
any copyrights,
patents or patent applications,
or other
proprietary rights that may cover technology that may be required
to implement this standard.
Please address the information to the IETF at <a href='mailto:ietf-ipr@ietf.org'>ietf-ipr@ietf.org</a>.</p>
<h3>Disclaimer of Validity</h3>
<p class='copyright'>
This document and the information contained herein are provided
on an &ldquo;AS IS&rdquo; basis and THE CONTRIBUTOR,
THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY),
THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM
ALL WARRANTIES,
EXPRESS OR IMPLIED,
INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE
INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.</p>
<h3>Copyright Statement</h3>
<p class='copyright'>
Copyright &copy; The Internet Society (2006).
This document is subject to the rights,
licenses and restrictions contained in BCP&nbsp;78,
and except as set forth therein,
the authors retain all their rights.</p>
<h3>Acknowledgment</h3>
<p class='copyright'>
Funding for the RFC Editor function is currently provided by the
Internet Society.</p>
</body></html>
