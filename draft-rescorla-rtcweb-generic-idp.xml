<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC3552 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3552.xml">
<!ENTITY RFC2818 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2818.xml">
<!ENTITY RFC3261 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3261.xml">
<!ENTITY RFC5479 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5479.xml">
<!ENTITY RFC4347 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4347.xml">
<!ENTITY RFC4568 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4568.xml">
<!ENTITY RFC5763 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5763.xml">
<!ENTITY RFC4251 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4251.xml">
<!ENTITY RFC3760 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3760.xml">
<!ENTITY RFC6189 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6189.xml">
<!ENTITY RFC5245 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5245.xml">
<!ENTITY RFC4627 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4627.xml">


<!ENTITY I-D.abarth-origin SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.abarth-origin">
<!ENTITY I-D.ietf-hybi-thewebsocketprotocol SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-hybi-thewebsocketprotocol">
<!ENTITY I-D.kaufman-rtcweb-security-ui SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.kaufman-rtcweb-security-ui">
<!ENTITY I-D.ietf-rtcweb-security SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-rtcweb-security">

]>
<?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc strict="yes" ?>
<?rfc compact="yes" ?>
<?rfc sortrefs="yes" ?>
<?rfc colonspace="yes" ?>
<?rfc rfcedstyle="no" ?>
<!-- Don't change this. It breaks stuff -->
<?rfc tocdepth="4"?>
<rfc category="std" docName="draft-rescorla-rtcweb-generic-idp"
     ipr="pre5378Trust200902">
  <front>
    <title abbrev="RTC-Web IdP">RTCWeb Generic Identity Provider Interface</title>

    <author fullname="Eric Rescorla" initials="E.K." surname="Rescorla">
      <organization>RTFM, Inc.</organization>

      <address>
        <postal>
          <street>2064 Edgewood Drive</street>

          <city>Palo Alto</city>

          <region>CA</region>

          <code>94303</code>

          <country>USA</country>
        </postal>

        <phone>+1 650 678 2350</phone>

        <email>ekr@rtfm.com</email>
      </address>
    </author>

    <date day="07" month="January" year="2012" />

    <area>RAI</area>

    <workgroup>RTC-Web</workgroup>

    <abstract>
      <t>
	Security for RTCWEB communications requires that the
 communicating endpoints be able to authenticate each 
 other. While authentication may be mediated by the 
 calling service, there are settings in which this is
 undesirable. This document describes a generic mechanism
 for leveraging existing identity providers
 (IdPs) such as BrowserID or OAuth to provide this
 authentication service.
      </t>
    </abstract>
    <note title="Legal">
      <t>THIS DOCUMENT AND THE INFORMATION CONTAINED THEREIN ARE PROVIDED ON
      AN &ldquo;AS IS&rdquo; BASIS AND THE CONTRIBUTOR, THE ORGANIZATION
      HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE
      IETF TRUST, AND THE INTERNET ENGINEERING TASK FORCE, DISCLAIM ALL
      WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY
      WARRANTY THAT THE USE OF THE INFORMATION THEREIN WILL NOT INFRINGE ANY
      RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A
      PARTICULAR PURPOSE.</t>
    </note>
  </front>

  <middle>
    <section title="Introduction" anchor="sec.introduction">
      <t>
 Security for RTCWEB communications requires that the
 communicating endpoints be able to authenticate each 
 other. While authentication may be mediated by the 
 calling service, there are settings in which this is
 undesirable. This document describes a generic mechanism
 for leveraging existing identity providers
 (IdPs) such as BrowserID or OAuth to provide this
 authentication service.
      </t>
    </section>

    <section title="Overview of Operation" anchor="sec.overview">
      <t>
 The RTCWEB component of the browser (which we assume to
 be trusted) interacts with the IdP in two modes:
      </t>
      <t>
 <list style="symbols">
   <t>As an authenticating party (AP).</t>
   <t>As a relying party (RP).</t>
 </list>
      </t>
      <t>
 As an AP, the user has an account relationship
 with the IdP. As an RP, the user merely has to
 be prepared to trust the IdP. In some cases,
 (what BrowserId calls a "primary"), the IdP
 is attesting to an identity which it itself
 controls (e.g., Facebook is authoritative for
 which user has a particular Facebook identity),
 and in other cases (what BrowserID calls a secondary),
 a greater level of trust and/or configuration is
 required.
      </t>
      <t>
 The basic architecture is shown below:
      </t>
      <figure>
 <artwork><![CDATA[
      +------------------------------------+
      |  https://calling-site.example.com  |
      |                                    |
      |                                    |
      |                                    |
      |         Calling JS Code            |
      |                ^                   |
      |                | API Calls         |
      |                v                   |
      |         PeerConnection             |
      |                ^                   |
      |                | postMessage()     |
      |                v                   |
      |    +-------------------------+     |     +---------------+
      |    | https://idp.example.org |     |     |               |
      |    |                         |<--------->|   Identity    |   
      |    |        IdP JS           |     |     |   Provider    |
      |    |                         |     |     |               |
      |    +-------------------------+     |     +---------------+
      |                                    |
      +------------------------------------+
  ]]></artwork>
      </figure>
      <t>
 The sequence of event is as follows:
      </t>
      <t>
 <list style="numbers">
   <t>The browser (the PeerConnection component)
   instantiates an IdP proxy (typically a hidden
   IFRAME) with its source at the IdP. This allows the 
   IdP to load whatever JS is necessary into the
   proxy, which runs in the IdP's security context.</t>
   <t>If the user is not already logged in, the
   IdP does whatever is required to log them in,
   such as soliciting a username and password.</t>
   <t>Once the user is logged in, the IdP proxy
   notifies the browser (via postMessage()) that
   it is ready.</t>
   <t>The browser and the IdP prixy communicate
   via a standardized series of messages
   delivered via postMessage. For instance,
   the browser might request the IdP proxy to
   sign or verify a given identity assertion.</t>
 </list>
      </t>
      <t>
 This approach allows us to decouple the browser from
 any particular identity provider; the browser need
 only know how to load the IdP's JavaScript--which
 is deterministic from the IdP's domain name--and
 the generic protocol for requesting and verifying
 assertions. The IdP provides whatever logic
 is necessary to bridge the generic protocol to
 the IdP's specific requirements. Thus, a single
 browser can support any number of identity protocols,
 including being forward compatible with IdPs which
 did not exist at the time the browser was written.
      </t>
    </section>
    <section title="Protocol Details" anchor="sec.protocol-details">
      <section title="General Message Structure">
 <t>
   Messages between the PeerConnection object and the
   IdP proxy are formatted using JSON <xref target="RFC4627"/>.
   For instance, the PeerConnection would request a 
   signature with the following "SIGN" message:
 </t>
 <figure>
 <artwork><![CDATA[
 { 
   "type":"SIGN",
   "id": "1",
   "message":"012345678abcdefghijkl"
 }
 ]]></artwork>
 </figure>
 <t>
   All messages MUST contain a "type" field which indicates
   the general meaning of the message.
 </t>
 <t>
   All requests from the PeerConnection object MUST contain
   an "id" field which MUST be unique for that PeerConnection
   object. Any responses from the IdP proxy MUST contain
   the same id in response, which allows the PeerConnection
   to correlate requests and responses.
 </t>
 <t>
   Any message-specific data is carried in a "message"
   field. Depending on the message type, this may
   either be a string or a deeper JSON object.
 </t>
 <section title="Errors">
   <t>
     If an error occurs, the IdP sends a message of
     type "ERROR". The message MAY have an
     "error" field containing freeform
     text data which containing additional
     information about what happened. For instance:
   </t>
 <figure title="Example error" anchor="fig.example-error">
 <artwork><![CDATA[
        {
          "type":"ERROR",
          "error":"Signature verification failed"
        }
 ]]></artwork>
 </figure>
 </section>
      </section>
      
      <section title="IdP Proxy Setup" anchor="sec.iframe-setup">
 <t>
   In order to perform an identity transaction, the PeerConnection
   must create the IdP proxy. While the specific technical
   mechanism used is left up to the implementation, the
   following requirements MUST be met for security and
   interoperability.
 </t>
 <t>
   <list style="symbols">
     <t>Any JS MUST run in the IdP's security context.</t>
     <t>The usual browser sandbox isolation mechanisms MUST
     be enforced with respect to the IdP proxy.</t>
     <t>JS running in the IdP proxy MUST be able to
     send and receive messages to the PeerConnection
     object using postMessage.</t>
     <t>Either window.parent or window.opener MUST
     be set such that messages sent with postMessage()
     arrive at the PeerConnection object. If both
     variables are set, they MUST be the same.</t>
     <t>Messages sent by the PeerConnection object
     MUST have their .origin value set to "rtcweb:://idp-interface".
     [TBD]</t>
   </list>
 </t>
 <t>
   One mechanism for implementing the IdP proxy is as a hidden
   (CSS "display=none") IFRAME with a URI as determined in <xref
   target="sec.idp-uri"/>. The PeerConnection component 
   will of course need to specially arrange for the 
   origin value to be set correctly; as dicussed in
   <xref target="sec.sec-cons"/>, the fact that ordinary
   Web pages cannot set their origins to "rtcweb://..."
   is an essential security feature.
 </t>
 <t>
   Initially the IdP proxy is in an unready state; the 
   IdP JS must be loaded and there may be several round 
   trips to the IdP server, for instance to log the user
   in. Thus, the IFRAME's "onready" property is not a reliable
   indicator of when the IdP IFRAME is ready to receive commands.
   Instead, when the IDP proxy is ready to receive commands,
   it delivers a "ready" message via postMessage(). As this
   message is unsolicited, it simply contains:
 </t>
      <figure>
 <artwork><![CDATA[
        { "type":"READY" }
  ]]></artwork>
      </figure>
      <t>
 Once the PeerConnection object receives the ready message,
 it can send commands to the IdP proxy.
      </t>
      <section title="Determining the IdP URI" anchor="sec.idp-uri">
 <t>
   Each IdP MUST serve its initial entry page
   (i.e., the one loaded by the IdP proxy) from
   the well-known URI "/.well-known/idp-proxy" on
   the IdP's web site. This URI MUST be loaded
   via HTTPS <xref target="RFC2818"/>.
 </t>
 <section title="Authenticating Party">
   <t>
     How an AP determines the appropriate IdP domain is
     out of scope of this specification. In general, 
     however, the AP has some actual account relationship 
     with the IdP, as this identity is what the IdP is 
     attesting to. Thus, the AP somehow supplies the
     IdP information to the browser. Some potential
     mechanisms include:
   </t>
   <t>
   <list style="symbols">
     <t>Provided by the user directly.</t>
     <t>Specified via a Web Intent. <eref target="http://webintents.org/"/></t>
     <t>Selected from some set of IdPs known to the calling site.
     E.g., "Authenticate via Facebook Connect"</t>
   </list>
 </t>
 </section>
 <section title="Relying Party">
   <t>
     Unlike the AP, the RP need not have any particular
     relationship with the IdP. Rather, it needs to be able
     to process whatever assertion is provided by the AP.
     As the assertion contains the IdP's identity,
     the URI can be constructed directly from the 
     assertion. Section [TODO] describes the
     relevant security considerations.
   </t>
 </section>
      </section>
      </section>
      <section title="Requesting Assertions" anchor="sec.request-assert">
 <t>
   In order to request an assertion, the PeerConnection
   sends a "SIGN" message. Aside from the mandatory fields,
   this message has a "contents" field containing a string.
   The contents of this string are defined in 
   <xref target="I-D.ietf-rtcweb-security"/>, but are
   opaque from the perspective of this protocol.
 </t>
 <t>
   A successful response to a "SIGN" message contains
   an "assertion" field which is a verifiable assertion
   over the "contents" value. The exact format of this
   assertion are out of scope for this standard.
   However, the assertion MUST be securely bound to
   the contents such that the RP (potentially with
   the assistance of the IdP) to recover the 
   contents value and the identity of the AP
   and have confidence that they are as intended
   by the IdP at the time of assertion generation.
 </t>
 <t>
   <xref target="fig.assert-request"/> shows an
   example transaction, with the message 
   "abcde..." being signed and bound to identity
   "ekr@example.org". The "signature" field contains
   an HMAC over the identity and the message,
   but this is an implementation detail, and
   many other techniques (e.g., digital signatures)
   could be used here. Line breaks are inserted
   solely for readability.
 </t>
 
      <figure title="Example assertion request" anchor="fig.assert-request">
 <artwork><![CDATA[
    PeerConnection -> IdP proxy:
      {
        "type":"SIGN",
         "id":1,
         "message":"abcdefghijklmnopqrstuvwyz"
      }
      
    IdPProxy -> PeerConnection:
      {
        "type":"SUCCESS",
        "id":1,
        "message":"{\"content\":\"[\\\"bob@example.org\\\",
          \\\"abcdefghijklmnopqrstuvwyz\\\"]\",\"signature\":
          \"1d5f87802b78ca326eefda48d7d1af3c53a4e764\"}"
      }
  ]]>
 </artwork>
      </figure>
      </section>

      <section title="Verifying Assertions" anchor="sec.verify-assert">
 <t>
   In order to verify an assertion, an RP sends a "VERIFY"
   message to the IdP proxy containing the assertion 
   supplied by the AP in the "message" field.
 </t>
 <t>
   The IdP proxy verifies the assertion. Depending on the
   identity protocol, this may require one or more round
   trips to the IdP. For instance, an OAuth-based protocol
   will probably require using the IdP as an oracle,
   whereas with BrowserID the IdP proxy can likely
   verify the signature on the assertion without
   contacting the IdP, provided that it has cached
   the IdP's public key. Regardless of the mechanism,
   if verification succeeds, the IdP proxy returns
   the identity of the AP and the original message
   used when the assertion was generated as a JSON
   encoded version of a JS array. <xref target="fig.verify-request"/> shows
   an example transaction. Line breaks are inserted
   solely for readability. 
   [[OPEN ISSUE: Should this be JSON encoded or be an array?]]
 </t>

 <figure title="Example assertion request" anchor="fig.verify-request">
 <artwork><![CDATA[
      PeerConnection -> IdP Proxy:
        {
          "type":"VERIFY",
          "id":2,
          "message":"{\"content\":\"[\\\"bob@example.org\\\",
            \\\"abcdefghijklmnopqrstuvwyz\\\"]\",
            \"signature\":\"1d5f87802b78ca326eefda48d7d1af3c53a4e764\"}"
        }

      IdP Proxy -> PeerConnection:
        {
         "type":"SUCCESS",
         "id":2,
         "message":"[\"100001682090590\",\"abcdefghijklmnopqrstuvwyz\"]"
        }
  ]]>
 </artwork>
      </figure>
      </section>
      <section title="PostMessage Checks" anchor="sec.postmessage">
	<t>
	  Because the PeerConnect object and the IdP proxy communicate
	  via postMessage(), it is essential to verify that the
	  origin of any message (contained in the event.origin
	  property) and source (contained in the event.source)
	  property are as expected:
	</t>
	<t>
	  <list style="symbols">
	    <t>
	      For messages from the PeerConnection object, the
	      IdP proxy MUST verify that the origin is
	      "rtcweb:://idp-interface" and that the source
	      matches either window.opener or window.parent.
	      If both are non-falsey, they MUST be equal.
	      If any of these checks fail, the message MUST
	      be rejected.
	    </t>
	    <t>
	      For messages from the IdP proxy, the PeerConnection
	      object MUST verify that the origin matches
	      the IdP's origin and that the source matches
	      the window/IFRAME opened for the IdP proxy.
	      
	    </t>
	  </list>
	</t>
	<t>
	  If any of these checks fail, the message MUST
	  be rejected. In general, mismatches SHOULD NOT
	  cause transaction failure, since malicious
	  JS might use bogus messages as a form of DoS
	  attack.
	</t>
      </section>
    </section>
    <section title="Security Considerations" anchor="sec.sec-cons">
      <t>
	
      </t>
    </section>
  </middle>

  <back>


    <references title="Normative References">
      &RFC2119;      
      &RFC2818;      
      &I-D.ietf-rtcweb-security;
      &RFC4627;
    </references>
    <references title="Informative References">
      &I-D.abarth-origin;
    </references>
  </back>
</rfc>