<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY I-D.ietf-tls-rfc2246-bis SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-tls-rfc2246-bis.xml">
<!ENTITY I-D.ietf-tls-rfc3546bis SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-tls-rfc3546bis.xml">
<!ENTITY I-D.rescorla-dtls SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.rescorla-dtls.xml">
<!ENTITY I-D.fischl-sipping-media-dtls SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.fischl-sipping-media-dtls.xml">
<!ENTITY I-D.fischl-mmusic-sdp-dtls SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.fischl-mmusic-sdp-dtls.xml">
<!ENTITY I-D.ietf-mmusic-sdescriptions SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-mmusic-sdescriptions.xml">

<!ENTITY rfc1889 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.1889.xml">
<!ENTITY rfc2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY rfc2327 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2327.xml">
<!ENTITY rfc2434 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2434.xml">
<!ENTITY rfc2508 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2508.xml">
<!ENTITY rfc2833 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2833.xml">
<!ENTITY rfc3095 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3095.xml">
<!ENTITY rfc3261 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3261.xml">
<!ENTITY rfc3280 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3280.xml">
<!ENTITY rfc3545 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3545.xml">
<!ENTITY rfc3550 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3550.xml">
<!ENTITY rfc3711 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3711.xml">
]>
<!-- $Id -->
<?rfc inline="yes"?>
<?rfc toc="yes" ?>
<?rfc symrefs="no" ?>
<?rfc iprnotified="no" ?>
<?rfc strict="yes" ?>
<?rfc compact="yes" ?>
<?rfc sortrefs="no" ?>
<?rfc colonspace='yes' ?>
<rfc category="std" docName="draft-mcgrew-tls-srtp-00.txt" 
     ipr="full3978"> 
  <front> 
    <title abbrev="SRTP Extension for DTLS">
      DTLS key establisihment for SRTP
<!-- Secure Real-time Transport
    Protocol (SRTP) Extensions for Datagram Transport Layer Security
    (DTLS)
-->
</title>


    <author fullname="David McGrew" initials="D." surname="McGrew">  
      <organization>Cisco Systems</organization> 
      <address> 
        <postal> 
	<street>510 McCarthy Blvd.</street>
          <city>Milpitas</city>
          <region>CA</region>
          <code>95305</code>
          <country>USA</country>
        </postal>
        <email>mcgrew@cisco.com</email>
      </address>
    </author>

    <author fullname="Eric Rescorla" initials="E." surname="Rescorla">
      <organization>Network Resonance</organization>
      <address>
        <postal>
          <street>2483 E. Bayshore #212</street>
          <city>Palo Alto</city>
          <region>CA</region>
          <code>94303</code>
          <country>USA</country>
        </postal>
        <email>ekr@networkresonance.com</email>
      </address>
    </author>
    <date day="20" month="March" year="2006" />

    <abstract>
      <t>Secure Real-time Transport Protocol (SRTP) is a profile of
      the Real-time Transport Protocol which can provide
      confidentiality, message authentication, and replay protection
      to the RTP traffic and to the control traffic for RTP, the
      Real-time Transport Control Protocol (RTCP). This document
      describes a method of using DTLS key management for SRTP by
      using a new extension that indicates that SRTP is to be used for
      data protection, and which establishes SRTP keys.
   </t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction">
    <t>
    Secure Real-time Transport Protocol (SRTP) <xref target="RFC3711"/>
    is a profile of the
    Real-time Transport Protocol (RTP) <xref target="RFC1889"/> which can provide
    confidentiality, message authentication, and replay protection to
    RTP
    traffic and to the control traffic for RTP, the Real-time
    Transport Control Protocol (RTCP). SRTP does not provide key
    management functionality but instead depends on external key
    management.
    </t>
    <t>
    Datagram Transport Layer Security (DTLS) <xref target="I-D.rescorla-dtls"/>
    is a channel security protocol that offers integrated key management,
    parameter negotiation, and secure data transfer. Because DTLS's
    data transfer protocol is generic, it is less highly optimized
    for use with RTP than is SRTP, which has been specifically tuned
    for that purpose. This document describes an SRTP extension
    for DTLS which combine the the performance and encryption flexibility
    benefits of SRTP 
    with the flexibility and convenience of DTLS's integrated key
    and association management. This extension MUST only be used
    when the data being transported is RTP and RTCP <xref target="RFC3550"></xref>.
    </t>
    <t>
   The key points of our approach are as follows:
   <list style="symbols">
   <t>Application data is protected using SRTP.</t>
   <t>The DTLS handshake is used to establish keying material, algorithms, and
     parameters for SRTP.</t>
    <!--
        EKT works by encrypting a 'master key' from which the other keys are derived.  With 
        the DTLS-PRF approach, we're incompatible with EKT unless we're careful about it
      -->
   <t>The DTLS pseudo-random function (PRF) is used to generate the SRTP encryption and authentication keys.</t>
   <t>A DTLS extension used to negotiate SRTP algorithms.</t>
   <t>Other content types are protected using the usual DTLS record
      format.</t>
   <!-- I deleted the following because I didn't understand it and the the other points in the list seemed complete to me

	<t>New mode negotiated via DTLS extension mechanism.</t>

	-->
   </list>
   The next section provides details of the new extension.
   </t>
   </section>
    <section title="Conventions Used In This Document">
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
      document are to be interpreted as described in <xref
      target="RFC2119"></xref>.</t>
    </section>

   <section title="Protocol Description">
   <t>
   In this section we provide a description of the new protocol
   elements introduced by this proposal.
   </t>
   <section title="Usage Model">
      <t>
        DTLS-SRTP is defined for point-to-point media sessions, in
        which there are exactly two participants.  A DTLS-SRTP session
        corresponds to a pair of complementary unidirectional RTP
        flows.  Between a single pair of participants, there may be
        multiple media sessions; each session MUST have its own
        DTLS-SRTP session.  Additionally, each RTCP flow is protected
        by a separate DTLS-SRTP session.  One or both of the DTLS-SRTP
        session participants MAY be RTP mixers.
	Each DTLS-SRTP session contains a single DLTS association
	(called a "connection" in TLS jargon).
	
        <!-- What about the case in which a device receives audio but
           sends text?  What about a case in which a device sends and
           receives audio, but only recieves text on a separate port
           (separate SRTP session)?  Might want to use SRTP-DTLS with
           a mixer 
 
                  M
            A --- I 
            B --- X --- Audio Source 
            C --- E
                  R
 
             A separate DTLS port wouldn't have these problems -
           everyone would contact the mixer

	   Perhaps this case doesn't really matter.
        -->
        
      </t>
   <t>
     A DTLS-SRTP session can be indicated by an external
     signaling protocol like SIP.  When the signaling
     exchange is integrity-protected (e.g when SIP Identity
     protection via digital signatures is used), 
     DTLS-SRTP can leverage this integrity guarantee  
      to provide complete security of the media stream.
   A description of how to indicate DTLS-SRTP sessions  in SIP and SDP,
     and how to  authenticate
   the endpoints using fingerprints can be found in 
   <xref target="I-D.fischl-mmusic-sdp-dtls"/> and
   <xref target="I-D.fischl-sipping-media-dtls"/>.
   <!-- TODO: We need to check the "two m-lines" issue -->
   </t>
   <t>
     Each RTP stream participates in a single DTLS session.  In a
     naive implementation, this results in new DTLS session
     establishment (complete with public key cryptography) for each
     media channel.  For example, a videophone may be sending both an
     audio stream and a video stream, each of which would use a
     separate DTLS session establishment exchange, which would proceed
     in parallel.  As an optimization, the DTLS-SRTP implementation
     SHOULD use the following strategy: a single DTLS connection is
     established, and all other DTLS sessions wait until that
     connection is established before proceeding with their session
     establishment exchanges.  This strategy allows the later sessions
     to use the DTLS session re-start, which allows the amortization of
     the expensive public key cryptography operations over multiple
     DTLS session establishment instances.
   </t>
   <t>
    One issue that arises in this context is multiple RTP sender over
    the same DTLS channel. In order to avoid the "two-time pad" problem
    (as described in Section 9.1 of RFC 3711), distinct keys are used
    for each participant in the DTLS-SRTP session.
   </t>
   </section>
   <section title="use_srtp Extension">
   <t>
   In order to negotiate the use of SRTP data protection,
   clients MAY include an extension of type "use_srtp" in
   the extended client hello. The "extension_data" field of this
   extension contains the list of acceptable SRTP protection
   profiles, as indicated below.
   </t>
   <t>
   Servers that receive an extended hello containing a "use_srtp"
   extension, MAY agree to use SRTP by including an 
   extension of type "use_srtp", with the chosen protection
   profile in the extended server hello. This process is shown below.
   </t>
<figure>
<artwork>	
      Client                                               Server

      ClientHello + use_srtp       --------&gt;
                                           ServerHello + use_srtp
                                                     Certificate*
                                               ServerKeyExchange*
                                              CertificateRequest*
                                   &lt;--------      ServerHelloDone
      Certificate*
      ClientKeyExchange
      CertificateVerify*
      [ChangeCipherSpec]
      Finished                     --------&gt;
                                               [ChangeCipherSpec]
                                   &lt;--------             Finished
      SRTP packets                 &lt;-------&gt;      SRTP packets
</artwork>
</figure>
   <t>
   Once the "use_srtp" extension is negotiated, packets 
   of type "application_data" in
   the newly negotiated association (i.e., after the change_cipher_spec)
   SHOULD be protected using SRTP. 
   <!-- [TODO: Note that you actually can 
   in theory intermix DTLS "application_data" traffic as well. Is there any
   value here?]
   -->
   Records of type other than
   "application_data" MUST use ordinary DTLS framing. When the "use_srtp"
   extension is in effect, implementations MUST NOT place more than
   one "record" per datagram. (This is only meaningful from the
   perspective of DTLS because SRTP is inherently oriented towards
   one payload per packet, but is stated purely for clarification.)
   </t>
   <section title="use_srtp Extension Definition">
   <t>
   The client MUST fill the extension_data field of the 
   the "use_rtp" extension with an SRTPProtectionProfiles value:
   </t>
   <figure>
   <artwork	>
   uint8 SRTPProtectionProfile[2];

   SRTPProtectionProfiles SRTPProtectionProfiles;
   </artwork>
   </figure>
   <t>
   This list indicates the SRTP protection profiles that the 
   client is willing to support, listed in descending order
   of preference.
   </t>
   <t>
   If the server is willing to accept the use_srtp extension, it MUST
   respond with its own "use_srtp" extension in the
   ExtendedServerHello.  The extension_data field MUST be a
   SRTPProtectionProfile which contains the
   protection profile which the server has chosen for use with this
   connection. The server MUST NOT select a value which the client
   has not offered. If there is no shared profile, the 
   server should not return the use_srtp extension at which point
   the connection falls back to the negotiated DTLS cipher suite.
   If that is not acceptable the server should return an appropriate
   DTLS alert.
   </t>
   </section>
   <section title="SRTP Protection Profiles" anchor="section.propro">
   <t>
     A DTLS-SRTP SRTP Protection Profile defines the parameters and
     options that are in effect for the SRTP processing.  This
     document defines the following SRTP protection profiles.
   </t>
   <figure>
   <artwork>
   SRTPProtectionProfile SRTP_AES128_CM_SHA1_80 ={0x00, 0x01};
   SRTPProtectionProfile SRTP_AES128_CM_SHA1_32 ={0x00, 0x02};
   SRTPProtectionProfile SRTP_AES128_F8_SHA1_80 ={0x00, 0x03};
   SRTPProtectionProfile SRTP_AES128_F8_SHA1_32 ={0x00, 0x04};
   SRTPProtectionProfile SRTP_NULL_SHA1_80      ={0x00, 0x05};
   SRTPProtectionProfile SRTP_NULL_SHA1_32      ={0x00, 0x06};
   </artwork>
   </figure>							
   <t>
   The following list indicates the SRTP transform parameters for each
   protection profile.  The parameters cipher_key_length,
   cipher_salt_length, auth_key_length, and auth_tag_length express
   the number of bits in the values to which they refer.  The
   maximum_lifetime parameter indicates the maximum number of packets
   that can be protected with each single set of keys when the
   parameter profile is in use. 
   </t>
<!--   
   <texttable>
     <ttcol align="left">Profile</ttcol>
     <ttcol align="right">Cipher</ttcol>
     <ttcol align="right">Integrity</ttcol>
     
     <c>SRTP_AES128_CM_SHA1_80</c> 
     <c>AES128_CM</c>
     <c>HMAC-SHA1 (80 bit)</c>

     <c>SRTP_AES128_CM_SHA1_32</c> 
     <c>AES128_CM</c>
     <c>HMAC-SHA1 (32 bit)</c>

     <c>SRTP_AES128_F8_SHA1_80</c> 
     <c>AES128_F8</c>
     <c>HMAC-SHA1 (80 bit)</c>

     <c>SRTP_AES128_F8_SHA1_32</c> 
     <c>AES128_F8</c>
     <c>HMAC-SHA1 (32 bit)</c>


     <c>SRTP_NULL_SHA1_80</c> 
     <c>NULL</c>
     <c>HMAC-SHA1 (80 bit)</c>

     <c>SRTP_NULL_SHA1_32</c> 
     <c>NULL</c>
     <c>HMAC-SHA1 (32 bit)</c>

   </texttable>
-->
   <t>
 
     <list style="hanging">
       <t hangText="SRTP_AES128_CM_SHA1_80">
	 <list>
	   <t> cipher: AES_128_CM  </t>
	   <t> cipher_key_length: 128</t>
	   <t> cipher_salt_length: 112 </t>
	   <t> maximum_lifetime:   2^48 </t>
	   <t> auth_function: HMAC-SHA1 </t>
	   <t> auth_key_length: 160 </t>
	   <t> auth_tag_length: 80 </t>
	 </list>
       </t>
       <t hangText="SRTP_AES128_CM_SHA1_32">
	   Because of the short authentication tag provides limited authentication, this
	 profile SHOULD NOT be used with RTCP.
	 <list>
	   <t> cipher: AES_128_CM  </t>
	   <t> cipher_key_length: 128</t>
	   <t> cipher_salt_length: 112 </t>
	   <t> maximum_lifetime:   2^48 </t>
	   <t> auth_function: HMAC-SHA1 </t>
	   <t> auth_key_length: 160 </t>
	   <t> auth_tag_length: 32 </t>
	 </list>
       </t>
       <t hangText="SRTP_AES128_F8_SHA1_80">	 
	 <list>
	   <t> cipher: AES_128_F8  </t>
	   <t> cipher_key_length: 128</t>
	   <t> cipher_salt_length: 112 </t>
	   <t> maximum_lifetime:   2^48 </t>
	   <t> auth_function: HMAC-SHA1 </t>
	   <t> auth_key_length: 160 </t>
	   <t> auth_tag_length: 80 </t>
	 </list>
       </t>
       <t hangText="SRTP_AES128_F8_SHA1_32">
	   	 Because the short authentication tag provides limited authentication, this
	 profile SHOULD NOT be used with RTCP.
	 <list>
	   <t> cipher: AES_128_F8  </t>
	   <t> cipher_key_length: 128</t>
	   <t> cipher_salt_length: 112 </t>
	   <t> maximum_lifetime:   2^48 </t>
	   <t> auth_function: HMAC-SHA1 </t>
	   <t> auth_key_length: 160 </t>
	   <t> auth_tag_length: 32 </t>
	 </list>
       </t>
       <t hangText="SRTP_AES128_NULL_SHA1_80">	 
	 <list>
	   <t> cipher: NULL  </t>
	   <t> cipher_key_length: 0</t>
	   <t> cipher_salt_length: 0 </t>
	   <t> maximum_lifetime:   2^48 </t>
	   <t> auth_function: HMAC-SHA1 </t>
	   <t> auth_key_length: 160 </t>
	   <t> auth_tag_length: 80 </t>
	 </list>
       </t>
       <t hangText="SRTP_AES128_NULL_SHA1_32">
	   	 Because the short authentication tag provides limited authentication, this
	 profile SHOULD NOT be used with RTCP.
	 <list>
	   <t> cipher: NULL  </t>
	   <t> cipher_key_length: 0</t>
	   <t> cipher_salt_length: 0 </t>
	   <t> maximum_lifetime:   2^48 </t>
	   <t> auth_function: HMAC-SHA1 </t>
	   <t> auth_key_length: 160 </t>
	   <t> auth_tag_length: 32 </t>
	 </list>
       </t>
     </list>
     With all of these SRTP Parameter profiles, the following SRTP
     options are in effect:
     <list>
       <t>
	 The TLS Key Derivation Function (KDF) is used, and the SRTP default
       KDF is not used.
	 </t>
       <t>
	 The Key Derivation Rate (KDR) is equal to zero.  Thus, keys are not
	 re-derived based on the sequence number.     
	 </t>
       <t>
	 For all other parameters, the default values are used.
	 </t>
       </list>
     All SRTP parameters that are not determined by the SRTP
     Protection Profile MAY be established via the signaling system.
     In particular, the relative order of Forward Error Correction and
     SRTP processing, and a suggested SRTP replay window size SHOULD
     be established in this manner.  An example of how these parameters can 
     be defined for SDP by is contained in <xref target="I-D.ietf-mmusic-sdescriptions"/>. 
   </t>
   <t>
   New SRTPProtectionProfile values must be defined by RFC 2434 
   Standards Action. See Section <xref target="section.iana"/>
   for IANA Considerations.
   </t>
   </section>
   </section>

   <section title="Key Derivation">
   <t>
   When SRTP mode is in effect, different keys are used for 
   ordinary DTLS record protection and SRTP record protection.
   These keys are generated as additional keying material at
   the end of the DTLS key block. Thus, the key block becomes:
   </t>
   <figure>
   <artwork>
client_write_MAC_secret[SecurityParameters.hash_size]    
server_write_MAC_secret[SecurityParameters.hash_size]    
client_write_key[SecurityParameters.key_material_length] 
server_write_key[SecurityParameters.key_material_length] 
srtp_client_write_MAC_secret[SRTPSecurityParams.auth_key_length]    
srtp_server_write_MAC_secret[SRTPSecurityParams.auth_key_length]    
srtp_client_write_key[SRTPSecurityParams.cipher_key_length] 
srtp_server_write_key[SRTPSecurityParams.cipher_key_length] 
srtp_client_write_salt_secret[SRTPSecurityParams.cipher_salt_length]    
srtp_server_write_salt_secret[SRTPSecurityParams.cipher_salt_length]    
   </artwork>
   </figure>
   <t>
     <!-- 
   [TODO: I think we can just use the same key sizes for the 
   algorithms as does DTLS. Is there a problem here I missed?]

   I don't think this is a robust approach.  For example, what about AES SRTP CMAC?
   Instead, I defined the key lengths in the SRTPparameters
   -->
   </t>
   <t>
   The last six values are mapped directly onto the SRTP values
   for each transform. The following table shows the mapping
   in the client to server direction:
   </t>
      <texttable>
        <ttcol align="left">DTLS Value</ttcol>
        <ttcol align="right">SRTP Value</ttcol>

	<c>srtp_client_write_MAC_secret</c>
	<c>k_a</c>
	
	<c>srtp_client_write_key</c>
	<c>k_e</c>

	<c>srtp_client_write_salt</c>
	<c>k_s</c>
      </texttable>
   <t>
   Because we generate the SRTP keys directly, 
   the SRTP key derivation mechanism described in Section 4.3 
   of <xref target="RFC3711"/> is not used. 
   </t>
   </section>
   <section title="Key Scope">
     <t>
     The SRTP cipher and authentication function keys provided by DTLS-SRTP 
     are used as follows.
     <list>       
       <t>
	 The srtp_client_write_key is used to encrypt traffic that is
	 sent by the client.  It MUST NOT be used in encryption by the
	 server.
       </t>
       <t>
	 The srtp_client_write_salt_secret is used to randomize IV by some SRTP
	 ciphers; may be used as input to the encryption of traffic that is
	 sent by the client.  It MUST NOT be used in encryption by the
	 server.
       </t>
       <t>
	 The srtp_client_write_MAC_secret is used to generate authentication
	 tags for traffic that is sent by the client.  It MUST NOT be used
	 to generate tags for traffic that is sent by the server.
       </t>
       <t>
	 The srtp_server_write_key is used to encrypt traffic that is sent by
	 the server.  It MUST NOT be used in encryption by the client.
       </t>
       <t>
	 The srtp_server_write_salt_secret is used to randomize IV by some SRTP
	 ciphers; may be used as input to the encryption of traffic that is
	 sent by the server.  It MUST NOT be used in encryption by the
	 client.
       </t>
       <t>	 
	 The srtp_server_write_MAC_secret is used to generate authentication
	 tags for traffic that is sent by the server.  It MUST NOT be used
	 to generate tags for traffic that is sent by the client.
       </t>
     </list>
     </t>
     <t>
       The "use_srtp" extension conveys the RTP sequence number at
       which the SRTP keys derived after a DTLS handshake will be
       used.  Because of the possibility of packet reorder, DTLS-SRTP
       implementations SHOULD store multiple SRTP keys sets during a
       re-key in order to avoid the need for receivers to drop packets
       for which they lack a key. 
     </t>
   </section>
   <section title="Key Usage Limitations">
   <t>
     The maximum_lifetime parameter in the SRTP protection profile
     indicates the maximum number of packets that can be protected
     with each single encryption and authentication key.  Each profile
     defines its own limit.  When this limit is reached, a new DTLS
     session SHOULD be used to establish replacement keys, and SRTP
     implementations MUST NOT use the existing keys for the processing
     of either outbound or inbound traffic.
   </t>
   </section>
   <section title="Data Protection">
   <t>
   Once the DTLS handshake has completed the peers can send RTP and
   RTCP over the newly created channel. We describe the transmission
   process first followed by the reception process.
   </t>
   <t>
     Within each RTP session, SRTP processing MUST NOT take
     place before the DTLS handshake completes. 
   </t>
   <section title="Transmission" anchor="section.transmit">
   <t>
   DTLS and TLS define a number of record content types. In
   ordinary TLS/DTLS, all data is protected using the same 
   record encoding and mechanisms. When the mechanism described
   in this document is in effect, this is modified so that 
   data of type "application_data" (used to transport data traffic)
   is encrypted using SRTP rather than the standard TLS record encoding.
   </t>
   <t>
   When a user of DTLS wishes to send an RTP packet in SRTP mode
   it delivers it to the DTLS implementation as a single write
   of type "application_data". The DTLS implementation then 
   invokes the processing described in RFC 3711 Sections 3
   and 4. The resulting SRTP packet is then sent directly on
   the wire as a single datagram with no DTLS framing. This
   provides the same bits on the wire representation as SRTP for the data.
   Note that the RTP sequence number rather than the 
   DTLS sequence number is used for these packets.
   </t> 
   <!-- t>
   [TODO: How fixed is the SRTP MAC? Could we include the DTLS 
   record header in the MAC somehow just to make absolutely sure
   that we know the content type? That seems like it would be 
   nice from a security perspective for maximal ambiguity, even
   though the different keys thing does provide a fair amount 
   of insulation.]

   DAM : I don't think that we need to do this, since we've
   got very clean separation between SRTP keys and DTLS
   data-protection keys.  Perhaps we should add clarifying
   text or an example to show what we mean here.

   </t -->
   </section>
   <section title="Reception">
   <t>
   In ordinary DTLS, the receiver can unambiguously determine
   the type of the record from the DTLS record header. However
   when SRTP and DTLS data is mixed over the same channel,
   the recipient must first determine which decryption
   mechanism to use. This can be done unambiguously using the
   following procedure.
   <list style="numbers">
   <t>Assume that the datagram is a DTLS record.</t>
   <t>If the first byte does not match a known DTLS content type go to step 6.</t>
   <t>If the version field does not match the current version go to step 6.</t>
   <t>If the length does not match the rest of the record, go to step 6.</t>
   <t>Attempt to decrypt and verify the DTLS record--omitting
   the replay check. If this process succeeds, the record must
   be DTLS. Deliver it to the rest of the DTLS implementation.</t>
   <t>Assume that the datagram is an SRTP packet and follow
   the procedure of Section 3 of RFC 3711. Note that the 
   replay detection check specified in DTLS SHOULD NOT be done for these packets. 
     If anti-replay is desired SRTP anti-replay mechanisms SHOULD be used.
</t>
   </list>
   </t><t>
   The first byte of a
   DTLS packet is "Type" which can currently have values of 20,21,22, and
   23 as defined in ContentType declaration in <xref
   target="I-D.ietf-tls-rfc2246-bis"></xref>. It is reasonable to expect
   the first byte to remain under 64 and greater than 1. For RTP the
   first byte has a value that is 196 or above. 
   Thus, in general, the type check specified in step (2) is sufficient
   for unambigous interpretation, and checks (3), (4), and (5)
   are merely fallbacks in case of the unlikely event that
   the headers do change enough to make this first check less
   than completely definitive.
   </t>
   <t>
   If this procedure does not result in a successful verification
   and reception, the datagram SHOULD be silently discarded. 
   For testing and debugging purposes it MAY be desirable to generate
   an "invalid_MAC" alert, as specified in Section 4.1.2.1 of
   <xref target="I-D.rescorla-dtls"/>.
   </t>
   </section>
   </section>
   <section title="Rehandshake and Re-key" anchor="section.rehandshake">
   <t>
   Rekeying in DTLS is accomplished by performing a new handshake
   over the existing DTLS channel. This handshake can be performed
   in parallel with data transport, so no interruption of the 
   data flow is required. Once the handshake is finished, all records,
   including application_data records, simply switch over to the
   new keys.
   </t>
   <t>
   Because of packet reordering, data from the previous association
   can appear on the wire after the handshake has completed. This
   means that receivers must maintain both sets of keys for some
   time in order to be able to decrypt and verify older data records. In
   the ordinary DTLS record layer, this is accomplished by having
   an "epoch" value in each record that indicates which handshake
   the record is from. However, no such explicit field is present in SRTP.
   </t>
   <t>
   One approach would be to simply place the DTLS epoch value in
   the Master Key Identifier, but this would add two bytes to 
   every packet, which seems undesirable, given that rekeying is
   an infrequent event. Instead, we propose adapting the 
   rollover counter management algorithm of Section 3.3.1 of 
   RFC 3711. When a handshake has just been performed (during
   the MSL period after the handshake), the implementation
   SHOULD retain the pre-handshake set of keys. When a new
   packet arrives, it should try decrypting/authenticating
   with both sets of keys (using the sequence number to guess
   which key to try first). If either set succeeds, it should
   pass on the packet, otherwise it should be rejected.
   Once the MSL has expired, the previous keys can be discarded.
   This algorithm is easily extensible to the case where
   several handshakes happen in close succession, but such
   practice is NOT RECOMMENDED.
   </t>
   </section>
   </section>		
   <section anchor="section.sec" title="Security Considerations"> 
   <t>
   The use of multiple data protection framings negotiated
   in the same handshake creates some complexities, which are
   discussed here.
   </t>
   <section title="Security of Negotiation">
   <t>
   One concern here is that attackers might be able to implement a
   bid-down attack forcing the peers to use ordinary DTLS rather than
   SRTP. However, because the negotiation of this extension is
   performed in the DTLS handshake, it is protected by the Finished
   messages. Therefore, any bid-down attack is automatically detected,
   which reduces this to a denial of service attack--which any attacker who can 
   control the channel can always mount.
   </t>
   </section>
   <section title="Security of Established Keys">
   <t>
   [TODO: David, can you say something about NIST, the PRF, etc...?]
   </t>
   </section>
   <section title="Framing Confusion">
   <t>
   Because two different framing formats are used, there is concern
   that an attacker could convince the receiver to treat an SRTP-framed
   RTP packet as a DTLS record (e.g., a handshake message) or 
   vice versa. This attack is prevented by using different keys
   for MAC verification for each type of data. Therefore, this type
   of attack reduces to being able to forge a packet with a valid
   MAC, which violates a basic security invariant of both DTLS
   and SRTP.
   </t>
   <t>
   As an additional defense against injection into the DTLS handshake
   channel, the DTLS record type is included in the MAC. Therefore,
   an SRTP record would be treated as an unknown type and
   ignored. (See Section 6 of <xref target="I-D.ietf-tls-rfc2246-bis"/>).
   </t>
   </section>
   <section title="Sequence Number Interactions">
   <t>
   As described in Section <xref target="section.transmit"/>,
   the SRTP and DTLS sequence number spaces are distinct. This means
   that it is not possible to unambiguously order a given DTLS
   control record with respect to an SRTP packet. In general, this
   is relevant in two situations: alerts and rehandshake.
   </t>
   <section title="Alerts">
   <t>
   Because DTLS handshake and change_cipher_spec
   messages share the same sequence number space as alerts, they
   can be ordered correctly.
   Because DTLS alerts are inherently unreliable and SHOULD NOT
   be generated as a response to data packets, reliable 
   sequencing between SRTP packets and DTLS alerts is not an
   important feature. However, implementations which wish 
   to use DTLS alerts to signal problems with the SRTP encoding
   SHOULD simply act on alerts as soon as they are received
   and assume that they refer to the temporally contiguous stream.
   Such implementations MUST check for alert retransmission and
   discard retransmitted alerts to 
   avoid overreacting to replay attacks.
   </t>
   </section>
   <section title="Rehandshake">
   <t>
   Because the rehandshake transition algorithm specified in Section <xref
   target="section.rehandshake"/> requires trying multiple sets of keys,
   it slightly weakens the authentication. For instance, if an n-bit
   MAC is used and k different sets of keys are present, then the MAC
   is weakened by log_2(k) bits to n - log_2(k). In practice, since
   the number of keys used will be very small and the MACs in use
   are typically strong (the default for SRTP is 80 bits) the decrease
   in security involved here is minimal.
   </t>
   <t>
   Another concern here is that this algorithm slightly increases
   the work factor on the receiver because it needs to attempt multiple
   validations. However, again, the number of potential keys will
   be very small (and the attacker cannot force it to be larger) and
   this technique is already used for rollover counter management,
   so the authors do not consider this to be a serious flaw.
   </t>
   </section>
   </section>
   </section>

   <section title="IANA Considerations" anchor="section.iana"> 
      <t>
      This document a new extension for DTLS, in
accordance with <xref target="I-D.ietf-tls-rfc3546bis"/>:
</t>
<figure><artwork>
      enum { use_srtp (??) } ExtensionType;
</artwork></figure>
<t>
   [[ NOTE: This value needs to be assigned by IANA ]]
</t>
<t>
This extension MUST only be used with DTLS.
</t> 
<t>
Section <xref target="section.propro"/> requires that all SRTPProtectionProfile
values be defined by RFC 2434 Standards Action. IANA SHOULD
create a DTLS SRTPProtectionProfile registry initially populated
with values from Section <xref target="section.propro"/> of this document.
Future values MUST be allocated via Standards Action as described
in <xref target="RFC2434"/>
</t>     
   </section>

   <section title="Acknowledgments">
   <t>
    Some people.
   </t>
   </section>   

  </middle>

  <back>
    <references title="Normative References">
      &rfc1889;
      &rfc2119;
      &rfc2434;
<!--      &rfc3280; -->
      &rfc3550;
      &I-D.rescorla-dtls;
      &I-D.fischl-sipping-media-dtls;
      &I-D.fischl-mmusic-sdp-dtls;
      &I-D.ietf-mmusic-sdescriptions;

    </references>

    <references title="Informational References">
      &I-D.ietf-tls-rfc2246-bis;
      &I-D.ietf-tls-rfc3546bis;
      &rfc3711;

    </references>
  </back>
</rfc>
<!-- Keep this comment at the end of the file
Local variables:
mode: xml
sgml-omittag:nil
sgml-shorttag:nil
sgml-namecase-general:nil
sgml-general-insert-case:lower
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:2
sgml-indent-data:nil
sgml-parent-document:nil
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
